SCRIPT  /usr/share/vim/vim81/syntax/syncolor.vim
Sourced 3 times
Total time:   0.001395
 Self time:   0.001395

count  total (s)   self (s)
                            " Vim syntax support file
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2001 Sep 12
                            
                            " This file sets up the default methods for highlighting.
                            " It is loaded from "synload.vim" and from Vim for ":syntax reset".
                            " Also used from init_highlight().
                            
    3              0.000015 if !exists("syntax_cmd") || syntax_cmd == "on"
                              " ":syntax on" works like in Vim 5.7: set colors but keep links
    2              0.000023   command -nargs=* SynColor hi <args>
    2              0.000017   command -nargs=* SynLink hi link <args>
    1              0.000001 else
    1              0.000001   if syntax_cmd == "enable"
                                " ":syntax enable" keeps any existing colors
                                command -nargs=* SynColor hi def <args>
                                command -nargs=* SynLink hi def link <args>
    1              0.000002   elseif syntax_cmd == "reset"
                                " ":syntax reset" resets all colors to the default
    1              0.000008     command -nargs=* SynColor hi <args>
    1              0.000008     command -nargs=* SynLink hi! link <args>
                              else
                                " User defined syncolor file has already set the colors.
                                finish
    1              0.000000   endif
    3              0.000003 endif
                            
                            " Many terminals can only use six different colors (plus black and white).
                            " Therefore the number of colors used is kept low. It doesn't look nice with
                            " too many colors anyway.
                            " Careful with "cterm=bold", it changes the color to bright for some terminals.
                            " There are two sets of defaults: for a dark and a light background.
    3              0.000005 if &background == "dark"
    3              0.000041   SynColor Comment	term=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
    3              0.000035   SynColor Constant	term=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
    3              0.000037   SynColor Special	term=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
    3              0.000033   SynColor Identifier	term=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
    3              0.000031   SynColor Statement	term=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
    3              0.000032   SynColor PreProc	term=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
    3              0.000031   SynColor Type		term=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
    3              0.000030   SynColor Underlined	term=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
    3              0.000033   SynColor Ignore	term=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
                            else
                              SynColor Comment	term=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
                              SynColor Constant	term=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
                              SynColor Special	term=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=SlateBlue guibg=NONE
                              SynColor Identifier	term=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
                              SynColor Statement	term=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
                              SynColor PreProc	term=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=Purple guibg=NONE
                              SynColor Type		term=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
                              SynColor Underlined	term=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
                              SynColor Ignore	term=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
    3              0.000003 endif
    3              0.000032 SynColor Error		term=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
    3              0.000032 SynColor Todo		term=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
                            
                            " Common groups that link to default highlighting.
                            " You can specify other highlighting easily.
    3              0.000034 SynLink String		Constant
    3              0.000035 SynLink Character	Constant
    3              0.000033 SynLink Number		Constant
    3              0.000035 SynLink Boolean		Constant
    3              0.000033 SynLink Float		Number
    3              0.000034 SynLink Function	Identifier
    3              0.000033 SynLink Conditional	Statement
    3              0.000034 SynLink Repeat		Statement
    3              0.000033 SynLink Label		Statement
    3              0.000034 SynLink Operator	Statement
    3              0.000033 SynLink Keyword		Statement
    3              0.000032 SynLink Exception	Statement
    3              0.000033 SynLink Include		PreProc
    3              0.000033 SynLink Define		PreProc
    3              0.000033 SynLink Macro		PreProc
    3              0.000033 SynLink PreCondit	PreProc
    3              0.000033 SynLink StorageClass	Type
    3              0.000033 SynLink Structure	Type
    3              0.000033 SynLink Typedef		Type
    3              0.000033 SynLink Tag		Special
    3              0.000034 SynLink SpecialChar	Special
    3              0.000032 SynLink Delimiter	Special
    3              0.000034 SynLink SpecialComment	Special
    3              0.000032 SynLink Debug		Special
                            
    3              0.000011 delcommand SynColor
    3              0.000013 delcommand SynLink

SCRIPT  /home/carlos/.vim/plugged/deoplete.nvim/autoload/deoplete/custom.vim
Sourced 1 time
Total time:   0.000394
 Self time:   0.000394

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: custom.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000004 function! deoplete#custom#_init() abort
                              let s:custom = {}
                              let s:custom.source = {}
                              let s:custom.source._ = {}
                              let s:custom.option = deoplete#init#_option()
                              let s:custom.filter = {}
                            
                              let s:cached = {}
                              let s:cached.option = {}
                              let s:cached.filter = {}
                              let s:cached.buffer_option = {}
                              let s:cached.source_vars = {}
                            endfunction
    1              0.000002 function! deoplete#custom#_init_buffer() abort
                              let b:custom = {}
                              let b:custom.option = {}
                              let b:custom.source_vars = {}
                              let b:custom.filter = {}
                            endfunction
                            
    1              0.000002 function! deoplete#custom#_update_cache() abort
                              if !exists('s:custom')
                                call deoplete#custom#_init()
                              endif
                            
                              let custom_buffer = deoplete#custom#_get_buffer()
                            
                              let s:cached.option = copy(s:custom.option)
                              let s:cached.buffer_option = copy(custom_buffer.option)
                              call extend(s:cached.option, s:cached.buffer_option)
                            
                              let s:cached.source_vars = {}
                              for [name, source] in items(s:custom.source)
                                let s:cached.source_vars[name] = get(source, 'vars', {})
                              endfor
                              for [name, vars] in items(custom_buffer.source_vars)
                                if !has_key(s:cached.source_vars, name)
                                  let s:cached.source_vars[name] = {}
                                endif
                                call extend(s:cached.source_vars[name], vars)
                              endfor
                              let s:cached.filter = {}
                              for [name, vars] in items(s:custom.filter)
                                let s:cached.filter[name] = vars
                              endfor
                              for [name, vars] in items(custom_buffer.filter)
                                if !has_key(s:cached.filter, name)
                                  let s:cached.filter[name] = {}
                                endif
                                call extend(s:cached.filter[name], vars)
                              endfor
                            endfunction
                            
    1              0.000002 function! deoplete#custom#_get() abort
                              if !exists('s:custom')
                                call deoplete#custom#_init()
                              endif
                            
                              return s:custom
                            endfunction
    1              0.000002 function! deoplete#custom#_get_buffer() abort
                              if !exists('b:custom')
                                call deoplete#custom#_init_buffer()
                              endif
                            
                              return b:custom
                            endfunction
                            
    1              0.000002 function! deoplete#custom#_get_source(source_name) abort
                              let custom = deoplete#custom#_get().source
                            
                              if !has_key(custom, a:source_name)
                                let custom[a:source_name] = {}
                              endif
                            
                              return custom[a:source_name]
                            endfunction
    1              0.000002 function! deoplete#custom#_get_option(name) abort
                              return s:cached.option[a:name]
                            endfunction
    1              0.000003 function! deoplete#custom#_get_filetype_option(name, filetype, default) abort
                              let buffer_option = s:cached.buffer_option
                              if has_key(buffer_option, a:name)
                                " Use buffer_option instead
                                return buffer_option[a:name]
                              endif
                            
                              let option = s:cached.option[a:name]
                              let filetype = has_key(option, a:filetype) ? a:filetype : '_'
                              return get(option, filetype, a:default)
                            endfunction
    1              0.000002 function! deoplete#custom#_get_source_vars(name) abort
                              return get(s:cached.source_vars, a:name, {})
                            endfunction
    1              0.000002 function! deoplete#custom#_get_filter(name) abort
                              return get(s:cached.filter, a:name, {})
                            endfunction
                            
    1              0.000002 function! deoplete#custom#source(source_name, name_or_dict, ...) abort
                              for key in deoplete#util#split(a:source_name)
                                let custom_source = deoplete#custom#_get_source(key)
                                call s:set_custom(custom_source, a:name_or_dict, get(a:000, 0, ''))
                              endfor
                            endfunction
                            
    1              0.000002 function! deoplete#custom#var(source_name, name_or_dict, ...) abort
                              for key in deoplete#util#split(a:source_name)
                                let custom_source = deoplete#custom#_get_source(key)
                                let vars = get(custom_source, 'vars', {})
                                call s:set_custom(vars, a:name_or_dict, get(a:000, 0, ''))
                                call deoplete#custom#source(key, 'vars', vars)
                              endfor
                            endfunction
    1              0.000003 function! deoplete#custom#buffer_var(source_name, name_or_dict, ...) abort
                              let custom = deoplete#custom#_get_buffer().source_vars
                              for key in deoplete#util#split(a:source_name)
                                if !has_key(custom, key)
                                  let custom[key] = {}
                                endif
                                let vars = custom[key]
                                call s:set_custom(vars, a:name_or_dict, get(a:000, 0, ''))
                              endfor
                            endfunction
                            
    1              0.000002 function! deoplete#custom#filter(filter_name, name_or_dict, ...) abort
                              let custom = deoplete#custom#_get().filter
                              for key in deoplete#util#split(a:filter_name)
                                if !has_key(custom, key)
                                  let custom[key] = {}
                                endif
                                let vars = custom[key]
                                call s:set_custom(vars, a:name_or_dict, get(a:000, 0, ''))
                              endfor
                            endfunction
    1              0.000003 function! deoplete#custom#buffer_filter(filter_name, name_or_dict, ...) abort
                              let custom = deoplete#custom#_get_buffer().filter
                              for key in deoplete#util#split(a:filter_name)
                                if !has_key(custom, key)
                                  let custom[key] = {}
                                endif
                                let vars = custom[key]
                                call s:set_custom(vars, a:name_or_dict, get(a:000, 0, ''))
                              endfor
                            endfunction
                            
    1              0.000002 function! deoplete#custom#option(name_or_dict, ...) abort
                              let custom = deoplete#custom#_get().option
                              call s:set_custom(custom, a:name_or_dict, get(a:000, 0, ''))
                            endfunction
    1              0.000002 function! deoplete#custom#buffer_option(name_or_dict, ...) abort
                              let custom = deoplete#custom#_get_buffer().option
                              call s:set_custom(custom, a:name_or_dict, get(a:000, 0, ''))
                            endfunction
                            
    1              0.000003 function! s:set_custom(dest, name_or_dict, value) abort
                              if type(a:name_or_dict) == v:t_dict
                                call extend(a:dest, a:name_or_dict)
                              else
                                call s:set_value(a:dest, a:name_or_dict, a:value)
                              endif
                            endfunction
    1              0.000002 function! s:set_value(dest, name, value) abort
                              if type(a:value) == v:t_dict && !empty(a:value)
                                if !has_key(a:dest, a:name)
                                  let a:dest[a:name] = {}
                                endif
                                call extend(a:dest[a:name], a:value)
                              else
                                let a:dest[a:name] = a:value
                              endif
                            endfunction

SCRIPT  /home/carlos/.vim/plugged/deoplete.nvim/autoload/deoplete/init.vim
Sourced 1 time
Total time:   0.000478
 Self time:   0.000478

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: init.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000005 if !exists('s:is_handler_enabled')
    1              0.000003   let s:is_handler_enabled = 0
    1              0.000001 endif
                            
    1              0.000002 function! deoplete#init#_is_handler_enabled() abort
                              return s:is_handler_enabled
                            endfunction
                            
    1              0.000002 function! deoplete#init#_initialize() abort
                              if exists('g:deoplete#_initialized')
                                return 1
                              endif
                            
                              let g:deoplete#_initialized = v:false
                            
                              call deoplete#init#_custom_variables()
                              call deoplete#custom#_update_cache()
                            
                              call s:init_internal_variables()
                            
                              " For context_filetype check
                              silent! call context_filetype#get()
                            
                              if deoplete#init#_channel()
                                return 1
                              endif
                            
                              call deoplete#mapping#_init()
                            endfunction
    1              0.000002 function! deoplete#init#_channel() abort
                              if !exists('g:deoplete#_serveraddr')
                                return 1
                              endif
                            
                              let python3 = get(g:, 'python3_host_prog', 'python3')
                              if !executable(python3)
                                call deoplete#util#print_error(
                                      \ string(python3) . ' is not executable.')
                                call deoplete#util#print_error(
                                      \ 'You need to set g:python3_host_prog.')
                              endif
                              if has('nvim') && !has('nvim-0.3.0')
                                call deoplete#util#print_error('deoplete requires nvim 0.3.0+.')
                                return 1
                              endif
                              if !has('nvim') && v:version < 800
                                call deoplete#util#print_error('deoplete requires Vim 8.0+.')
                                return 1
                              endif
                            
                              try
                                if deoplete#util#has_yarp()
                                  let g:deoplete#_yarp = yarp#py3('deoplete')
                                  call g:deoplete#_yarp.notify('deoplete_init')
                                else
                                  " rplugin.vim may not be loaded on VimEnter
                                  if !exists('g:loaded_remote_plugins')
                                    runtime! plugin/rplugin.vim
                                  endif
                            
                                  call _deoplete_init()
                                endif
                              catch
                                call deoplete#util#print_error(v:exception)
                                call deoplete#util#print_error(v:throwpoint)
                            
                                if !has('python3')
                                  call deoplete#util#print_error(
                                        \ 'deoplete requires Python3 support("+python3").')
                                endif
                            
                                if deoplete#init#_python_version_check()
                                  call deoplete#util#print_error('deoplete requires Python 3.6.1+.')
                                endif
                            
                                if deoplete#util#has_yarp()
                                  if !exists('*yarp#py3')
                                    call deoplete#util#print_error(
                                          \ 'deoplete requires nvim-yarp plugin.')
                                  endif
                                else
                                  call deoplete#util#print_error(
                                      \ 'deoplete failed to load. '
                                      \ .'Try the :UpdateRemotePlugins command and restart Neovim. '
                                      \ .'See also :checkhealth.')
                                endif
                            
                                return 1
                              endtry
                            endfunction
    1              0.000002 function! deoplete#init#_channel_initialized() abort
                              return get(g:, 'deoplete#_initialized', v:false)
                            endfunction
    1              0.000002 function! deoplete#init#_enable_handler() abort
                              call deoplete#handler#_init()
                              let s:is_handler_enabled = 1
                            endfunction
    1              0.000002 function! deoplete#init#_disable_handler() abort
                              augroup deoplete
                                autocmd!
                              augroup END
                              let s:is_handler_enabled = 0
                            endfunction
                            
    1              0.000002 function! s:init_internal_variables() abort
                              call deoplete#init#_prev_completion()
                            
                              let g:deoplete#_context = {}
                            
                              if !exists('g:deoplete#_logging')
                                let g:deoplete#_logging = {}
                              endif
                              unlet! g:deoplete#_initialized
                              try
                                let g:deoplete#_serveraddr =
                                      \ deoplete#util#has_yarp() ?
                                      \ neovim_rpc#serveraddr() : v:servername
                                if g:deoplete#_serveraddr ==# ''
                                  " Use NVIM_LISTEN_ADDRESS
                                  let g:deoplete#_serveraddr = $NVIM_LISTEN_ADDRESS
                                endif
                              catch
                                call deoplete#util#print_error(v:exception)
                                call deoplete#util#print_error(v:throwpoint)
                            
                                if !has('python3')
                                  call deoplete#util#print_error(
                                        \ 'deoplete requires Python3 support("+python3").')
                                endif
                            
                                if deoplete#util#has_yarp()
                                  " Dummy call is needed to check exists()
                                  call neovim_rpc#serveraddr()
                                  if !exists('*neovim_rpc#serveraddr')
                                    call deoplete#util#print_error(
                                          \ 'deoplete requires vim-hug-neovim-rpc plugin in Vim.')
                                  endif
                                endif
                              endtry
                            endfunction
    1              0.000004 function! deoplete#init#_custom_variables() abort
                              if get(g:, 'deoplete#disable_auto_complete', v:false)
                                call deoplete#custom#option('auto_complete', v:false)
                              endif
                            
                              call s:check_custom_option(
                                    \ 'g:deoplete#auto_complete_delay',
                                    \ 'auto_complete_delay')
                              call s:check_custom_option(
                                    \ 'g:deoplete#auto_refresh_delay',
                                    \ 'auto_refresh_delay')
                              call s:check_custom_option(
                                    \ 'g:deoplete#camel_case',
                                    \ 'camel_case')
                              call s:check_custom_option(
                                    \ 'g:deoplete#ignore_case',
                                    \ 'ignore_case')
                              call s:check_custom_option(
                                    \ 'g:deoplete#ignore_sources',
                                    \ 'ignore_sources')
                              call s:check_custom_option(
                                    \ 'g:deoplete#keyword_patterns',
                                    \ 'keyword_patterns')
                              call s:check_custom_option(
                                    \ 'g:deoplete#max_list',
                                    \ 'max_list')
                              call s:check_custom_option(
                                    \ 'g:deoplete#num_processes',
                                    \ 'num_processes')
                              call s:check_custom_option(
                                    \ 'g:deoplete#auto_complete_start_length',
                                    \ 'min_pattern_length')
                              call s:check_custom_option(
                                    \ 'g:deoplete#enable_on_insert_enter',
                                    \ 'on_insert_enter')
                              call s:check_custom_option(
                                    \ 'g:deoplete#enable_profile',
                                    \ 'profile')
                              call s:check_custom_option(
                                    \ 'g:deoplete#enable_refresh_always',
                                    \ 'refresh_always')
                              call s:check_custom_option(
                                    \ 'g:deoplete#skip_chars',
                                    \ 'skip_chars')
                              call s:check_custom_option(
                                    \ 'g:deoplete#sources',
                                    \ 'sources')
                              call s:check_custom_option(
                                    \ 'g:deoplete#enable_smart_case',
                                    \ 'smart_case')
                              call s:check_custom_option(
                                    \ 'g:deoplete#enable_complete_suffix',
                                    \ 'complete_suffix')
                              call s:check_custom_option(
                                    \ 'g:deoplete#enable_yarp',
                                    \ 'yarp')
                            
                              " Source variables
                              call s:check_custom_var('file',
                                    \ 'g:deoplete#file#enable_buffer_path',
                                    \ 'enable_buffer_path')
                              call s:check_custom_var('omni',
                                    \ 'g:deoplete#omni#input_patterns',
                                    \ 'input_patterns')
                              call s:check_custom_var('omni',
                                    \ 'g:deoplete#omni#functions',
                                    \ 'functions')
                            endfunction
                            
    1              0.000003 function! s:check_custom_var(source_name, old_var, new_var) abort
                              if !exists(a:old_var)
                                return
                              endif
                            
                              call deoplete#util#print_error(
                                    \ printf('%s is deprecated variable.  '.
                                    \ 'Please use deoplete#custom#var() instead.', a:old_var))
                              call deoplete#custom#var(a:source_name, a:new_var, eval(a:old_var))
                            endfunction
    1              0.000003 function! s:check_custom_option(old_var, new_var) abort
                              if !exists(a:old_var)
                                return
                              endif
                            
                              call deoplete#util#print_error(
                                    \ printf('%s is deprecated variable.  '.
                                    \ 'Please use deoplete#custom#option() instead.', a:old_var))
                              call deoplete#custom#option(a:new_var, eval(a:old_var))
                            endfunction
                            
    1              0.000002 function! deoplete#init#_option() abort
                              " Note: HTML omni func use search().
                              return {
                                    \ 'auto_complete': v:true,
                                    \ 'auto_complete_delay': 0,
                                    \ 'auto_complete_popup': 'auto',
                                    \ 'auto_refresh_delay': 100,
                                    \ 'camel_case': v:false,
                                    \ 'candidate_marks': [],
                                    \ 'check_stderr': v:true,
                                    \ 'complete_suffix': v:true,
                                    \ 'ignore_case': &ignorecase,
                                    \ 'ignore_sources': {},
                                    \ 'keyword_patterns': {'_': '[a-zA-Z_]\k*'},
                                    \ 'max_list': 500,
                                    \ 'min_pattern_length': 2,
                                    \ 'num_processes': 4,
                                    \ 'omni_patterns': {},
                                    \ 'on_insert_enter': v:true,
                                    \ 'on_text_changed_i': v:true,
                                    \ 'prev_completion_mode': '',
                                    \ 'profile': v:false,
                                    \ 'refresh_always': v:true,
                                    \ 'skip_chars': ['(', ')'],
                                    \ 'skip_multibyte': v:false,
                                    \ 'smart_case': &smartcase,
                                    \ 'sources': {},
                                    \ 'trigger_key': v:char,
                                    \ 'yarp': v:false,
                                    \ }
                            endfunction
    1              0.000002 function! deoplete#init#_prev_completion() abort
                              let g:deoplete#_prev_completion = {
                                    \ 'event': '',
                                    \ 'input': '',
                                    \ 'linenr': -1,
                                    \ 'candidates': [],
                                    \ 'complete_position': -1,
                                    \ }
                            endfunction
                            
    1              0.000002 function! deoplete#init#_python_version_check() abort
                              python3 << EOF
                            import vim
                            import sys
                            vim.vars['deoplete#_python_version_check'] = (
                                sys.version_info.major,
                                sys.version_info.minor,
                                sys.version_info.micro) < (3, 6, 1)
                            EOF
                              return get(g:, 'deoplete#_python_version_check', 0)
                            endfunction
                            
    1              0.000002 function! deoplete#init#_msgpack_version_check() abort
                              python3 << EOF
                            import vim
                            import msgpack
                            vim.vars['deoplete#_msgpack_version'] = msgpack.version
                            vim.vars['deoplete#_msgpack_version_check'] = msgpack.version < (1, 0, 0)
                            EOF
                              return get(g:, 'deoplete#_msgpack_version_check', 0)
                            endfunction

SCRIPT  /home/carlos/.vim/plugged/vim-colorschemes/colors/atom.vim
Sourced 1 time
Total time:   0.003614
 Self time:   0.002201

count  total (s)   self (s)
                            "Maintainer:    Greg Sexton <gregsexton@gmail.com>
                            "Last Change:   2011-04-22
                            "Version:       1.1
                            "URL:           http://www.gregsexton.org/vim-color-schemes/atom-color/
                            
    1   0.000989   0.000515 set background=dark
    1              0.000002 if version > 580
                                "no guarantees for version 5.8 and below, but this makes it stop complaining
    1   0.001488   0.001015     hi clear
    1              0.000004     if exists("syntax_on")
    1   0.000725   0.000259 	syntax reset
    1              0.000001     endif
    1              0.000001 endif
    1              0.000003 let g:colors_name="atom"
                            
    1              0.000007 hi Normal       guifg=#e8ecf0     guibg=#304050
                            
    1              0.000007 hi DiffDelete   guifg=#304050     guibg=#203040
    1              0.000007 hi DiffAdd      guibg=#002851
    1              0.000006 hi DiffChange   guibg=#450303
    1              0.000007 hi DiffText     guibg=#990909     gui=none
                            
    1              0.000008 hi diffAdded    guifg=#00bf00     guibg=#1d2c1b
    1              0.000008 hi diffRemoved  guifg=#e00000     guibg=#2d1c20
                            
    1              0.000009 hi Cursor       guibg=khaki       guifg=slategrey
    1              0.000007 hi VertSplit    guibg=#102030     guifg=#102030   gui=none
    1              0.000007 hi Folded       guifg=#cccccc     guibg=#405060
    1              0.000012 hi FoldColumn   guibg=grey30      guifg=tan
    1              0.000008 hi IncSearch    guifg=slategrey   guibg=khaki
    1              0.000006 hi LineNr       guifg=#556575     guibg=#203040
    1              0.000008 hi ModeMsg      guifg=goldenrod
    1              0.000006 hi MoreMsg      guifg=SeaGreen
    1              0.000007 hi NonText      guifg=#304050     guibg=#304050
    1              0.000007 hi Question     guifg=springgreen
    1              0.000007 hi Search       guibg=#ffff7d     guifg=#000000
    1              0.000008 hi SpecialKey   guifg=yellowgreen
    1              0.000011 hi StatusLine   guibg=#102030     guifg=grey70    gui=none
    1              0.000007 hi StatusLineNC guibg=#203040     guifg=grey50    gui=none
    1              0.000007 hi Title        guifg=indianred
    1              0.000008 hi Visual       gui=none          guifg=white     guibg=#D04040
    1              0.000007 hi WarningMsg   guifg=salmon
    1              0.000006 hi Directory    guifg=#A6E22E
    1              0.000006 hi SignColumn   guifg=#A6E22E     guibg=#203040
                            
    1              0.000002 if version >= 700 " Vim 7.x specific colors
    1              0.000007     hi CursorLine   guifg=NONE    guibg=#203040 gui=NONE
    1              0.000007     hi CursorColumn guifg=NONE    guibg=#203040 gui=NONE
    1              0.000007     hi MatchParen   guifg=red     guibg=#304050 gui=BOLD
    1              0.000007     hi Pmenu        guifg=#f6f3e8 guibg=#152535 gui=NONE
    1              0.000007     hi PmenuSel     guifg=#000000 guibg=#cae682 gui=NONE
    1              0.000001 endif
                            
    1              0.000002 if version >= 703 " Vim 7.x specific colors
    1              0.000006     hi ColorColumn  guifg=#e8ecf0 guibg=#283848
    1              0.000001 endif
                            
                            " syntax highlighting groups
    1              0.000006 hi Comment    guifg=#8090a0   gui=none
    1              0.000006 hi Constant   guifg=#ff6070   gui=none
    1              0.000007 hi Identifier guifg=#70d080   gui=none
    1              0.000006 hi Statement  guifg=#6699D0   gui=none
    1              0.000007 hi PreProc    guifg=indianred gui=none
    1              0.000007 hi Type       guifg=#8cd0d3   gui=none
    1              0.000006 hi Special    guifg=#ecad2b   gui=none
    1              0.000006 hi Delimiter  guifg=#8090a0
    1              0.000006 hi Number     guifg=#FFFF80
    1              0.000006 hi Ignore     guifg=grey40    gui=none
    1              0.000008 hi Todo       guifg=orangered guibg=#304050 gui=none
                            
                            "vim: sw=4

SCRIPT  /home/carlos/.vim/plugged/vim-session/autoload/xolox/session.vim
Sourced 1 time
Total time:   0.001077
 Self time:   0.001069

count  total (s)   self (s)
                            " Public API for the vim-session plug-in.
                            "
                            " Author: Peter Odding
                            " Last Change: November 1, 2015
                            " URL: http://peterodding.com/code/vim/session/
                            
    1              0.000004 let g:xolox#session#version = '2.13.1'
                            
                            " Public API for session persistence. {{{1
                            
    1              0.000003 function! xolox#session#save_session(commands, filename) " {{{2
                              " Save the current Vim editing session to a Vim script using the
                              " [:mksession] [] command and some additional Vim magic provided by the
                              " vim-session plug-in. When the generated session script is later sourced
                              " using the [:source] [] command (possibly in another process or even on
                              " another machine) it will restore the editing session to its previous state
                              " (provided all of the files involved in the session are still there at
                              " their original locations).
                              "
                              " The first argument is expected to be a list, it will be extended with the
                              " lines to be added to the session script. The second argument is expected
                              " to be the filename under which the script will later be saved (it's
                              " embedded in a comment at the top of the script).
                              "
                              " [:mksession]: http://vimdoc.sourceforge.net/htmldoc/starting.html#:mksession
                              " [:source]: http://vimdoc.sourceforge.net/htmldoc/repeat.html#:source
                              let is_all_tabs = xolox#session#include_tabs()
                              call add(a:commands, '" ' . a:filename . ':')
                              call add(a:commands, '" Vim session script' . (is_all_tabs ? '' : ' for a single tab page') . '.')
                              call add(a:commands, '" Created by session.vim ' . g:xolox#session#version . ' on ' . strftime('%d %B %Y at %H:%M:%S.'))
                              call add(a:commands, '" Open this file in Vim and run :source % to restore your session.')
                              call add(a:commands, '')
                              if &verbose >= 1
                                call add(a:commands, 'set verbose=' . &verbose)
                              endif
                              " We save the GUI options only for global sessions, not for tab scoped
                              " sessions. Also, if the Vim we're currently running in doesn't have GUI
                              " support, Vim will report &go as an empty string. We should never persist
                              " this value if the user didn't specifically set it! Otherwise the next time
                              " the session is restored in a GUI Vim, things will look funky :-).
                              if has('gui') && is_all_tabs
                                call add(a:commands, 'set guioptions=' . escape(&go, ' "\'))
                                if xolox#misc#option#get('session_persist_font', 1)
                                  call add(a:commands, 'silent! set guifont=' . escape(&gfn, ' "\'))
                                endif
                              endif
                              call xolox#session#save_globals(a:commands)
                              if is_all_tabs
                                call xolox#session#save_features(a:commands)
                                if g:session_persist_colors
                                  call xolox#session#save_colors(a:commands)
                                endif
                              endif
                              call xolox#session#save_qflist(a:commands)
                              call xolox#session#save_state(a:commands)
                              if is_all_tabs
                                call xolox#session#save_fullscreen(a:commands)
                                call add(a:commands, 'doautoall SessionLoadPost')
                              else
                                call add(a:commands, 'let s:winrestcmd = winrestcmd()')
                                call add(a:commands, 'windo doautocmd SessionLoadPost')
                                call s:jump_to_window(a:commands, tabpagenr(), winnr())
                                call add(a:commands, 'silent! execute s:winrestcmd')
                              endif
                              call add(a:commands, 'unlet SessionLoad')
                              call add(a:commands, '" vim: ft=vim ro nowrap smc=128')
                            endfunction
                            
    1              0.000002 function! xolox#session#save_globals(commands) " {{{2
                              " Serialize the values of the global variables configured by the user with
                              " the `g:session_persist_globals` option. The first argument is expected to
                              " be a list, it will be extended with the lines to be added to the session
                              " script.
                              for global in g:session_persist_globals
                                call add(a:commands, printf("let %s = %s", global, string(eval(global))))
                              endfor
                            endfunction
                            
    1              0.000002 function! xolox#session#save_features(commands) " {{{2
                              " Save the current state of the following Vim features:
                              "
                              " - Whether syntax highlighting is enabled (`:syntax on`)
                              " - Whether file type detection is enabled (`:filetype on`)
                              " - Whether file type plug-ins are enabled (`:filetype plugin on`)
                              " - Whether file type indent plug-ins are enabled (`:filetype indent on`)
                              "
                              " The first argument is expected to be a list, it will be extended with the
                              " lines to be added to the session script.
                              let template = "if exists('%s') != %i | %s %s | endif"
                              for [global, command] in [
                                      \ ['g:syntax_on', 'syntax'],
                                      \ ['g:did_load_filetypes', 'filetype'],
                                      \ ['g:did_load_ftplugin', 'filetype plugin'],
                                      \ ['g:did_indent_on', 'filetype indent']]
                                let active = exists(global)
                                let toggle = active ? 'on' : 'off'
                                call add(a:commands, printf(template, global, active, command, toggle))
                              endfor
                            endfunction
                            
    1              0.000002 function! xolox#session#save_colors(commands) " {{{2
                              " Save the current color scheme and background color. The first argument is
                              " expected to be a list, it will be extended with the lines to be added to
                              " the session script.
                              call add(a:commands, 'if &background != ' . string(&background))
                              call add(a:commands, "\tset background=" . &background)
                              call add(a:commands, 'endif')
                              if exists('g:colors_name') && type(g:colors_name) == type('') && g:colors_name != ''
                                let template = "if !exists('g:colors_name') || g:colors_name != %s | colorscheme %s | endif"
                                call add(a:commands, printf(template, string(g:colors_name), fnameescape(g:colors_name)))
                              endif
                            endfunction
                            
    1              0.000002 function! xolox#session#save_fullscreen(commands) " {{{2
                              " Save the full screen state of Vim. This function provides integration
                              " between my [vim-session] [] and [vim-shell] [] plug-ins. The first
                              " argument is expected to be a list, it will be extended with the lines to
                              " be added to the session script.
                              "
                              " [vim-session]: http://peterodding.com/code/vim/session
                              " [vim-shell]: http://peterodding.com/code/vim/shell
                              try
                                let commands = xolox#shell#persist_fullscreen()
                                if !empty(commands)
                                  call add(a:commands, "try")
                                  for line in commands
                                    call add(a:commands, "  " . line)
                                  endfor
                                  if has('gui_running') && (has('gui_gtk') || has('gui_gtk2') || has('gui_gnome'))
                                    " Without this hack GVim on GTK doesn't preserve the window size.
                                    call add(a:commands, "  call feedkeys(\":set lines=" . &lines . " columns=" . &columns . "\\<CR>\")")
                                  endif
                                  call add(a:commands, "catch " . '/^Vim\%((\a\+)\)\=:E117/')
                                  call add(a:commands, "  \" Ignore missing full-screen plug-in.")
                                  call add(a:commands, "endtry")
                                endif
                              catch /^Vim\%((\a\+)\)\=:E117/
                                " Ignore missing full-screen functionality.
                              endtry
                            endfunction
                            
    1              0.000002 function! xolox#session#save_qflist(commands) " {{{2
                              " Save the contents of the quick-fix list. The first argument is expected to
                              " be a list, it will be extended with the lines to be added to the session
                              " script.
                              if has('quickfix')
                                let qf_list = []
                                for qf_entry in getqflist()
                                  if has_key(qf_entry, 'bufnr')
                                    if !has_key(qf_entry, 'filename')
                                      let qf_entry.filename = bufname(qf_entry.bufnr)
                                    endif
                                    unlet qf_entry.bufnr
                                  endif
                                  call add(qf_list, qf_entry)
                                endfor
                                call add(a:commands, 'call setqflist(' . string(qf_list) . ')')
                              endif
                            endfunction
                            
    1              0.000002 function! xolox#session#save_state(commands) " {{{2
                              " Wrapper for the [:mksession] [] command that slightly massages the
                              " generated Vim script to get rid of some strange quirks in the way Vim
                              " generates sessions. Also implements support for buffers with content that
                              " was generated by other Vim plug-ins. The first argument is expected to
                              " be a list, it will be extended with the lines to be added to the session
                              " script.
                              let tempfile = tempname()
                              let ssop_save = &sessionoptions
                              try
                                " The default value of &sessionoptions includes "options" which causes
                                " :mksession to include all Vim options and mappings in generated session
                                " scripts. This can significantly increase the size of session scripts
                                " which makes them slower to generate and evaluate. It can also be a bit
                                " buggy, e.g. it breaks Ctrl-S when :runtime mswin.vim has been used. The
                                " value of &sessionoptions is changed temporarily to avoid these issues.
                                set ssop-=options
                                execute 'mksession' fnameescape(tempfile)
                                let lines = readfile(tempfile)
                                " Remove the mode line added by :mksession because we'll add our own in
                                " xolox#session#save_session().
                                call s:eat_trailing_line(lines, '" vim: set ft=vim :')
                                " Remove the "SessionLoadPost" event firing at the end of the :mksession
                                " output. We will fire the event ourselves when we're really done.
                                call s:eat_trailing_line(lines, 'unlet SessionLoad')
                                call s:eat_trailing_line(lines, 'doautoall SessionLoadPost')
                                call xolox#session#save_special_windows(lines)
                                if !xolox#session#include_tabs()
                                  " Customize the output of :mksession for tab scoped sessions.
                                  let buffers = tabpagebuflist()
                                  call map(lines, 's:tabpage_filter(buffers, v:val)')
                                endif
                                call extend(a:commands, map(lines, 's:state_filter(v:val)'))
                                " Re-implement Vim's special handling of the initial, empty buffer.
                                call add(a:commands, "if exists('s:wipebuf')")
                                call add(a:commands, "  if empty(bufname(s:wipebuf))")
                                call s:cleanup_after_plugin(a:commands, 's:wipebuf')
                                call add(a:commands, "  endif")
                                call add(a:commands, "endif")
                                return 1
                              finally
                                let &sessionoptions = ssop_save
                                call delete(tempfile)
                              endtry
                            endfunction
                            
    1              0.000004 function! s:eat_trailing_line(session, line) " {{{3
                              " Remove matching, trailing strings from a list of strings.
                              if a:session[-1] == a:line
                                call remove(a:session, -1)
                              endif
                            endfunction
                            
    1              0.000003 function! s:tabpage_filter(buffers, line) " {{{3
                              " Change output of :mksession if for single tab page.
                              if a:line =~ '^badd +\d\+ '
                                " The :mksession command adds all open buffers to a session even for tab
                                " scoped sessions. That makes sense, but we want only the buffers in the
                                " tab page to be included. That's why we filter out any references to the
                                " rest of the buffers from the script generated by :mksession.
                                let pathname = matchstr(a:line, '^badd +\d\+ \zs.*')
                                let bufnr = bufnr('^' . pathname . '$')
                                if index(a:buffers, bufnr) == -1
                                  return '" ' . a:line
                                endif
                              elseif a:line =~ '^let v:this_session\s*='
                                " The :mksession command unconditionally adds the global v:this_session
                                " variable definition to the session script, but we want a differently
                                " scoped variable for tab scoped sessions.
                                return substitute(a:line, 'v:this_session', 't:this_session', 'g')
                              endif
                              " Preserve all other lines.
                              return a:line
                            endfunction
                            
    1              0.000002 function! s:state_filter(line) " {{{3
                              " Various changes to the output of :mksession.
                              if a:line =~ '^normal!\? zo$'
                                " Silence "E490: No fold found" errors.
                                return 'silent! ' . a:line
                              elseif a:line =~ '^file .\{-}\<NERD_tree_\d\+$'
                                " Silence "E95: Buffer with this name already exists" when restoring
                                " mirrored NERDTree windows.
                                return '" ' . a:line
                              elseif a:line =~ '^file .\{-}\[BufExplorer\]$'
                                " Same trick (about the E95) for BufExplorer.
                                return '" ' . a:line
                              elseif a:line =~ '^file .\{-}__Tag_List__$'
                                " Same trick (about the E95) for TagList.
                                return '" ' . a:line
                              elseif a:line =~ "^\\s*silent exe 'bwipe ' \\. s:wipebuf$" || a:line =~ '^unlet! s:wipebuf$'
                                " Disable Vim's special handling of the initial, empty buffer because it
                                " breaks restoring of special windows with content generated by a Vim
                                " plug-in. The :mksession command doesn't have this problem because it
                                " simply doesn't support buffers with generated contents...
                                return '" ' . a:line
                              else
                                return a:line
                              endif
                            endfunction
                            
    1              0.000003 function! xolox#session#save_special_windows(session) " {{{2
                              " Implements support for buffers with content that was generated by other
                              " Vim plug-ins. The first argument is expected to be a list, it will be
                              " extended with the lines to be added to the session script.
                              let tabpage = tabpagenr()
                              let window = winnr()
                              let s:nerdtrees = {}
                              call add(a:session, '')
                              call add(a:session, '" Support for special windows like quick-fix and plug-in windows.')
                              call add(a:session, '" Everything down here is generated by vim-session (not supported')
                              call add(a:session, '" by :mksession out of the box).')
                              call add(a:session, '')
                              try
                                if xolox#session#include_tabs()
                                  tabdo call s:check_special_tabpage(a:session)
                                else
                                  call s:check_special_tabpage(a:session)
                                endif
                              finally
                                unlet s:nerdtrees
                                execute 'tabnext' tabpage
                                execute window . 'wincmd w'
                                call s:jump_to_window(a:session, tabpage, window)
                              endtry
                            endfunction
                            
    1              0.000002 function! s:check_special_tabpage(session)
                              let status = 0
                              let winrestcmd = winrestcmd()
                              let window = winnr()
                              windo let status += s:check_special_window(a:session)
                              execute window . 'wincmd w'
                              silent! execute winrestcmd
                              if status > 0 && winnr('$') > 1
                                call add(a:session, winrestcmd)
                              endif
                            endfunction
                            
    1              0.000003 function! s:check_special_window(session)
                              " If we detected a special window and the argument to the command is not a
                              " pathname, this variable should be set to false to disable normalization.
                              let do_normalize_path = 1
                              let bufname = expand('%:t')
                              if exists('b:NERDTreeRoot')
                                if !has_key(s:nerdtrees, bufnr('%'))
                                  let command = 'NERDTree'
                                  let argument = b:NERDTreeRoot.path.str()
                                  let s:nerdtrees[bufnr('%')] = 1
                                else
                                  let command = 'NERDTreeMirror'
                                  let argument = ''
                                endif
                              elseif bufname == '[BufExplorer]'
                                let command = 'BufExplorer'
                                let argument = ''
                              elseif bufname == '__Tag_List__'
                                let command = 'Tlist'
                                let argument = ''
                              elseif exists('g:proj_running') && g:proj_running == bufnr('%')
                                let command = 'Project'
                                let argument = expand('%:p')
                              elseif exists('b:ConqueTerm_Idx')
                                let command = 'ConqueTerm'
                                let argument = g:ConqueTerm_Terminals[b:ConqueTerm_Idx]['program_name']
                                let do_normalize_path = 0
                              elseif &filetype == 'netrw'
                                let command = 'edit'
                                let argument = bufname('%')
                              elseif &buftype == 'quickfix'
                                let command = 'cwindow'
                                let argument = ''
                              endif
                              if exists('command')
                                call s:jump_to_window(a:session, tabpagenr(), winnr())
                                call add(a:session, 'let s:bufnr_save = bufnr("%")')
                                call add(a:session, 'let s:cwd_save = getcwd()')
                                if argument == ''
                                  call add(a:session, command)
                                else
                                  if do_normalize_path
                                    let argument = fnamemodify(argument, ':~')
                                    if xolox#session#options_include('slash')
                                      let argument = substitute(argument, '\', '/', 'g')
                                    endif
                                  endif
                                  call add(a:session, command . ' ' . fnameescape(argument))
                                endif
                                call s:cleanup_after_plugin(a:session, 's:bufnr_save')
                                call add(a:session, 'execute "cd" fnameescape(s:cwd_save)')
                                return 1
                              endif
                            endfunction
                            
    1              0.000003 function! s:jump_to_window(session, tabpage, window)
                              call add(a:session, a:window . 'wincmd w')
                              if xolox#session#include_tabs()
                                call add(a:session, 'tabnext ' . a:tabpage)
                              endif
                            endfunction
                            
    1              0.000003 function! s:nerdtree_persist()
                              " Remember current working directory and whether NERDTree is loaded.
                              if exists('b:NERDTreeRoot')
                                return 'NERDTree ' . fnameescape(b:NERDTreeRoot.path.str()) . ' | only'
                              else
                                return 'cd ' . fnameescape(getcwd())
                              endif
                            endfunction
                            
    1              0.000003 function! s:cleanup_after_plugin(commands, bufnr_var)
                              call add(a:commands, "if !getbufvar(" . a:bufnr_var . ", '&modified')")
                              call add(a:commands, "  let s:wipebuflines = getbufline(" . a:bufnr_var . ", 1, '$')")
                              call add(a:commands, "  if len(s:wipebuflines) <= 1 && empty(get(s:wipebuflines, 0, ''))")
                              call add(a:commands, "    silent execute 'bwipeout' " . a:bufnr_var)
                              call add(a:commands, "  endif")
                              call add(a:commands, "endif")
                            endfunction
                            
                            " Automatic commands to manage the default session. {{{1
                            
    1              0.000003 function! xolox#session#auto_load() " {{{2
                              " Automatically load the default or last used session when Vim starts.
                              " Normally called by the [VimEnter] [] automatic command event.
                              "
                              " [VimEnter]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimEnter
                              if g:session_autoload == 'no'
                                return
                              endif
                              " Check that the user has started Vim without editing any files.
                              if xolox#session#is_empty()
                                " Check whether a session matching the user-specified server name exists.
                                if v:servername !~ '^\cgvim\d*$'
                                  for session in xolox#session#get_names(0)
                                    if v:servername ==? session
                                      call xolox#session#open_cmd(session, '', 'OpenSession')
                                      return
                                    endif
                                  endfor
                                endif
                                " Default to the last used session or the default session?
                                let [has_last_session, session] = s:get_last_or_default_session()
                                let path = xolox#session#name_to_path(session)
                                if (g:session_default_to_last == 0 || has_last_session) && filereadable(path) && !s:session_is_locked(session, 'OpenSession')
                                  " Compose the message for the prompt.
                                  let is_default_session = (session == g:session_default_name)
                                  let msg = printf("Do you want to restore your %s editing session%s?",
                                        \ is_default_session ? 'default' : 'last used',
                                        \ is_default_session ? '' : printf(' (%s)', session))
                                  " Prepare the list of choices.
                                  let choices = ["&Restore", "&Don't Restore"]
                                  if g:session_default_to_last && has_last_session
                                    call add(choices, "&Forget")
                                  endif
                                  " Prompt the user (if not configured otherwise).
                                  let choice = s:prompt(msg, choices, 'g:session_autoload')
                                  if choice == 1
                                    call xolox#session#open_cmd(session, '', 'OpenSession')
                                  elseif choice == 3
                                    call s:last_session_forget()
                                  endif
                                endif
                              endif
                            endfunction
                            
    1              0.000003 function! xolox#session#is_empty() " {{{2
                              " Check that the user has started Vim without editing any files. Used by
                              " `xolox#session#auto_load()` to determine whether automatic session loading
                              " should be performed. Currently checks the following conditions:
                              "
                              " 1. That the current buffer is either empty (contains no lines and is not
                              "    modified) or showing [vim-startify] [].
                              " 2. That the buffer list either empty or persistent.
                              "
                              " [vim-startify]: https://github.com/mhinz/vim-startify/
                              let current_buffer_is_empty = (&modified == 0 && getline(1, '$') == [''])
                              let current_buffer_is_startify = (&filetype == 'startify')
                              let buffer_list_is_empty = (bufname('%') == '' && empty(filter(range(1, bufnr('$')), 'buflisted(v:val) && v:val != ' . bufnr(''))))
                              let buffer_list_is_persistent = (index(xolox#misc#option#split(&viminfo), '%') >= 0)
                              return (current_buffer_is_empty || current_buffer_is_startify) && (buffer_list_is_empty || buffer_list_is_persistent)
                            endfunction
                            
    1              0.000002 function! xolox#session#auto_save() " {{{2
                              " Automatically save the current editing session when Vim is closed.
                              " Normally called by the [VimLeavePre] [] automatic command event.
                              "
                              " [VimLeavePre]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimLeavePre
                              if v:dying
                                " We won't save the session if Vim is not terminating normally.
                                return
                              endif
                              if g:session_autosave == 'no'
                                " We won't save the session if auto-save is explicitly disabled.
                                return
                              endif
                              " Get the name of the session for automatic saving.
                              let name = xolox#misc#option#get('session_autosave_to')
                              if empty(name)
                                " Get the name of the active session (if any).
                                let name = xolox#session#find_current_session()
                                " If no session is active and the user doesn't have any sessions yet,
                                " help them get started by suggesting to create the default session.
                                if empty(name) && (empty(xolox#session#get_names(0)) || g:session_default_overwrite)
                                  let name = g:session_default_name
                                endif
                              endif
                              " Prompt the user to save the active/first/default session?
                              if !empty(name)
                                let is_tab_scoped = xolox#session#is_tab_scoped()
                                let msg = "Do you want to save your %s before quitting Vim?"
                                if s:prompt(printf(msg, xolox#session#get_label(name, is_tab_scoped)), ["&Save", "&Don't Save"], 'g:session_autosave') == 1
                                  if g:session_default_overwrite && (name == g:session_default_name)
                                    let bang = '!'
                                  else
                                    let bang = ''
                                  endif
                                  if is_tab_scoped
                                    call xolox#session#save_tab_cmd(name, bang, 'SaveTabSession')
                                  else
                                    call xolox#session#save_cmd(name, bang, 'SaveSession')
                                  endif
                                endif
                              endif
                            endfunction
                            
    1              0.000003 function! xolox#session#auto_save_periodic() " {{{2
                              " Automatically saves the current editing session every few minutes.
                              " Normally called by the [CursorHold] [] and [CursorHoldI] [] automatic
                              " command events.
                              "
                              " [CursorHold]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHold
                              " [CursorHoldI]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHoldI
                              if g:session_autosave_periodic > 0
                                let interval = g:session_autosave_periodic * 60
                                let next_save = s:session_last_flushed + interval
                                if localtime() > next_save
                                  let name = xolox#session#find_current_session()
                                  if !empty(name)
                                    if xolox#session#is_tab_scoped()
                                      let function = 'xolox#session#save_tab_cmd'
                                      let arguments = [name, '', 'SaveTabSession']
                                    else
                                      let function = 'xolox#session#save_cmd'
                                      let arguments = [name, '', 'SaveSession']
                                    endif
                                    if xolox#misc#option#get('session_autosave_silent', 0)
                                      " Silence informational messages perceived as noisy.
                                      " https://github.com/xolox/vim-session/issues/120
                                      silent call call(function, arguments)
                                    else
                                      call call(function, arguments)
                                    endif
                                  endif
                                endif
                              endif
                            endfunction
                            
    1              0.000004 function! s:flush_session()
                              let s:session_last_flushed = localtime()
                            endfunction
                            
    1              0.000006 if !exists('s:session_last_flushed')
    1   0.000020   0.000012   call s:flush_session()
    1              0.000002 endif
                            
    1              0.000003 function! xolox#session#auto_unlock() " {{{2
                              " Automatically unlock all sessions when Vim quits. Normally called by the
                              " [VimLeavePre] [] automatic command event.
                              "
                              " [VimLeavePre]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimLeavePre
                              if xolox#session#locking_enabled()
                                let i = 0
                                while i < len(s:lock_files)
                                  let lock_file = s:lock_files[i]
                                  if delete(lock_file) == 0
                                    call remove(s:lock_files, i)
                                  else
                                    let i += 1
                                  endif
                                endwhile
                              endif
                            endfunction
                            
                            " Commands that enable users to manage multiple sessions. {{{1
                            
    1              0.000004 function! s:prompt(msg, choices, option_name)
                              let option_value = eval(a:option_name)
                              if option_value == 'yes'
                                return 1
                              elseif option_value == 'no'
                                return 0
                              else
                                if g:session_verbose_messages
                                  let format = "%s\n\nNote that you can permanently disable this dialog by adding the following line to your %s script:\n\n\t:let %s = 'no'"
                                  let prompt = printf(format, a:msg, xolox#misc#os#is_win() ? '~\_vimrc' : '~/.vimrc', a:option_name)
                                else
                                  let prompt = a:msg
                                endif
                                return confirm(prompt, join(a:choices, "\n"), 1, 'Question')
                              endif
                            endfunction
                            
    1              0.000004 function! xolox#session#open_cmd(name, bang, command) abort " {{{2
                              let name = s:unescape(a:name)
                              if empty(name)
                                let name = xolox#session#prompt_for_name('restore')
                              endif
                              if name == ''
                                return -1
                              else
                                let starttime = xolox#misc#timer#start()
                                let path = xolox#session#name_to_path(name)
                                if !filereadable(path)
                                  let msg = "session.vim %s: The %s session at %s doesn't exist!"
                                  call xolox#misc#msg#warn(msg, g:xolox#session#version, string(name), fnamemodify(path, ':~'))
                                  return 0
                                elseif a:bang == '!' || !s:session_is_locked(name, a:command)
                                  let oldcwd = s:nerdtree_persist()
                                  call xolox#session#close_cmd(a:bang, 1, name != xolox#session#find_current_session(), a:command)
                                  call s:lock_session(path)
                                  execute 'source' fnameescape(path)
                                  if xolox#session#is_tab_scoped()
                                    call s:lock_session(path) " Retroactively (this is only known after the session has been loaded) add the tabpage to the lock.
                                    let t:session_old_cwd = oldcwd
                                    let session_type = 'tab scoped'
                                  else
                                    let g:session_old_cwd = oldcwd
                                    let session_type = 'global'
                                  endif
                                  call s:last_session_persist(name)
                                  call s:flush_session()
                                  call xolox#misc#timer#stop("session.vim %s: Opened %s %s session in %s.", g:xolox#session#version, session_type, string(name), starttime)
                                  call xolox#misc#msg#info("session.vim %s: Opened %s %s session from %s.", g:xolox#session#version, session_type, string(name), fnamemodify(path, ':~'))
                                endif
                              endif
                              return 1
                            endfunction
                            
    1              0.000003 function! xolox#session#view_cmd(name) abort " {{{2
                              let name = s:unescape(a:name)
                              " Default to the current session?
                              if empty(name)
                                let name = xolox#session#find_current_session()
                              endif
                              " Prompt the user to select a session.
                              if empty(name)
                                let name = xolox#session#prompt_for_name('view')
                              endif
                              if name != ''
                                let path = xolox#session#name_to_path(name)
                                if !filereadable(path)
                                  let msg = "session.vim %s: The %s session at %s doesn't exist!"
                                  call xolox#misc#msg#warn(msg, g:xolox#session#version, string(name), fnamemodify(path, ':~'))
                                else
                                  if has('gui_running')
                                    execute 'tab drop' fnameescape(path)
                                  else
                                    execute 'tabedit' fnameescape(path)
                                  endif
                                  call xolox#misc#msg#info("session.vim %s: Viewing session script %s.", g:xolox#session#version, fnamemodify(path, ':~'))
                                endif
                              endif
                            endfunction
                            
    1              0.000003 function! xolox#session#save_cmd(name, bang, command) abort " {{{2
                              let starttime = xolox#misc#timer#start()
                              let name = s:unescape(a:name)
                              if empty(name)
                                let name = xolox#session#find_current_session()
                              endif
                              if empty(name)
                                let name = g:session_default_name
                              endif
                              let path = xolox#session#name_to_path(name)
                              let friendly_path = fnamemodify(path, ':~')
                              if a:bang == '!' || !s:session_is_locked(name, a:command)
                                let lines = []
                                call xolox#session#save_session(lines, friendly_path)
                                if xolox#misc#os#is_win() && !xolox#session#options_include('unix')
                                  call map(lines, 'v:val . "\r"')
                                endif
                                if writefile(lines, path) != 0
                                  let msg = "session.vim %s: Failed to save %s session to %s!"
                                  call xolox#misc#msg#warn(msg, g:xolox#session#version, string(name), friendly_path)
                                else
                                  call s:last_session_persist(name)
                                  call s:flush_session()
                                  let label = xolox#session#get_label(name, !xolox#session#include_tabs())
                                  call xolox#misc#timer#stop("session.vim %s: Saved %s in %s.", g:xolox#session#version, label, starttime)
                                  call xolox#misc#msg#info("session.vim %s: Saved %s to %s.", g:xolox#session#version, label, friendly_path)
                                  if xolox#session#include_tabs()
                                    let v:this_session = path
                                  else
                                    let t:this_session = path
                                  endif
                                  call s:lock_session(path)
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! xolox#session#delete_cmd(name, bang) " {{{2
                              let name = s:unescape(a:name)
                              if empty(name)
                                let name = xolox#session#prompt_for_name('delete')
                              endif
                              if name != ''
                                let path = xolox#session#name_to_path(name)
                                if !filereadable(path)
                                  let msg = "session.vim %s: The %s session at %s doesn't exist!"
                                  call xolox#misc#msg#warn(msg, g:xolox#session#version, string(name), fnamemodify(path, ':~'))
                                elseif a:bang == '!' || !s:session_is_locked(name, 'DeleteSession')
                                  if delete(path) != 0
                                    let msg = "session.vim %s: Failed to delete %s session at %s!"
                                    call xolox#misc#msg#warn(msg, g:xolox#session#version, string(name), fnamemodify(path, ':~'))
                                  else
                                    call s:unlock_session(path)
                                    let msg = "session.vim %s: Deleted %s session at %s."
                                    call xolox#misc#msg#info(msg, g:xolox#session#version, string(name), fnamemodify(path, ':~'))
                                  endif
                                endif
                              endif
                            endfunction
                            
    1              0.000004 function! xolox#session#close_cmd(bang, silent, save_allowed, command) abort " {{{2
                              let is_all_tabs = xolox#session#include_tabs()
                              let name = xolox#session#find_current_session()
                              if name != ''
                                if a:save_allowed
                                  let msg = "Do you want to save your %s before closing it?"
                                  let label = xolox#session#get_label(name, !is_all_tabs)
                                  if s:prompt(printf(msg, label), ["&Save", "&Don't Save"], 'g:session_autosave') == 1
                                    call xolox#session#save_cmd(name, a:bang, a:command)
                                  endif
                                else
                                  call xolox#misc#msg#debug("session.vim %s: Session reset requested, not saving changes to session ..", g:xolox#session#version)
                                endif
                                call s:unlock_session(xolox#session#name_to_path(name))
                              endif
                              " Close al but the current tab page?
                              if is_all_tabs && tabpagenr('$') > 1
                                execute 'tabonly' . a:bang
                              endif
                              " Close all but the current window.
                              if winnr('$') > 1
                                execute 'only' . a:bang
                              endif
                              " Start editing a new, empty buffer.
                              execute 'enew' . a:bang
                              " Close all but the current buffer.
                              let bufnr_save = bufnr('%')
                              let all_buffers = is_all_tabs ? range(1, bufnr('$')) : tabpagebuflist()
                              for bufnr in all_buffers
                                if buflisted(bufnr) && bufnr != bufnr_save
                                  execute 'silent bdelete' bufnr
                                endif
                              endfor
                              " Restore working directory (and NERDTree?) from before :OpenSession.
                              if is_all_tabs && exists('g:session_old_cwd')
                                execute g:session_old_cwd
                                unlet g:session_old_cwd
                              elseif !is_all_tabs && exists('t:session_old_cwd')
                                execute t:session_old_cwd
                                unlet t:session_old_cwd
                              endif
                              call s:flush_session()
                              if !a:silent
                                let msg = "session.vim %s: Closed %s."
                                let label = xolox#session#get_label(xolox#session#find_current_session(), !is_all_tabs)
                                call xolox#misc#msg#info(msg, g:xolox#session#version, label)
                              endif
                              if xolox#session#is_tab_scoped()
                                let t:this_session = ''
                              else
                                let v:this_session = ''
                              endif
                              return 1
                            endfunction
                            
    1              0.000003 function! xolox#session#open_tab_cmd(name, bang, command) abort " {{{2
                              try
                                call xolox#session#change_tab_options()
                                call xolox#session#open_cmd(a:name, a:bang, a:command)
                              finally
                                call xolox#session#restore_tab_options()
                              endtry
                            endfunction
                            
    1              0.000002 function! xolox#session#save_tab_cmd(name, bang, command) abort " {{{2
                              try
                                call xolox#session#change_tab_options()
                                call xolox#session#save_cmd(a:name, a:bang, a:command)
                              finally
                                call xolox#session#restore_tab_options()
                              endtry
                            endfunction
                            
    1              0.000002 function! xolox#session#append_tab_cmd(name, bang, count, command) abort " {{{2
                              try
                                call xolox#session#change_tab_options()
                                let original_tabpage = tabpagenr()
                                execute printf('%stabnew', a:count == -1 ? '' : a:count)
                                let status = xolox#session#open_cmd(a:name, a:bang, a:command)
                                if status <= 0 && empty(bufname(''))
                                  tabclose
                                  if tabpagenr() != original_tabpage
                                    execute original_tabpage . 'tabnext'
                                  endif
                                  if status == 0
                                    " Switching tab pages cleared the warning message. Repeat it now.
                                    call xolox#misc#msg#warn(get(g:xolox_messages, -1, ''))
                                  endif
                                endif
                              finally
                                call xolox#session#restore_tab_options()
                              endtry
                            endfunction
                            
    1              0.000002 function! xolox#session#close_tab_cmd(bang, command) abort " {{{2
                              let save_allowed = xolox#session#is_tab_scoped()
                              try
                                call xolox#session#change_tab_options()
                                call xolox#session#close_cmd(a:bang, 0, save_allowed, a:command)
                              finally
                                call xolox#session#restore_tab_options()
                              endtry
                            endfunction
                            
    1              0.000002 function! xolox#session#restart_cmd(bang, args) abort " {{{2
                              if !has('gui_running')
                                " In console Vim we can't start a new Vim and kill the old one...
                                let msg = "session.vim %s: The :RestartVim command only works in graphical Vim!"
                                call xolox#misc#msg#warn(msg, g:xolox#session#version)
                              else
                                " Save the current session (if there is no active
                                " session we will create a session called "restart").
                                let name = xolox#session#find_current_session()
                                if empty(name)
                                  let name = 'restart'
                                endif
                                call xolox#session#save_cmd(name, a:bang, 'RestartVim')
                                " Generate the Vim command line.
                                let progname = xolox#misc#escape#shell(xolox#misc#os#find_vim())
                                let command = progname . ' -g -c ' . xolox#misc#escape#shell('OpenSession\! ' . fnameescape(name))
                                let args = matchstr(a:args, '^\s*|\s*\zs.\+$')
                                if !empty(args)
                                  let command .= ' -c ' . xolox#misc#escape#shell(args)
                                endif
                                if !empty(v:servername)
                                  let command .= ' --servername ' . xolox#misc#escape#shell(v:servername)
                                endif
                                " Close the session, releasing the session lock.
                                call xolox#session#close_cmd(a:bang, 0, 1, 'RestartVim')
                                " Start the new Vim instance.
                                if xolox#misc#os#is_win()
                                  " On Microsoft Windows.
                                  execute '!start' command
                                else
                                  " On anything other than Windows (UNIX like).
                                  let cmdline = []
                                  for variable in g:session_restart_environment
                                    call add(cmdline, variable . '=' . xolox#misc#escape#shell(fnameescape(eval('$' . variable))))
                                  endfor
                                  call add(cmdline, command)
                                  call add(cmdline, printf("--cmd ':set enc=%s'", escape(&enc, '\ ')))
                                  silent execute '!' join(cmdline, ' ') '&'
                                endif
                                " Close Vim.
                                silent quitall
                              endif
                            endfunction
                            
                            " Miscellaneous functions. {{{1
                            
    1              0.000003 function! s:unescape(s) " {{{2
                              " Undo escaping of special characters (preceded by a backslash).
                              let s = substitute(a:s, '\\\(.\)', '\1', 'g')
                              " Expand any environment variables in the user input.
                              let s = substitute(s, '\(\$[A-Za-z0-9_]\+\)', '\=expand(submatch(1))', 'g')
                              return s
                            endfunction
                            
    1              0.000002 function! xolox#session#prompt_for_name(action) " {{{2
                              " Prompt the user to select one of the existing sessions. The first argument
                              " is expected to be a string describing what will be done to the session
                              " once it's been selected. Returns the name of the selected session as a
                              " string. If no session is selected an empty string is returned. Here's
                              " an example of what the prompt looks like:
                              "
                              "     :call xolox#session#prompt_for_name('trash')
                              "
                              "     Please select the session to trash:
                              "
                              "      1. first-session
                              "      2. second-session
                              "      3. third-session
                              "
                              "     Type number and <Enter> or click with mouse (empty cancels):
                              "
                              " If only a single session exists there's nothing to choose from so the name
                              " of that session will be returned directly, without prompting the user.
                              let sessions = sort(xolox#session#get_names(0), 1)
                              if len(sessions) == 1
                                return sessions[0]
                              elseif !empty(sessions)
                                let lines = copy(sessions)
                                for i in range(len(sessions))
                                  let lines[i] = ' ' . (i + 1) . '. ' . lines[i]
                                endfor
                                redraw
                                sleep 100 m
                                echo "\nPlease select the session to " . a:action . ":"
                                sleep 100 m
                                let i = inputlist([''] + lines + [''])
                                if i >= 1 && i <= len(sessions)
                                  return sessions[i - 1]
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 function! xolox#session#name_to_path(name) " {{{2
                              " Convert the name of a session (the first argument, expected to be a
                              " string) to an absolute pathname. Any special characters in the session
                              " name will be encoded using URL encoding. This means you're free to use
                              " whatever naming conventions you like (regardless of special characters
                              " like slashes). Returns a string.
                              let directory = xolox#misc#path#absolute(g:session_directory)
                              let filename = xolox#misc#path#encode(a:name) . g:session_extension
                              return xolox#misc#path#merge(directory, filename)
                            endfunction
                            
    1              0.000002 function! xolox#session#path_to_name(path) " {{{2
                              " Convert the absolute pathname of a session script (the first argument,
                              " expected to be a string) to a session name. This function assumes the
                              " absolute pathname refers to the configured session directory, but it does
                              " not check for it nor does it require it (it simple takes the base name
                              " of the absolute pathname of the session script and decodes it). Returns a
                              " string.
                              return xolox#misc#path#decode(fnamemodify(a:path, ':t:r'))
                            endfunction
                            
    1              0.000002 function! xolox#session#get_names(include_suggestions) " {{{2
                              " Get the names of all available sessions. This scans the directory
                              " configured with `g:session_directory` for files that end with the suffix
                              " configured with `g:session_extension`, takes the base name of each file
                              " and decodes any URL encoded characters. Returns a list of strings.
                              "
                              " If the first argument is true (1) then the user defined function
                              " configured with `g:session_name_suggestion_function` is called to find
                              " suggested session names, which are prefixed to the list of available
                              " sessions, otherwise the argument should be false (0).
                              let directory = xolox#misc#path#absolute(g:session_directory)
                              let filenames = split(glob(xolox#misc#path#merge(directory, '*' . g:session_extension)), "\n")
                              call map(filenames, 'xolox#session#path_to_name(v:val)')
                              if a:include_suggestions && !empty(g:session_name_suggestion_function)
                                let suggested_names = call(g:session_name_suggestion_function, [])
                                let filenames = suggested_names + filenames
                              endif
                              return filenames
                            endfunction
                            
    1              0.000003 function! xolox#session#complete_names(arg, line, pos) " {{{2
                              " Completion function for user defined Vim commands. Used by commands like
                              " `:OpenSession` and `:DeleteSession`  (but not `:SaveSession`) to support
                              " user friendly completion.
                              let names = filter(xolox#session#get_names(0), 'v:val =~ a:arg')
                              return map(names, 'fnameescape(v:val)')
                            endfunction
                            
    1              0.000002 function! xolox#session#complete_names_with_suggestions(arg, line, pos) " {{{2
                              " Completion function for the Vim command `:SaveSession`.
                              let names = filter(xolox#session#get_names(1), 'v:val =~ a:arg')
                              return map(names, 'fnameescape(v:val)')
                            endfunction
                            
    1              0.000002 function! xolox#session#is_tab_scoped() " {{{2
                              " Determine whether the current session is tab scoped or global. Returns 1
                              " (true) when the session is tab scoped, 0 (false) otherwise.
                              return exists('t:this_session')
                            endfunction
                            
    1              0.000002 function! xolox#session#find_current_session() " {{{2
                              " Find the name of the current tab scoped or global session. Returns a
                              " string. If no session is active an empty string is returned.
                              for variable in ['t:this_session', 'v:this_session']
                                if exists(variable)
                                  let filename = eval(variable)
                                  if !empty(filename)
                                    let directory = fnamemodify(filename, ':p:h')
                                    if xolox#misc#path#equals(directory, g:session_directory)
                                      return xolox#session#path_to_name(filename)
                                    endif
                                  endif
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000002 function! xolox#session#get_label(name, is_tab_scoped) " {{{2
                              " Get a human readable label based on the scope (tab scoped or global) and
                              " name of a session. The first argument is the name (a string) and the
                              " second argument is a boolean indicating the scope of the session; 1 (true)
                              " means tab scoped and 0 (false) means global scope. Returns a string.
                              if a:name == g:session_default_name
                                let description = 'default editing session'
                              else
                                let description = printf('editing session %s', string(a:name))
                              endif
                              if a:is_tab_scoped
                                let description = printf('tab scoped %s', description)
                              endif
                              return description
                            endfunction
                            
    1              0.000002 function! xolox#session#options_include(value) " {{{2
                              " Check whether Vim's [sessionoptions] [] option includes the keyword given
                              " as the first argument (expected to be a string). Returns 1 (true) when it
                              " does, 0 (false) otherwise.
                              "
                              " [sessionoptions]: http://vimdoc.sourceforge.net/htmldoc/options.html#'sessionoptions'
                              return index(xolox#misc#option#split(&sessionoptions), a:value) >= 0
                            endfunction
                            
                            " Tab scoped sessions: {{{2
                            
    1              0.000002 function! xolox#session#include_tabs() " {{{3
                              " Check whether Vim's [sessionoptions] [] option includes the `tabpages`
                              " keyword. Returns 1 (true) when it does, 0 (false) otherwise.
                              return xolox#session#options_include('tabpages')
                            endfunction
                            
    1              0.000002 function! xolox#session#change_tab_options() " {{{3
                              " Temporarily change Vim's [sessionoptions] [] option so we can save a tab
                              " scoped session. Saves a copy of the original value to be restored later.
                              let s:ssop_save = &sessionoptions
                              " Only persist the current tab page.
                              set sessionoptions-=tabpages
                              " Don't persist the size and position of the Vim window.
                              set ssop-=winpos ssop-=resize
                            endfunction
                            
    1              0.000002 function! xolox#session#restore_tab_options() " {{{3
                              " Restore the original value of Vim's [sessionoptions] [] option.
                              if exists('s:ssop_save')
                                let &ssop = s:ssop_save
                                unlet s:ssop_save
                              endif
                            endfunction
                            
                            " Default to last used session: {{{2
                            
    1              0.000003 function! s:last_session_file()
                              let directory = xolox#misc#path#absolute(g:session_directory)
                              return xolox#misc#path#merge(directory, 'last-session.txt')
                            endfunction
                            
    1              0.000002 function! s:last_session_persist(name)
                              if g:session_default_to_last
                                if writefile([a:name], s:last_session_file()) != 0
                                  call xolox#misc#msg#warn("session.vim %s: Failed to persist name of last used session!", g:xolox#session#version)
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! s:last_session_forget()
                              let last_session_file = s:last_session_file()
                              if filereadable(last_session_file) && delete(last_session_file) != 0
                                call xolox#misc#msg#warn("session.vim %s: Failed to delete name of last used session!", g:xolox#session#version)
                              endif
                            endfunction
                            
    1              0.000003 function! s:get_last_or_default_session()
                              let last_session_file = s:last_session_file()
                              let has_last_session = filereadable(last_session_file)
                              if g:session_default_to_last && has_last_session
                                let lines = readfile(last_session_file)
                                return [has_last_session, lines[0]]
                              else
                                return [has_last_session, g:session_default_name]
                              endif
                            endfunction
                            
                            " Lock file management: {{{2
                            
    1              0.000004 if !exists('s:lock_files')
    1              0.000003   let s:lock_files = []
    1              0.000001 endif
                            
    1              0.000001 function! xolox#session#locking_enabled()
                              " Check whether session locking is enabled. Returns true (1) when locking is
                              " enabled, false (0) otherwise.
                              "
                              " By default session locking is enabled but users can opt-out by setting
                              " `g:session_lock_enabled` to false (0).
                              return xolox#misc#option#get('session_lock_enabled', 1)
                            endfunction
                            
    1              0.000002 function! s:vim_instance_id()
                              let id = {'pid': getpid()}
                              if !empty(v:servername)
                                let id['servername'] = v:servername
                              endif
                              if !xolox#session#include_tabs() || xolox#session#is_tab_scoped()
                                let id['tabpage'] = tabpagenr()
                              endif
                              return id
                            endfunction
                            
    1              0.000002 function! s:lock_file_path(session_path)
                              let directory = xolox#misc#option#get('session_lock_directory', '')
                              if empty(directory)
                                " Stale lock files can be really annoying, especially after a reboot
                                " because that just shouldn't happen - it's always a bug. References:
                                "  - https://github.com/xolox/vim-session/issues/97
                                "  - https://github.com/xolox/vim-session/issues/110
                                " One simple way to give a large group of users what they want is to use a
                                " volatile directory that is specifically meant for storing lock files.
                                " I've decided to make this the default when possible. The best reference
                                " I've been able to find on the proper system wide location for lock files
                                " is the following (yes, I know, it's Linux specific, so sue me):
                                " http://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/var.html
                                let global_lock_directory = '/var/lock'
                                if filewritable(global_lock_directory) == 2
                                  let directory = global_lock_directory
                                endif
                              endif
                              if !empty(directory)
                                let pathname = xolox#misc#path#merge(directory, xolox#misc#path#encode(a:session_path))
                              else
                                let pathname = a:session_path
                              endif
                              return pathname . '.lock'
                            endfunction
                            
    1              0.000002 function! s:lock_session(session_path)
                              if !xolox#session#locking_enabled()
                                return 1
                              endif
                              let lock_file = s:lock_file_path(a:session_path)
                              if xolox#misc#persist#save(lock_file, s:vim_instance_id())
                                if index(s:lock_files, lock_file) == -1
                                  call add(s:lock_files, lock_file)
                                endif
                                return 1
                              endif
                            endfunction
                            
    1              0.000002 function! s:unlock_session(session_path)
                              if !xolox#session#locking_enabled()
                                return 1
                              endif
                              let lock_file = s:lock_file_path(a:session_path)
                              if delete(lock_file) == 0
                                let idx = index(s:lock_files, lock_file)
                                if idx >= 0
                                  call remove(s:lock_files, idx)
                                endif
                                return 1
                              endif
                            endfunction
                            
    1              0.000002 function! s:session_is_locked(session_name, command)
                              if !xolox#session#locking_enabled()
                                return 0
                              endif
                              let session_path = xolox#session#name_to_path(a:session_name)
                              let lock_file = s:lock_file_path(session_path)
                              if filereadable(lock_file)
                                let this_instance = s:vim_instance_id()
                                let other_instance = xolox#misc#persist#load(lock_file)
                                let arguments = [g:xolox#session#version, string(a:session_name)]
                                if this_instance == other_instance
                                  " Session belongs to current Vim instance and tab page.
                                  return 0
                                elseif this_instance['pid'] == other_instance['pid']
                                  if has_key(other_instance, 'tabpage')
                                    let msg = "session.vim %s: The %s session is already loaded in tab page %s."
                                    call add(arguments, other_instance['tabpage'])
                                  else
                                    let msg = "session.vim %s: The %s session is already loaded in this Vim."
                                  endif
                                else
                                  let msg = "session.vim %s: The %s session is locked by another Vim instance %s."
                                  if has_key(other_instance, 'servername')
                                    call add(arguments, 'named ' . other_instance['servername'])
                                  else
                                    call add(arguments, 'with PID ' . other_instance['pid'])
                                  endif
                                  let msg .= " If that doesn't seem right maybe you forcefully closed Vim or it crashed?"
                                endif
                                let msg .= " Use the command ':%s! %s' to override."
                                call extend(arguments, [a:command, a:session_name])
                                call call('xolox#misc#msg#warn', [msg] + arguments)
                                return 1
                              endif
                            endfunction
                            
                            " vim: ts=2 sw=2 et

SCRIPT  /home/carlos/.vim/plugged/vim-misc/autoload/xolox/misc/option.vim
Sourced 1 time
Total time:   0.000297
 Self time:   0.000297

count  total (s)   self (s)
                            " Vim and plug-in option handling.
                            "
                            " Author: Peter Odding <peter@peterodding.com>
                            " Last Change: April 1, 2015
                            " URL: http://peterodding.com/code/vim/misc/
                            
    1              0.000003 function! xolox#misc#option#get(name, ...) " {{{1
                              " Expects one or two arguments: 1. The name of a variable and 2. the default
                              " value if the variable does not exist.
                              "
                              " Returns the value of the variable from a buffer local variable, global
                              " variable or the default value, depending on which is defined.
                              "
                              " This is used by some of my Vim plug-ins for option handling, so that users
                              " can customize options for specific buffers.
                              if exists('b:' . a:name)
                                " Buffer local variable.
                                return eval('b:' . a:name)
                              elseif exists('g:' . a:name)
                                " Global variable.
                                return eval('g:' . a:name)
                              elseif exists('a:1')
                                " Default value.
                                return a:1
                              endif
                            endfunction
                            
    1              0.000002 function! xolox#misc#option#split(value) " {{{1
                              " Given a multi-value Vim option like ['runtimepath'] [rtp] this returns a
                              " list of strings. For example:
                              "
                              "     :echo xolox#misc#option#split(&runtimepath)
                              "     ['/home/peter/Projects/Vim/misc',
                              "      '/home/peter/Projects/Vim/colorscheme-switcher',
                              "      '/home/peter/Projects/Vim/easytags',
                              "      ...]
                              "
                              " [rtp]: http://vimdoc.sourceforge.net/htmldoc/options.html#'runtimepath'
                              let values = split(a:value, '[^\\]\zs,')
                              return map(values, 's:unescape(v:val)')
                            endfunction
                            
    1              0.000002 function! s:unescape(s)
                              return substitute(a:s, '\\\([\\,]\)', '\1', 'g')
                            endfunction
                            
    1              0.000002 function! xolox#misc#option#join(values) " {{{1
                              " Given a list of strings like the ones returned by
                              " `xolox#misc#option#split()`, this joins the strings together into a
                              " single value that can be used to set a Vim option.
                              let values = copy(a:values)
                              call map(values, 's:escape(v:val)')
                              return join(values, ',')
                            endfunction
                            
    1              0.000001 function! s:escape(s)
                              return escape(a:s, ',\')
                            endfunction
                            
    1              0.000002 function! xolox#misc#option#split_tags(value) " {{{1
                              " Customized version of `xolox#misc#option#split()` with specialized
                              " handling for Vim's ['tags' option] [tags].
                              "
                              " [tags]: http://vimdoc.sourceforge.net/htmldoc/options.html#'tags'
                              let values = split(a:value, '[^\\]\zs,')
                              return map(values, 's:unescape_tags(v:val)')
                            endfunction
                            
    1              0.000001 function! s:unescape_tags(s)
                              return substitute(a:s, '\\\([\\, ]\)', '\1', 'g')
                            endfunction
                            
    1              0.000002 function! xolox#misc#option#join_tags(values) " {{{1
                              " Customized version of `xolox#misc#option#join()` with specialized
                              " handling for Vim's ['tags' option] [tags].
                              let values = copy(a:values)
                              call map(values, 's:escape_tags(v:val)')
                              return join(values, ',')
                            endfunction
                            
    1              0.000002 function! s:escape_tags(s)
                              return escape(a:s, ', ')
                            endfunction
                            
    1              0.000001 function! xolox#misc#option#eval_tags(value, ...) " {{{1
                              " Evaluate Vim's ['tags' option] [tags] without looking at the file
                              " system, i.e. this will report tags files that don't exist yet. Expects
                              " the value of the ['tags' option] [tags] as the first argument. If the
                              " optional second argument is 1 (true) only the first match is returned,
                              " otherwise (so by default) a list with all matches is returned.
                              let pathnames = []
                              let first_only = exists('a:1') ? a:1 : 0
                              for pattern in xolox#misc#option#split_tags(a:value)
                                " Make buffer relative pathnames absolute.
                                if pattern =~ '^\./'
                                  let suffix = matchstr(pattern, '^./\zs.*$')
                                  let directory = (&cpoptions =~# 'd') ? getcwd() : expand('%:p:h')
                                  let pattern = xolox#misc#path#merge(directory, suffix)
                                endif
                                " Make working directory relative pathnames absolute.
                                if xolox#misc#path#is_relative(pattern)
                                  let pattern = xolox#misc#path#merge(getcwd(), pattern)
                                endif
                                " Ignore the trailing `;' for recursive upwards searching because we
                                " always want the most specific pathname available.
                                let pattern = substitute(pattern, ';$', '', '')
                                " Expand the pattern.
                                call extend(pathnames, split(expand(pattern), "\n"))
                                if first_only && !empty(pathnames)
                                  return pathnames[0]
                                endif
                              endfor
                              return first_only ? '' : pathnames
                            endfunction
                            
                            " vim: ts=2 sw=2 et

SCRIPT  /home/carlos/.vim/plugged/deoplete.nvim/autoload/deoplete/util.vim
Sourced 1 time
Total time:   0.000365
 Self time:   0.000365

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: util.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000003 function! deoplete#util#print_error(string, ...) abort
                              let name = a:0 ? a:1 : 'deoplete'
                              echohl Error | echomsg printf('[%s] %s', name,
                                    \ deoplete#util#string(a:string)) | echohl None
                            endfunction
    1              0.000001 function! deoplete#util#print_warning(string) abort
                              echohl WarningMsg | echomsg '[deoplete] '
                                    \ . deoplete#util#string(a:string) | echohl None
                            endfunction
    1              0.000002 function! deoplete#util#print_debug(string) abort
                              echomsg '[deoplete] ' . deoplete#util#string(a:string)
                            endfunction
                            
    1              0.000001 function! deoplete#util#convert2list(expr) abort
                              return type(a:expr) ==# v:t_list ? a:expr : [a:expr]
                            endfunction
    1              0.000002 function! deoplete#util#string(expr) abort
                              return type(a:expr) ==# v:t_string ? a:expr : string(a:expr)
                            endfunction
                            
    1              0.000002 function! deoplete#util#get_input(event) abort
                              let mode = mode()
                              if a:event ==# 'InsertEnter'
                                let mode = 'i'
                              endif
                              let input = (mode ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?
                                    \      getline('.') :
                                    \      matchstr(getline('.'),
                                    \         '^.*\%' . (mode ==# 'i' ? col('.') : col('.') - 1)
                                    \         . 'c' . (mode ==# 'i' ? '' : '.'))
                            
                              if a:event ==# 'InsertCharPre'
                                let input .= v:char
                              endif
                            
                              return input
                            endfunction
    1              0.000002 function! deoplete#util#get_next_input(event) abort
                              return getline('.')[len(deoplete#util#get_input(a:event)) :]
                            endfunction
                            
    1              0.000001 function! deoplete#util#vimoption2python(option) abort
                              return '[\w' . s:vimoption2python(a:option) . ']'
                            endfunction
    1              0.000002 function! deoplete#util#vimoption2python_not(option) abort
                              return '[^\w' . s:vimoption2python(a:option) . ']'
                            endfunction
    1              0.000002 function! s:vimoption2python(option) abort
                              let has_dash = 0
                              let patterns = []
                              for pattern in split(a:option, ',')
                                if pattern =~# '\d\+'
                                  let pattern = substitute(pattern, '\d\+',
                                        \ '\=nr2char(submatch(0))', 'g')
                                endif
                            
                                if pattern ==# ''
                                  " ,
                                  call add(patterns, ',')
                                elseif pattern ==# '\'
                                  call add(patterns, '\\')
                                elseif pattern ==# '-'
                                  let has_dash = 1
                                else
                                  " Avoid ambiguous Python 3 RE syntax for nested sets
                                  if pattern =~# '^--'
                                    let pattern = '\' . pattern
                                  elseif pattern =~# '--$'
                                    let pattern = split(pattern, '-')[0] . '-\-'
                                  endif
                            
                                  call add(patterns, pattern)
                                endif
                              endfor
                            
                              " Dash must be last.
                              if has_dash
                                call add(patterns, '-')
                              endif
                            
                              return join(deoplete#util#uniq(patterns), '')
                            endfunction
                            
    1              0.000001 function! deoplete#util#uniq(list) abort
                              let list = map(copy(a:list), '[v:val, v:val]')
                              let i = 0
                              let seen = {}
                              while i < len(list)
                                let key = string(list[i][1])
                                if has_key(seen, key)
                                  call remove(list, i)
                                else
                                  let seen[key] = 1
                                  let i += 1
                                endif
                              endwhile
                              return map(list, 'v:val[0]')
                            endfunction
                            
    1              0.000002 function! deoplete#util#get_syn_names() abort
                              if col('$') >= 200
                                return []
                              endif
                            
                              let names = []
                              try
                                " Note: synstack() seems broken in concealed text.
                                for id in synstack(line('.'), (mode() ==# 'i' ? col('.')-1 : col('.')))
                                  let name = synIDattr(id, 'name')
                                  call add(names, name)
                                  if synIDattr(synIDtrans(id), 'name') !=# name
                                    call add(names, synIDattr(synIDtrans(id), 'name'))
                                  endif
                                endfor
                              catch
                                " Ignore error
                              endtry
                              return names
                            endfunction
                            
    1              0.000002 function! deoplete#util#neovim_version() abort
                              redir => v
                              silent version
                              redir END
                              return split(v, '\n')[0]
                            endfunction
                            
    1              0.000001 function! deoplete#util#has_yarp() abort
                              return !has('nvim') || deoplete#custom#_get_option('yarp')
                            endfunction
                            
    1              0.000001 function! deoplete#util#get_keyword_pattern(filetype) abort
                              let keyword_patterns = deoplete#custom#_get_option('keyword_patterns')
                              if empty(keyword_patterns)
                                let patterns = deoplete#custom#_get_filetype_option(
                                    \   'keyword_patterns', a:filetype, '')
                              else
                                let filetype = has_key(keyword_patterns, a:filetype) ? a:filetype : '_'
                                let patterns = get(keyword_patterns, filetype, '')
                              endif
                              let pattern = join(deoplete#util#convert2list(patterns), '|')
                            
                              " Convert keyword.
                              let k_pattern = deoplete#util#vimoption2python(
                                    \ &l:iskeyword . (&l:lisp ? ',-' : ''))
                              return substitute(pattern, '\\k', '\=k_pattern', 'g')
                            endfunction
                            
    1              0.000001 function! deoplete#util#rpcnotify(method, context) abort
                              if !deoplete#init#_channel_initialized()
                                return ''
                              endif
                            
                              let a:context['rpc'] = a:method
                            
                              if deoplete#util#has_yarp()
                                if g:deoplete#_yarp.job_is_dead
                                  return ''
                                endif
                                call g:deoplete#_yarp.notify(a:method, a:context)
                              else
                                call rpcnotify(g:deoplete#_channel_id, a:method, a:context)
                              endif
                            
                              return ''
                            endfunction
                            
                            " Compare versions.  Return values is the distance between versions.  Each
                            " version integer (from right to left) is an ascending power of 100.
                            "
                            " Example:
                            " '0.1.10' is (1 * 100) + 10, or 110.
                            " '1.2.3' is (1 * 10000) + (2 * 100) + 3, or 10203.
                            "
                            " Returns:
                            " <0 if a < b
                            " >0 if a > b
                            " 0 if versions are equal.
    1              0.000001 function! deoplete#util#versioncmp(a, b) abort
                              let a = map(split(a:a, '\.'), 'str2nr(v:val)')
                              let b = map(split(a:b, '\.'), 'str2nr(v:val)')
                              let l = min([len(a), len(b)])
                              let d = 0
                            
                              " Only compare the parts that are common to both versions.
                              for i in range(l)
                                let d += (a[i] - b[i]) * pow(100, l - i - 1)
                              endfor
                            
                              return d
                            endfunction
                            
    1              0.000002 function! deoplete#util#split(string) abort
                              return split(a:string, '\s*,\s*')
                            endfunction
                            
    1              0.000002 function! deoplete#util#check_eskk_phase_henkan() abort
                              if !exists('b:eskk') || empty(b:eskk)
                                return 0
                              endif
                            
                              let preedit = eskk#get_preedit()
                              let phase = preedit.get_henkan_phase()
                              return phase is g:eskk#preedit#PHASE_HENKAN
                            endfunction
                            
    1              0.000002 function! deoplete#util#check_popup() abort
                              return exists('*complete_info') && complete_info().mode ==# 'eval'
                            endfunction

SCRIPT  /home/carlos/.vim/plugged/vim-hug-neovim-rpc/autoload/neovim_rpc.vim
Sourced 1 time
Total time:   0.000305
 Self time:   0.000305

count  total (s)   self (s)
                            
    1              0.000005 if has('pythonx')
    1              0.000039     let g:neovim_rpc#py = 'pythonx'
    1              0.000006     let s:pyeval = function('pyxeval')
                            elseif has('python3')
                                let g:neovim_rpc#py = 'python3'
                                let s:pyeval = function('py3eval')
                            else
                                let g:neovim_rpc#py = 'python'
                                let s:pyeval = function('pyeval')
    1              0.000001 endif
                            
    1              0.000002 func! s:py(cmd)
                                execute g:neovim_rpc#py a:cmd
                            endfunc
                            
    1              0.000002 func! neovim_rpc#serveraddr()
                                if exists('g:_neovim_rpc_nvim_server')
                                    return g:_neovim_rpc_nvim_server
                                endif
                            
                                if &encoding !=? "utf-8"
                                    throw '[vim-hug-neovim-rpc] requires `:set encoding=utf-8`'
                                endif
                            
                                try
                                    call s:py('import pynvim')
                                catch
                                    try
                                        call s:py('import neovim')
                                    catch
                                        call neovim_rpc#_error("failed executing: " .
                                                    \ g:neovim_rpc#py . " import [pynvim|neovim]")
                                        call neovim_rpc#_error(v:exception)
                                        throw '[vim-hug-neovim-rpc] requires one of `:' . g:neovim_rpc#py .
                                                    \ ' import [pynvim|neovim]` command to work'
                                    endtry
                                endtry
                            
                                call s:py('import neovim_rpc_server')
                                let l:servers = s:pyeval('neovim_rpc_server.start()')
                            
                                let g:_neovim_rpc_nvim_server     = l:servers[0]
                                let g:_neovim_rpc_vim_server = l:servers[1]
                            
                                let g:_neovim_rpc_main_channel = ch_open(g:_neovim_rpc_vim_server)
                            
                                " identify myself
                                call ch_sendexpr(g:_neovim_rpc_main_channel,'neovim_rpc_setup')
                            
                                return g:_neovim_rpc_nvim_server
                            endfunc
                            
                            " elegant python function call wrapper
    1              0.000001 func! neovim_rpc#pyxcall(func,...)
                                call s:py('import vim, json')
                                let g:neovim_rpc#_tmp_args = copy(a:000)
                                let l:ret = s:pyeval(a:func . '(*vim.vars["neovim_rpc#_tmp_args"])')
                                unlet g:neovim_rpc#_tmp_args
                                return l:ret
                            endfunc
                            
                            " supported opt keys:
                            " - on_stdout
                            " - on_stderr
                            " - on_exit
                            " - detach
    1              0.000001 func! neovim_rpc#jobstart(cmd,...)
                            
                                let l:opts = {}
                                if len(a:000)
                                    let l:opts = a:1
                                endif
                            
                                let l:opts['_close'] = 0
                                let l:opts['_exit'] = 0
                            
                                let l:real_opts = {'mode': 'raw'}
                                if has_key(l:opts,'detach') && l:opts['detach']
                                    let l:real_opts['stoponexit'] = ''
                                endif
                            
                                if has_key(l:opts,'on_stdout')
                                    let l:real_opts['out_cb'] = function('neovim_rpc#_on_stdout')
                                endif
                                if has_key(l:opts,'on_stderr')
                                    let l:real_opts['err_cb'] = function('neovim_rpc#_on_stderr')
                                endif
                                let l:real_opts['exit_cb'] = function('neovim_rpc#_on_exit')
                                let l:real_opts['close_cb'] = function('neovim_rpc#_on_close')
                            
                                let l:job   = job_start(a:cmd, l:real_opts)
                                let l:jobid = ch_info(l:job)['id']
                            
                                let g:_neovim_rpc_jobs[l:jobid] = {'cmd':a:cmd, 'opts': l:opts, 'job': l:job}
                            
                                return l:jobid
                            endfunc
                            
    1              0.000001 func! neovim_rpc#jobstop(jobid)
                                let l:job = g:_neovim_rpc_jobs[a:jobid]['job']
                                return job_stop(l:job)
                            endfunc
                            
    1              0.000002 func! neovim_rpc#rpcnotify(channel,event,...)
                                call neovim_rpc#pyxcall('neovim_rpc_server.rpcnotify',a:channel,a:event,a:000)
                            endfunc
                            
    1              0.000002 let s:rspid = 1
    1              0.000002 func! neovim_rpc#rpcrequest(channel, event, ...)
                                let s:rspid = s:rspid + 1
                            
                                " a unique key for storing response
                                let rspid = '' . s:rspid
                            
                                " neovim's rpcrequest doesn't have timeout
                                let opt = {'timeout': 24 * 60 * 60 * 1000}
                                let args = ['rpcrequest', a:channel, a:event, a:000, rspid]
                                call ch_evalexpr(g:_neovim_rpc_main_channel, args, opt)
                            
                                let expr = 'neovim_rpc_server.responses.pop("' . rspid . '")'
                            
                                call s:py('import neovim_rpc_server, json')
                                let [err, result] = s:pyeval(expr)
                                if err
                                    if type(err) == type('')
                                        throw err
                                    endif
                                    throw err[1]
                                endif
                                return result
                            endfunc
                            
    1              0.000002 func! neovim_rpc#_on_stdout(job,data)
                                let l:jobid = ch_info(a:job)['id']
                                let l:opts = g:_neovim_rpc_jobs[l:jobid]['opts']
                                " convert to neovim style function call
                                call call(l:opts['on_stdout'],[l:jobid,split(a:data,"\n",1),'stdout'],l:opts)
                            endfunc
                            
    1              0.000002 func! neovim_rpc#_on_stderr(job,data)
                                let l:jobid = ch_info(a:job)['id']
                                let l:opts = g:_neovim_rpc_jobs[l:jobid]['opts']
                                " convert to neovim style function call
                                call call(l:opts['on_stderr'],[l:jobid,split(a:data,"\n",1),'stderr'],l:opts)
                            endfunc
                            
    1              0.000002 func! neovim_rpc#_on_exit(job,status)
                                let l:jobid = ch_info(a:job)['id']
                                let l:opts = g:_neovim_rpc_jobs[l:jobid]['opts']
                                let l:opts['_exit'] = 1
                                " cleanup when both close_cb and exit_cb is called
                                if l:opts['_close'] && l:opts['_exit']
                                    unlet g:_neovim_rpc_jobs[l:jobid]
                                endif
                                if has_key(l:opts, 'on_exit')
                                    " convert to neovim style function call
                                    call call(l:opts['on_exit'],[l:jobid,a:status,'exit'],l:opts)
                                endif
                            endfunc
                            
    1              0.000001 func! neovim_rpc#_on_close(job)
                                let l:jobid = ch_info(a:job)['id']
                                let l:opts = g:_neovim_rpc_jobs[l:jobid]['opts']
                                let l:opts['_close'] = 1
                                " cleanup when both close_cb and exit_cb is called
                                if l:opts['_close'] && l:opts['_exit']
                                    unlet g:_neovim_rpc_jobs[l:jobid]
                                endif
                            endfunc
                            
    1              0.000002 func! neovim_rpc#_callback()
                                execute g:neovim_rpc#py . ' neovim_rpc_server.process_pending_requests()'
                            endfunc
                            
    1              0.000016 let g:_neovim_rpc_main_channel = -1
    1              0.000015 let g:_neovim_rpc_jobs = {}
                            
    1              0.000002 let s:leaving = 0
                            
    1              0.000002 func! neovim_rpc#_error(msg)
                                if mode() == 'i'
                                    " NOTE: side effect, sorry, but this is necessary
                                    set nosmd
                                endif
                                echohl ErrorMsg
                                echom '[vim-hug-neovim-rpc] ' . a:msg
                                echohl None
                            endfunc
                            
    1              0.000002 func! neovim_rpc#_nvim_err_write(msg)
                                if mode() == 'i'
                                    " NOTE: side effect, sorry, but this is necessary
                                    set nosmd
                                endif
                                echohl ErrorMsg
                                let g:error = a:msg
                                echom a:msg
                                echohl None
                            endfunc
                            
    1              0.000002 func! neovim_rpc#_nvim_out_write(msg)
                                echom a:msg
                            endfunc

SCRIPT  /home/carlos/.vim/plugged/nvim-yarp/autoload/yarp.vim
Sourced 1 time
Total time:   0.000263
 Self time:   0.000263

count  total (s)   self (s)
                            
    1              0.000005 func! yarp#py3(module)
                                if type(a:module) == v:t_string
                                    let rp = {}
                                    let rp.module = a:module
                                else
                                    let rp = a:module
                                endif
                                let rp.init = function('yarp#pyx#init')
                                let rp.type = 'py3'
                                return yarp#core#new(rp)
                            endfunc
                            
    1              0.000002 func! yarp#py(module)
                                if type(a:module) == v:t_string
                                    let rp = {}
                                    let rp.module = a:module
                                else
                                    let rp = a:module
                                endif
                                let rp.init = function('yarp#pyx#init')
                                let rp.type = 'py'
                                return yarp#core#new(rp)
                            endfunc
                            

SCRIPT  /home/carlos/.vim/plugged/nvim-yarp/autoload/yarp/core.vim
Sourced 1 time
Total time:   0.000734
 Self time:   0.000734

count  total (s)   self (s)
    1              0.000006 if get(s:, 'loaded', 0)
                                finish
    1              0.000001 endif
    1              0.000003 let s:loaded = 1
                            
    1              0.000002 let s:id = 1
    1              0.000003 let s:reg = {}
    1              0.000002 let s:leaving = 0
                            
    1              0.000005 augroup yarp
    1              0.000291     autocmd!
                                " this one is which you're most likely to use?
    1              0.000013     autocmd VimLeavePre * let s:leaving = 1 
    1              0.000001 augroup end
                            
    1              0.000004 if has('nvim')
                                let s:rpcrequest = 'rpcrequest'
                                let s:rpcnotify = 'rpcnotify'
                                let s:jobstart = 'jobstart'
                                fun! s:_serveraddr()
                                    return v:servername
                                endfunc
                                let s:serveraddr = function('s:_serveraddr')
    1              0.000001 else
    1              0.000004     let s:rpcrequest = get(g:, 'yarp_rpcrequest', 'neovim_rpc#rpcrequest')
    1              0.000004     let s:rpcnotify = get(g:, 'yarp_rpcnotify', 'neovim_rpc#rpcnotify')
    1              0.000004     let s:jobstart = get(g:, 'yarp_jobstart', 'neovim_rpc#jobstart')
    1              0.000004     let s:serveraddr = get(g:, 'yarp_serveraddr', 'neovim_rpc#serveraddr')
    1              0.000001 endif
                            
    1              0.000003 func! yarp#core#new(rp)
                                let s:id = s:id + 1
                            
                                let rp = a:rp
                                let rp.jobstart = function('yarp#core#jobstart')
                                func rp.error(msg) dict
                                    call yarp#core#error(self.module, a:msg)
                                endfunc
                                func rp.warn(msg) dict
                                    call yarp#core#warn(self.module, a:msg)
                                endfunc
                                let rp.call = function('yarp#core#request')
                                let rp.request = function('yarp#core#request')
                                let rp.notify = function('yarp#core#notify')
                                let rp.try_notify = function('yarp#core#try_notify')
                                let rp.wait_channel = function('yarp#core#wait_channel')
                                let rp.id = s:id
                                let rp.job_is_dead = 0
                                let s:reg[rp.id] = rp
                            
                                " options
                                let rp.on_load = get(rp, 'on_load', function('yarp#core#_nop'))
                                let rp.job_detach = get(rp, 'job_detach', 0)
                            
                                " reserved for user
                                let rp.user_data = get(rp, 'user_data', {})
                                return rp
                            endfunc
                            
    1              0.000002 func! yarp#core#_nop(...) dict
                            endfunc
                            
    1              0.000003 func! yarp#core#on_stderr(chan_id, data, event) dict
                                let mod = self.self
                                call mod.error(filter(a:data, 'len(v:val)'))
                            endfunc
                            
    1              0.000002 func! yarp#core#on_exit(chan_id, data, event) dict
                                let mod = self.self
                                let mod.job_is_dead = 1
                                if has_key(mod, 'channel')
                                    unlet mod.channel
                                endif
                            
                                if has("nvim")
                                    if v:exiting is 0
                                        return
                                    endif
                                elseif v:dying || s:leaving
                                    return
                                endif
                                call mod.error("Job is dead. cmd=" . string(mod.cmd))
                            endfunc
                            
    1              0.000003 func! yarp#core#channel_started(id, channel)
                                let rp = s:reg[a:id]
                                let rp.channel = a:channel
                                call call(rp.on_load, [], rp)
                            endfunc
                            
    1              0.000002 func! yarp#core#request(method, ...) dict
                                call self.wait_channel()
                                return call(s:rpcrequest, [self.channel, a:method] + a:000)
                            endfunc
                            
    1              0.000002 func! yarp#core#notify(method, ...) dict
                                call self.wait_channel()
                                call call(s:rpcnotify, [self.channel, a:method] + a:000)
                            endfunc
                            
    1              0.000002 func! yarp#core#try_notify(method, ...) dict
                                call self.jobstart()
                                if get(self, 'job_is_dead', 0)
                                    call self.error('try_notify ' . a:method . ' failed, job is dead')
                                    return 0
                                endif
                                if !has_key(self, 'channel')
                                    " not yet started
                                    return 0
                                endif
                                let args = [self.channel, a:method] + a:000
                                try
                                    call call(s:rpcnotify, args)
                                    return 1
                                catch
                                    call self.error('try_notify ' . s:rpcnotify . ' ' . a:method . ' failed: ' . v:exception . ', ' . string(args))
                                    return 0
                                endtry
                            endfunc
                            
    1              0.000002 func! yarp#core#wait_channel() dict
                                if has_key(self, 'channel')
                                    return
                                endif
                                if ! has_key(self, 'job')
                                    call self.jobstart()
                                endif
                                if get(self, 'job', -1) == -1
                                    throw '[yarp] [' . self.module . '] job is not running'
                                endif
                                let cnt = 5000 / 20
                                while ! has_key(self, 'channel')
                                    if self.job_is_dead
                                        throw '[yarp] [' . self.module .
                                                \ '] job is dead. failed establishing channel for ' .
                                                \ string(self.cmd)
                                    endif
                                    if cnt <= 0
                                        throw '[yarp] [' . self.module . '] timeout establishing channel for ' . string(self.cmd)
                                    endif
                                    let cnt = cnt - 1
                                    silent sleep 20m
                                endwhile
                            endfunc
                            
    1              0.000002 func! yarp#core#jobstart() dict
                                if ! has_key(self, 'cmd')
                                    call self.init()
                                    if ! has_key(self, 'cmd')
                                        call self.error("cmd of the job is not set")
                                        return
                                    endif
                                endif
                                if has_key(self, 'job')
                                    return
                                endif
                                let opts = {'on_stderr': function('yarp#core#on_stderr'),
                                        \ 'on_exit': function('yarp#core#on_exit'),
                                        \ 'detach': self.job_detach,
                                        \ 'self': self}
                                try
                                    let self.job = call(s:jobstart, [self.cmd, opts])
                                    if self.job == -1
                                        call self.error('Failed starting job: ' . string(self.cmd))
                                    endif
                                catch
                                    let self.job = -1
                                    call self.error(['Failed starting job: ' . string(self.cmd), v:exception])
                                endtry
                            endfunc
                            
    1              0.000002 func! yarp#core#serveraddr()
                                return call (s:serveraddr, [])
                            endfunc
                            
    1              0.000002 func! yarp#core#error(mod, msg)
                                if mode() == 'i'
                                    " NOTE: side effect, sorry, but this is necessary
                                    set nosmd
                                endif
                                if type(a:msg) == type("")
                                    let lines = split(a:msg, "\n", 1)
                                else
                                    let lines = a:msg
                                endif
                                echoh ErrorMsg
                                for line in lines
                                    echom '[' . a:mod . '@yarp] ' . line
                                endfor
                                echoh None
                            endfunc
                            
    1              0.000002 func! yarp#core#warn(mod, msg)
                                if mode() == 'i'
                                    " NOTE: side effect, sorry, but this is necessary
                                    set nosmd
                                endif
                                if type(a:msg) == type("")
                                    let lines = split(a:msg, "\n", 1)
                                else
                                    let lines = a:msg
                                endif
                                echoh WarningMsg
                                for line in lines
                                    echom '[' . a:mod . '@yarp] ' . line
                                endfor
                                echoh None
                            endfunc

SCRIPT  /home/carlos/.vim/plugged/nvim-yarp/autoload/yarp/pyx.vim
Sourced 1 time
Total time:   0.000280
 Self time:   0.000280

count  total (s)   self (s)
                            
    1              0.000003 func! yarp#pyx#init() dict
                                if self.type == 'py'
                                    let l:Detect = function('s:pyexe')
                                else
                                    let l:Detect = function('s:py3exe')
                                endif
                            
                                let exe = call(l:Detect, [], self)
                            
                                if get(s:, 'script', '') == ''
                                    let s:script = globpath(&rtp,'pythonx/yarp.py',1,1)[0]
                                endif
                            
                                let self.cmd = [exe,
                                            \ '-u',
                                            \ s:script,
                                            \ yarp#core#serveraddr(),
                                            \ self.id,
                                            \ self.module]
                            
                                 call self.jobstart()
                            endfunc
                            
    1              0.000003 func! s:pyexe() dict
                                if get(g:, '_yarp_py', '')
                                    return g:_yarp_py
                                endif
                                let g:_yarp_py = expand(get(g:, 'python_host_prog', ''), 1)
                                if g:_yarp_py == '' && has('nvim') && has('python')
                                    " heavy weight
                                    " but better support for python detection
                                    python import sys
                                    let g:_yarp_py = pyeval('sys.executable')
                                endif
                                if g:_yarp_py == ''
                                    let g:_yarp_py = 'python2'
                                endif
                                return g:_yarp_py
                            endfunc
                            
    1              0.000001 func! s:py3exe() dict
                                if get(g:, '_yarp_py3', '')
                                    return g:_yarp_py3
                                endif
                                let g:_yarp_py3 = expand(get(g:, 'python3_host_prog', ''), 1)
                                if g:_yarp_py3 == '' && has('nvim') && has('python3')
                                    " heavy weight
                                    " but better support for python detection
                                    python3 import sys
                                    let g:_yarp_py3 = py3eval('sys.executable')
                                endif
                                if g:_yarp_py3 == ''
                                    let g:_yarp_py3 = 'python3'
                                endif
                                if exepath(g:_yarp_py3) == ''
                                    call self.error(
                                                \ "Python3 executable [" .
                                                \ g:_yarp_py3 .
                                                \ "] not found.")
                                    if has('vim_starting')
                                        call self.error("")
                                    endif
                                    call self.error("###### Please configure g:python3_host_prog properly ######")
                                    if has('vim_starting')
                                        call self.error("")
                                    endif
                                endif
                                return g:_yarp_py3
                            endfunc
                            

SCRIPT  /home/carlos/.vim/plugged/deoplete.nvim/autoload/deoplete/handler.vim
Sourced 1 time
Total time:   0.000899
 Self time:   0.000899

count  total (s)   self (s)
                            "=============================================================================
                            " FILE: handler.vim
                            " AUTHOR: Shougo Matsushita <Shougo.Matsu at gmail.com>
                            " License: MIT license
                            "=============================================================================
                            
    1              0.000008 function! deoplete#handler#_init() abort
                              augroup deoplete
                                autocmd!
                                autocmd InsertLeave * call s:on_insert_leave()
                                autocmd CompleteDone * call s:on_complete_done()
                              augroup END
                            
                              for event in [
                                    \ 'InsertEnter', 'BufReadPost', 'BufWritePost', 'VimLeavePre',
                                    \ ]
                                call s:define_on_event(event)
                              endfor
                            
                              if deoplete#custom#_get_option('on_text_changed_i')
                                call s:define_completion_via_timer('TextChangedI')
                              endif
                              if deoplete#custom#_get_option('on_insert_enter')
                                call s:define_completion_via_timer('InsertEnter')
                              endif
                              if deoplete#custom#_get_option('refresh_always')
                                if exists('##TextChangedP')
                                  call s:define_completion_via_timer('TextChangedP')
                                else
                                  call s:define_completion_via_timer('InsertCharPre')
                                endif
                              endif
                            
                              " Note: Vim 8 GUI(MacVim and Win32) is broken
                              " dummy timer call is needed before complete()
                              if !has('nvim') && has('gui_running')
                                    \ && (has('gui_macvim') || has('win32'))
                                let s:dummy_timer = timer_start(200, {timer -> 0}, {'repeat': -1})
                              endif
                            
                              if deoplete#util#has_yarp()
                                " To fix "RuntimeError: Event loop is closed" issue
                                " Note: Workaround
                                autocmd deoplete VimLeavePre * call s:kill_yarp()
                              endif
                            endfunction
                            
    1              0.000004 function! deoplete#handler#_do_complete() abort
                              let context = g:deoplete#_context
                              let event = get(context, 'event', '')
                              let modes = (event ==# 'InsertEnter') ? ['n', 'i'] : ['i']
                              if s:is_exiting() || index(modes, mode()) < 0 || s:check_input_method()
                                return
                              endif
                            
                              if !has_key(context, 'candidates')
                                    \ || deoplete#util#get_input(context.event) !=# context.input
                                return
                              endif
                            
                              let prev = g:deoplete#_prev_completion
                              let prev.event = context.event
                              let prev.input = context.input
                              let prev.candidates = context.candidates
                              let prev.complete_position = context.complete_position
                              let prev.linenr = line('.')
                            
                              let auto_popup = deoplete#custom#_get_option(
                                    \ 'auto_complete_popup') !=# 'manual'
                            
                              " Enable auto refresh when popup is displayed
                              if deoplete#util#check_popup()
                                let auto_popup = v:true
                              endif
                            
                              if context.event ==# 'Manual'
                                let context.event = ''
                              elseif !exists('g:deoplete#_saved_completeopt') && auto_popup
                                call deoplete#mapping#_set_completeopt()
                              endif
                            
                              if auto_popup
                                call feedkeys("\<Plug>_", 'i')
                              endif
                            endfunction
                            
    1              0.000005 function! deoplete#handler#_check_omnifunc(context) abort
                              let prev = g:deoplete#_prev_completion
                              let blacklist = ['LanguageClient#complete']
                              if a:context.event ==# 'Manual'
                                    \ || &l:omnifunc ==# ''
                                    \ || index(blacklist, &l:omnifunc) >= 0
                                    \ || prev.input ==# a:context.input
                                    \ || s:check_input_method()
                                    \ || deoplete#custom#_get_option('auto_complete_popup') ==# 'manual'
                                return
                              endif
                            
                              for filetype in a:context.filetypes
                                for pattern in deoplete#util#convert2list(
                                      \ deoplete#custom#_get_filetype_option(
                                      \   'omni_patterns', filetype, ''))
                                  if pattern !=# '' && a:context.input =~# '\%('.pattern.'\)$'
                                    let g:deoplete#_context.candidates = []
                            
                                    let prev.event = a:context.event
                                    let prev.input = a:context.input
                                    let prev.candidates = []
                            
                                    if &completeopt =~# 'noselect'
                                      call deoplete#mapping#_set_completeopt()
                                      call feedkeys("\<C-x>\<C-o>", 'in')
                                    else
                                      call deoplete#util#print_error(
                                            \ 'omni_patterns feature is disabled.')
                                      call deoplete#util#print_error(
                                            \ 'You need to set "noselect" in completeopt option.')
                                    endif
                                    return 1
                                  endif
                                endfor
                              endfor
                            endfunction
                            
    1              0.000007 function! s:completion_timer_start(event) abort
                              if exists('s:completion_timer')
                                call s:completion_timer_stop()
                              endif
                            
                              let delay = deoplete#custom#_get_option('auto_complete_delay')
                              if delay > 0
                                let s:completion_timer = timer_start(
                                      \ delay, {-> deoplete#handler#_completion_begin(a:event)})
                              else
                                call deoplete#handler#_completion_begin(a:event)
                              endif
                            endfunction
    1              0.000005 function! s:completion_timer_stop() abort
                              if !exists('s:completion_timer')
                                return
                              endif
                            
                              call timer_stop(s:completion_timer)
                              unlet s:completion_timer
                            endfunction
                            
    1              0.000005 function! s:check_prev_completion(event) abort
                              let prev = g:deoplete#_prev_completion
                              if a:event ==# 'Async' || a:event ==# 'Update' || mode() !=# 'i'
                                    \ || empty(get(prev, 'candidates', []))
                                    \ || s:check_input_method()
                                return
                              endif
                            
                              let input = deoplete#util#get_input(a:event)
                              let complete_str = matchstr(input, '\w\+$')
                              let min_pattern_length = deoplete#custom#_get_option('min_pattern_length')
                              if prev.linenr != line('.') || len(complete_str) < min_pattern_length
                                return
                              endif
                            
                              call deoplete#mapping#_set_completeopt()
                            
                              let mode = deoplete#custom#_get_option('prev_completion_mode')
                              let candidates = copy(prev.candidates)
                            
                              if mode ==# 'filter' || mode ==# 'length'
                                let input = input[prev.complete_position :]
                                let escaped_input = escape(input, '~\.^$[]*')
                                let pattern = substitute(escaped_input, '\w', '\\w*\0', 'g')
                                call filter(candidates, 'v:val.word =~? pattern')
                                if mode ==# 'length'
                                  call filter(candidates, 'len(v:val.word) > len(input)')
                                endif
                              elseif mode ==# 'mirror'
                                " pass
                              else
                                return
                              endif
                            
                              let g:deoplete#_filtered_prev = {
                                    \ 'complete_position': prev.complete_position,
                                    \ 'candidates': candidates,
                                    \ }
                              call feedkeys("\<Plug>+", 'i')
                            endfunction
                            
    1              0.000005 function! deoplete#handler#_async_timer_start() abort
                              let delay = deoplete#custom#_get_option('auto_refresh_delay')
                              if delay <= 0
                                return
                              endif
                            
                              call timer_start(max([20, delay]), {-> deoplete#auto_complete()})
                            endfunction
                            
    1              0.000004 function! deoplete#handler#_completion_begin(event) abort
                              call deoplete#custom#_update_cache()
                            
                              if s:is_skip(a:event)
                                let g:deoplete#_context.candidates = []
                                return
                              endif
                            
                              call s:check_prev_completion(a:event)
                            
                              if a:event !=# 'Update' && a:event !=# 'Async'
                                call deoplete#init#_prev_completion()
                              endif
                            
                              call deoplete#util#rpcnotify(
                                    \ 'deoplete_auto_completion_begin', {'event': a:event})
                            endfunction
    1              0.000005 function! s:is_skip(event) abort
                              if a:event ==# 'TextChangedP' && !empty(v:completed_item)
                                return 1
                              endif
                            
                              " Note: The check is needed for <C-y> mapping
                              if s:is_skip_prev_text(a:event)
                                return 1
                              endif
                            
                              if s:is_skip_text(a:event)
                                " Close the popup
                                if deoplete#util#check_popup()
                                  call feedkeys("\<Plug>_", 'i')
                                endif
                            
                                return 1
                              endif
                            
                              let auto_complete = deoplete#custom#_get_option('auto_complete')
                            
                              if &paste
                                    \ || (a:event !=# 'Manual' && a:event !=# 'Update' && !auto_complete)
                                    \ || (&l:completefunc !=# '' && &l:buftype =~# 'nofile')
                                    \ || (a:event !=# 'InsertEnter' && mode() !=# 'i')
                                return 1
                              endif
                            
                              return 0
                            endfunction
    1              0.000005 function! s:is_skip_prev_text(event) abort
                              let input = deoplete#util#get_input(a:event)
                            
                              " Note: Use g:deoplete#_context is needed instead of
                              " g:deoplete#_prev_completion
                              let prev_input = get(g:deoplete#_context, 'input', '')
                              if input ==# prev_input
                                    \ && input !=# ''
                                    \ && a:event !=# 'Manual'
                                    \ && a:event !=# 'Async'
                                    \ && a:event !=# 'Update'
                                    \ && a:event !=# 'TextChangedP'
                                return 1
                              endif
                            
                              return 0
                            endfunction
    1              0.000004 function! s:is_skip_text(event) abort
                              let input = deoplete#util#get_input(a:event)
                            
                              let lastchar = matchstr(input, '.$')
                              let skip_multibyte = deoplete#custom#_get_option('skip_multibyte')
                              if skip_multibyte && len(lastchar) != strwidth(lastchar)
                                    \ && empty(get(b:, 'eskk', []))
                                return 1
                              endif
                            
                              let displaywidth = strdisplaywidth(input) + 1
                              let is_virtual = virtcol('.') >= displaywidth
                              if &l:formatoptions =~# '[tca]' && &l:textwidth > 0
                                    \     && displaywidth >= &l:textwidth
                                if &l:formatoptions =~# '[ta]'
                                      \ || !empty(filter(deoplete#util#get_syn_names(),
                                      \                  "v:val ==# 'Comment'"))
                                      \ || is_virtual
                                  return 1
                                endif
                              endif
                            
                              let skip_chars = deoplete#custom#_get_option('skip_chars')
                            
                              return (a:event !=# 'Manual' && input !=# ''
                                    \     && index(skip_chars, input[-1:]) >= 0)
                            endfunction
    1              0.000004 function! s:check_input_method() abort
                              return exists('*getimstatus') && getimstatus()
                            endfunction
                            
    1              0.000005 function! s:define_on_event(event) abort
                              if !exists('##' . a:event)
                                return
                              endif
                            
                              execute 'autocmd deoplete' a:event
                                    \ '* if !&l:previewwindow | call deoplete#send_event('
                                    \ .string(a:event).') | endif'
                            endfunction
    1              0.000005 function! s:define_completion_via_timer(event) abort
                              if !exists('##' . a:event)
                                return
                              endif
                            
                              execute 'autocmd deoplete' a:event
                                    \ '* call s:completion_timer_start('.string(a:event).')'
                            endfunction
                            
    1              0.000004 function! s:on_insert_leave() abort
                              call deoplete#mapping#_restore_completeopt()
                              let g:deoplete#_context = {}
                              call deoplete#init#_prev_completion()
                            endfunction
                            
    1              0.000004 function! s:on_complete_done() abort
                              if get(v:completed_item, 'word', '') ==# ''
                                return
                              endif
                              call deoplete#handler#_skip_next_completion()
                            
                              if get(v:completed_item, 'user_data', '') !=# ''
                                try
                                  if type(v:completed_item.user_data) == type('')
                                    call s:substitute_suffix(json_decode(v:completed_item.user_data))
                                  endif
                                catch /.*/
                                endtry
                              endif
                            endfunction
    1              0.000005 function! s:substitute_suffix(user_data) abort
                              if !deoplete#custom#_get_option('complete_suffix')
                                    \ || !has_key(a:user_data, 'old_suffix')
                                    \ || !has_key(a:user_data, 'new_suffix')
                                return
                              endif
                              let old_suffix = a:user_data.old_suffix
                              let new_suffix = a:user_data.new_suffix
                            
                              let next_text = deoplete#util#get_next_input('CompleteDone')
                              if stridx(next_text, old_suffix) != 0
                                return
                              endif
                            
                              let next_text = new_suffix . next_text[len(old_suffix):]
                              call setline('.', deoplete#util#get_input('CompleteDone') . next_text)
                            endfunction
                            
    1              0.000005 function! deoplete#handler#_skip_next_completion() abort
                              if !exists('g:deoplete#_context')
                                return
                              endif
                            
                              let input = deoplete#util#get_input('CompleteDone')
                              if input !~# '[/.]$'
                                let g:deoplete#_context.input = input
                              endif
                              call deoplete#mapping#_restore_completeopt()
                              call deoplete#init#_prev_completion()
                            endfunction
                            
    1              0.000003 function! s:is_exiting() abort
                              return exists('v:exiting') && v:exiting != v:null
                            endfunction
                            
    1              0.000003 function! s:kill_yarp() abort
                              if !exists('g:deoplete#_yarp')
                                return
                              endif
                            
                              if g:deoplete#_yarp.job_is_dead
                                return
                              endif
                            
                              let job = g:deoplete#_yarp.job
                              if !has('nvim') && !exists('g:yarp_jobstart')
                                " Get job object from vim-hug-neovim-rpc
                                let job = g:_neovim_rpc_jobs[job].job
                              endif
                            
                              if has('nvim')
                                call jobstop(job)
                              else
                                call job_stop(job, 'kill')
                              endif
                            
                              let g:deoplete#_yarp.job_is_dead = 1
                            endfunction

SCRIPT  /home/carlos/.vim/plugged/vim-anzu/autoload/anzu.vim
Sourced 1 time
Total time:   0.000785
 Self time:   0.000785

count  total (s)   self (s)
    1              0.000008 scriptencoding utf-8
    1              0.000016 let s:save_cpo = &cpo
    1              0.000024 set cpo&vim
                            
    1              0.000005 let s:status_cache = ""
                            
    1              0.000005 function! anzu#search_status()
                            	return substitute(s:status_cache, '<anzustatushighlight>.\{-}<\/anzustatushighlight>', "", "g")
                            endfunction
                            
    1              0.000004 function! anzu#clear_search_status()
                            	let s:status_cache = ""
                            endfunction
                            
    1              0.000004 function! anzu#echohl_search_status()
                            	if empty(s:status_cache)
                            		return
                            	endif
                            	let text = s:status_cache
                            	try
                            		let len = 0
                            		let max_len = &columns * (&cmdheight -1) + &columns / 2
                            		for word in split(text . "<anzustatushighlight>None<\/anzustatushighlight>", '<anzustatushighlight>.\{-}<\/anzustatushighlight>\zs')
                            			let output = matchstr(word, '\zs.*\ze<anzustatushighlight>.*<\/anzustatushighlight>')
                            			if max_len > len + len(output)
                            				echon output
                            				let len += len(output)
                            			else
                            				echon output[ : max_len - len -1 ]
                            				return
                            			endif
                            			execute "echohl" matchstr(word, '.*<anzustatushighlight>\zs.*\ze<\/anzustatushighlight>')
                            		endfor
                            	finally
                            		echohl None
                            	endtry
                            endfunction
                            
                            
                            " a <= b
    1              0.000006 function! s:pos_less_equal(a, b)
                            	return a:a[0] == a:b[0] ? a:a[1] <= a:b[1] : a:a[0] <= a:b[0]
                            endfunction
                            
                            
                            " function! s:search_less_pos(pos_list, pos)
                            " 	let index = 0
                            " 	for pos in a:pos_list
                            " 		if s:pos_less_equal(a:pos, pos)
                            " 			return index
                            " 		endif
                            " 		let index = index + 1
                            " 	endfor
                            " 	return -1
                            " endfunction
                            
                            
    1              0.000006 function! s:print_status(format, pattern, index, len, wrap)
                            	let result = a:format
                            	let result = substitute(result, '%#\(.\{-}\)#', '<anzustatushighlight>\1<\/anzustatushighlight>', "g")
                            	let result = substitute(result, '%i', a:index, "g")
                            	let result = substitute(result, '%l', a:len, "g")
                            	let result = substitute(result, '%w', a:wrap, "g")
                            	let result = substitute(result, '%p', a:pattern, "g")
                            	" Fix \<homu\> to view
                            	let result = substitute(result, '%/', substitute(histget("/", -1), '\\', '\\\\', "g"), "g")
                            	return result
                            endfunction
                            
                            
    1              0.000005 function! s:clamp_pos(pos, min, max)
                            	return s:pos_less_equal(a:min, a:pos) && s:pos_less_equal(a:pos, a:max)
                            endfunction
                            
                            
    1              0.000004 function! anzu#get_on_pattern_pos(pat)
                            	if a:pat == ""
                            		return getpos(".")
                            	endif
                            	let pos = getpos(".")
                            	let first = searchpos(a:pat, 'nWbc')
                            	let last  = searchpos(a:pat, 'nWeb')
                            	if s:pos_less_equal(last, first)
                            		let last  = searchpos(a:pat, 'nWec')
                            	endif
                            	if s:clamp_pos(pos[1:2], first, last)
                            		return [0, first[0], first[1], 0]
                            	endif
                            	return pos
                            endfunction
                            
                            
    1              0.000004 function! anzu#update(pattern, cursor_pos, ...)
                            	let pattern = a:pattern
                            	let cursor = a:cursor_pos
                            	if pattern == ""
                            		return
                            	endif
                            
                            	let pos_all = s:searchpos(pattern)
                            	
                            	if empty(pos_all)
                            		let s:status_cache = s:print_status(g:anzu_no_match_word, pattern, "", "", "")
                            		return -1
                            	endif
                            
                            	let index = index(pos_all, [cursor[1], cursor[2]])
                            	if index == -1
                            		return -1
                            	endif
                            
                            	let wrap_mes = get(a:, 1, "")
                            
                            	let pattern = substitute(pattern, '\\', '\\\\', 'g')
                            	let s:status_cache = s:print_status(g:anzu_status_format, pattern, index+1, len(pos_all), wrap_mes)
                            endfunction
                            
                            
    1              0.000003 function! anzu#clear_search_cache(...)
                            	let bufnr = get(a:, 1, bufnr("%"))
                            	call setbufvar(bufnr, "anzu_searchpos_cache", {})
                            endfunction
                            
                            
    1              0.000003 function! anzu#getpos(pattern, count)
                            	return get(s:searchpos(a:pattern), a:count, [])
                            endfunction
                            
                            
    1              0.000004 function! anzu#jump(pattern, count)
                            	let pos = anzu#getpos(a:pattern, a:count)
                            	if empty(pos)
                            		return
                            	endif
                            	call setpos(".", [0] + pos + [0])
                            endfunction
                            
                            
    1              0.000004 function! anzu#jump_key(key, count)
                            	if a:count
                            		call anzu#jump(@/, a:count - 1)
                            		AnzuUpdateSearchStatus
                            	else
                            		if !empty(a:key)
                            			try
                            				execute "normal" a:key
                            			catch
                            				echohl ErrorMsg | echo matchstr(v:exception, 'Vim(normal):\zs.*\ze') | echohl None
                            				call anzu#clear_search_status()
                            				return -1
                            			endtry
                            " 			execute "normal" a:key
                            		endif
                            	endif
                            endfunction
                            
                            
    1              0.000003 function! anzu#mapexpr_jump(...)
                            	let l:count  = get(a:, 1, "")
                            	let key = get(a:, 2, "")
                            	return ":\<C-u>if anzu#jump_key(\"" . key . "\", " . l:count . ") != -1 \<Bar> set hlsearch \<Bar> endif\<CR>"
                            endfunction
                            
                            
    1              0.000004 function! s:searchpos(pattern, ...)
                            	let bufnr = get(a:, 1, bufnr("%"))
                            	let uncache = get(a:, 2, 0)
                            	if uncache
                            		return s:searchpos_all(a:pattern)
                            	endif
                            	let cache = getbufvar(bufnr, "anzu_searchpos_cache")
                            	if type(cache) == type("")
                            		unlet cache
                            		let cache = {}
                            	endif
                            
                            	if has_key(cache, a:pattern)
                            		return deepcopy(cache[a:pattern])
                            	endif
                            	let searchpos = s:searchpos_all(a:pattern)
                            	let cache[a:pattern] = searchpos
                            	call setbufvar(bufnr, "anzu_searchpos_cache", cache)
                            	return searchpos
                            endfunction
                            
                            
                            
    1              0.000004 function! s:searchpos_all(pattern)
                            	" winsave view correctly restores curswant
                            	let old_pos = winsaveview()
                            	let result = []
                            	try
                            		call setpos(".", [0, line("$"), strlen(getline("$")), 0])
                            		while 1
                            			silent! let pos = searchpos(a:pattern, "w")
                            			if pos == [0, 0] || index(result, pos) != -1
                            				break
                            			endif
                            			call add(result, pos)
                            			if len(result) >= g:anzu_search_limit
                            				break
                            			endif
                            		endwhile
                            	finally
                            		call winrestview(old_pos)
                            	endtry
                            	return result
                            endfunction
                            
    1              0.000003 function! anzu#searchpos(...)
                            	return call("s:searchpos", a:000)
                            endfunction
                            
                            
    1              0.000003 function! anzu#clear_sign_matchline()
                            	call s:clear_sign_all()
                            endfunction
                            
                            
                            " 1はダミーに使用
    1              0.000005 let s:sign_id_dummy = 1
    1              0.000004 let s:sign_id_init = 2
    1              0.000005 let s:sign_id_count = s:sign_id_init
    1              0.000004 function! s:sign(line, bufnr)
                            	execute printf("sign place %d line=%d name=anzu_sign_matchline buffer=%d", s:sign_id_count, a:line, a:bufnr)
                            	let s:sign_id_count += 1
                            endfunction
                            
    1              0.000004 function! s:clear_sign_id(id)
                            	execute printf("sign unplace %d", a:id)
                            endfunction
                            
    1              0.000004 function! s:clear_sign_all()
                            	call map(range(s:sign_id_init, s:sign_id_count), "s:clear_sign_id(v:val)")
                            	let s:sign_id_count = s:sign_id_init
                            endfunction
                            
    1              0.000003 function! s:is_signed()
                            	return s:sign_id_count != s:sign_id_init
                            endfunction
                            
                            
    1              0.000004 function! anzu#sign_matchline(pattern)
                            	highlight AnzuMatchline ctermbg=Yellow ctermfg=Yellow guibg=Yellow guifg=Yellow
                            	sign define anzu_sign_matchline text=>> texthl=AnzuMatchline
                            
                            	highlight AnzuDummyhighlight ctermbg=NONE ctermfg=NONE guibg=NONE guifg=NONE
                            	sign define anzu_sign_dummy texthl=AnzuDummyhighlight
                            
                            	call s:update_sign(a:pattern)
                            endfunction
                            
                            
    1              0.000004 let s:cache_top = 0
    1              0.000004 let s:cache_bottom = 0
    1              0.000004 function! anzu#smart_sign_matchline(pattern)
                            	let top = line("w0")
                            	let bottom = line("w$")
                            	if s:is_signed() && (top == s:cache_top && bottom == s:cache_bottom)
                            		return
                            	endif
                            	let s:cache_top = top
                            	let s:cache_bottom = bottom
                            	call anzu#sign_matchline(a:pattern)
                            endfunction
                            
                            
    1              0.000004 function! s:sign_lines(pattern)
                            	let top = line("w0")
                            	let bottom = line("w$")
                            	let height = bottom - top
                            	let rate = str2float(height) / line("$")
                            	let lines = map(deepcopy(s:searchpos(a:pattern)), "float2nr(v:val[0] * rate) + top")
                            	return lines
                            endfunction
                            
                            
    1              0.000004 function! s:update_sign(pattern)
                            	let lines = s:sign_lines(a:pattern)
                            	if empty(lines)
                            		return
                            	endif
                            
                            	let lines = s:uniq_sort(lines)
                            
                            	" チラツキ防止用
                            	execute printf("sign place %d line=1 name=anzu_sign_dummy buffer=%d", s:sign_id_dummy, bufnr("%"))
                            	try
                            		AnzuClearSignMatchLine
                            		let bufnr = bufnr("%")
                            		call map(lines, "s:sign(v:val, bufnr)")
                            	finally
                            		execute printf("sign unplace %d", s:sign_id_dummy)
                            	endtry
                            endfunction
                            
    1              0.000004 function! s:uniq_sort(list)
                            	let result = []
                            	for item in a:list
                            		if index(result, item) == -1
                            			call add(result, item)
                            		endif
                            	endfor
                            	return result
                            endfunction
                            
                            
    1              0.000017 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo

SCRIPT  /home/carlos/.vim/plugged/vim-fugitive/autoload/fugitive.vim
Sourced 1 time
Total time:   0.004878
 Self time:   0.004381

count  total (s)   self (s)
                            " Location:     autoload/fugitive.vim
                            " Maintainer:   Tim Pope <http://tpo.pe/>
                            
    1              0.000004 if exists('g:autoloaded_fugitive')
                              finish
    1              0.000001 endif
    1              0.000013 let g:autoloaded_fugitive = 1
                            
    1              0.000003 if !exists('g:fugitive_git_executable')
    1              0.000012   let g:fugitive_git_executable = 'git'
                            elseif g:fugitive_git_executable =~# '^\w\+='
                              let g:fugitive_git_executable = 'env ' . g:fugitive_git_executable
    1              0.000001 endif
                            
                            " Section: Utility
                            
    1              0.000003 function! s:function(name) abort
                              return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '.*\zs<SNR>\d\+_'),''))
                            endfunction
                            
    1              0.000002 function! s:sub(str,pat,rep) abort
                              return substitute(a:str,'\v\C'.a:pat,a:rep,'')
                            endfunction
                            
    1              0.000002 function! s:gsub(str,pat,rep) abort
                              return substitute(a:str,'\v\C'.a:pat,a:rep,'g')
                            endfunction
                            
    1              0.000001 function! s:Uniq(list) abort
                              let i = 0
                              let seen = {}
                              while i < len(a:list)
                                let str = string(a:list[i])
                                if has_key(seen, str)
                                  call remove(a:list, i)
                                else
                                  let seen[str] = 1
                                  let i += 1
                                endif
                              endwhile
                              return a:list
                            endfunction
                            
    1              0.000001 function! s:winshell() abort
                              return has('win32') && &shellcmdflag !~# '^-'
                            endfunction
                            
    1              0.000002 function! s:WinShellEsc(arg) abort
                              if type(a:arg) == type([])
                                return join(map(copy(a:arg), 's:shellesc(v:val)'))
                              elseif a:arg =~# '^[A-Za-z0-9_/:.-]\+$'
                                return a:arg
                              else
                                return '"' . s:gsub(s:gsub(a:arg, '"', '""'), '\%', '"%"') . '"'
                              endif
                            endfunction
                            
    1              0.000002 function! s:shellesc(arg) abort
                              if type(a:arg) == type([])
                                return join(map(copy(a:arg), 's:shellesc(v:val)'))
                              elseif a:arg =~# '^[A-Za-z0-9_/:.-]\+$'
                                return a:arg
                              elseif s:winshell()
                                return '"' . s:gsub(s:gsub(a:arg, '"', '""'), '\%', '"%"') . '"'
                              else
                                return shellescape(a:arg)
                              endif
                            endfunction
                            
    1              0.000002 let s:fnameescape = " \t\n*?[{`$\\%#'\"|!<"
    1              0.000001 function! s:fnameescape(file) abort
                              if type(a:file) == type([])
                                return join(map(copy(a:file), 's:fnameescape(v:val)'))
                              elseif exists('*fnameescape')
                                return fnameescape(a:file)
                              else
                                return escape(a:file, s:fnameescape)
                              endif
                            endfunction
                            
    1              0.000002 function! s:throw(string) abort
                              throw 'fugitive: '.a:string
                            endfunction
                            
    1              0.000001 function! s:DirCheck(...) abort
                              if !empty(a:0 ? s:Dir(a:1) : s:Dir())
                                return ''
                              elseif empty(bufname(''))
                                return 'return ' . string('echoerr "fugitive: working directory does not belong to a Git repository"')
                              else
                                return 'return ' . string('echoerr "fugitive: file does not belong to a Git repository"')
                              endif
                            endfunction
                            
    1              0.000001 function! s:Mods(mods, ...) abort
                              let mods = substitute(a:mods, '\C<mods>', '', '')
                              let mods = mods =~# '\S$' ? mods . ' ' : mods
                              if a:0 && mods !~# '\<\%(aboveleft\|belowright\|leftabove\|rightbelow\|topleft\|botright\|tab\)\>'
                                let mods = a:1 . ' ' . mods
                              endif
                              return substitute(mods, '\s\+', ' ', 'g')
                            endfunction
                            
    1              0.000002 function! s:Slash(path) abort
                              if exists('+shellslash')
                                return tr(a:path, '\', '/')
                              else
                                return a:path
                              endif
                            endfunction
                            
    1              0.000001 function! s:Resolve(path) abort
                              let path = resolve(a:path)
                              if has('win32')
                                let path = FugitiveVimPath(fnamemodify(fnamemodify(path, ':h'), ':p') . fnamemodify(path, ':t'))
                              endif
                              return path
                            endfunction
                            
    1              0.000002 function! s:FileIgnoreCase(for_completion) abort
                              return (exists('+fileignorecase') && &fileignorecase)
                                    \ || (a:for_completion && exists('+wildignorecase') && &wildignorecase)
                            endfunction
                            
    1              0.000001 function! s:cpath(path, ...) abort
                              if s:FileIgnoreCase(0)
                                let path = FugitiveVimPath(tolower(a:path))
                              else
                                let path = FugitiveVimPath(a:path)
                              endif
                              return a:0 ? path ==# s:cpath(a:1) : path
                            endfunction
                            
    1              0.000002 let s:executables = {}
                            
    1              0.000001 function! s:executable(binary) abort
                              if !has_key(s:executables, a:binary)
                                let s:executables[a:binary] = executable(a:binary)
                              endif
                              return s:executables[a:binary]
                            endfunction
                            
    1              0.000003 if !exists('s:temp_scripts')
    1              0.000002   let s:temp_scripts = {}
    1              0.000001 endif
    1              0.000001 function! s:TempScript(...) abort
                              let body = join(a:000, "\n")
                              if !has_key(s:temp_scripts, body)
                                let temp = tempname() . '.sh'
                                call writefile(['#!/bin/sh'] + a:000, temp)
                                let s:temp_scripts[body] = temp
                              endif
                              return FugitiveGitPath(s:temp_scripts[body])
                            endfunction
                            
    1              0.000018 function! s:DoAutocmd(cmd) abort
                              if v:version >= 704 || (v:version == 703 && has('patch442'))
                                return 'doautocmd <nomodeline>' . a:cmd
                              elseif &modelines > 0
                                return 'try|set modelines=0|doautocmd ' . a:cmd . '|finally|set modelines=' . &modelines . '|endtry'
                              else
                                return 'doautocmd ' . a:cmd
                              endif
                            endfunction
                            
    1              0.000002 let s:nowait = v:version >= 704 ? '<nowait>' : ''
                            
    1              0.000002 function! s:Map(mode, lhs, rhs, ...) abort
                              for mode in split(a:mode, '\zs')
                                let flags = (a:0 ? a:1 : '') . (a:rhs =~# '<Plug>' ? '' : '<script>')
                                let head = a:lhs
                                let tail = ''
                                let keys = get(g:, mode.'remap', {})
                                if type(keys) == type([])
                                  return
                                endif
                                while !empty(head)
                                  if has_key(keys, head)
                                    let head = keys[head]
                                    if empty(head)
                                      return
                                    endif
                                    break
                                  endif
                                  let tail = matchstr(head, '<[^<>]*>$\|.$') . tail
                                  let head = substitute(head, '<[^<>]*>$\|.$', '', '')
                                endwhile
                                if flags !~# '<unique>' || empty(mapcheck(head.tail, mode))
                                  exe mode.'map <buffer>' s:nowait flags head.tail a:rhs
                                  if a:0 > 1
                                    let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') .
                                          \ '|sil! exe "' . mode . 'unmap <buffer> ' . head.tail . '"'
                                  endif
                                endif
                              endfor
                            endfunction
                            
                            " Section: Quickfix
                            
    1              0.000001 function! s:QuickfixGet(nr, ...) abort
                              if a:nr < 0
                                return call('getqflist', a:000)
                              else
                                return call('getloclist', [a:nr] + a:000)
                              endif
                            endfunction
                            
    1              0.000002 function! s:QuickfixSet(nr, ...) abort
                              if a:nr < 0
                                return call('setqflist', a:000)
                              else
                                return call('setloclist', [a:nr] + a:000)
                              endif
                            endfunction
                            
    1              0.000002 function! s:QuickfixCreate(nr, opts) abort
                              if has('patch-7.4.2200')
                                call s:QuickfixSet(a:nr, [], ' ', a:opts)
                              else
                                call s:QuickfixSet(a:nr, [], ' ')
                              endif
                            endfunction
                            
    1              0.000003 function! s:QuickfixStream(nr, event, title, cmd, first, callback, ...) abort
                              let opts = {'title': a:title, 'context': {'items': []}}
                              call s:QuickfixCreate(a:nr, opts)
                              let event = (a:nr < 0 ? 'c' : 'l') . 'fugitive-' . a:event
                              silent exe s:DoAutocmd('QuickFixCmdPre ' . event)
                              let winnr = winnr()
                              exe a:nr < 0 ? 'copen' : 'lopen'
                              if winnr != winnr()
                                wincmd p
                              endif
                            
                              let buffer = []
                              let lines = split(s:SystemError(s:shellesc(a:cmd))[0], "\n")
                              for line in lines
                                call extend(buffer, call(a:callback, a:000 + [line]))
                                if len(buffer) >= 20
                                  let contexts = map(copy(buffer), 'get(v:val, "context", {})')
                                  lockvar contexts
                                  call extend(opts.context.items, contexts)
                                  unlet contexts
                                  call s:QuickfixSet(a:nr, remove(buffer, 0, -1), 'a')
                                  redraw
                                endif
                              endfor
                              call extend(buffer, call(a:callback, a:000 + [0]))
                              call extend(opts.context.items, map(copy(buffer), 'get(v:val, "context", {})'))
                              lockvar opts.context.items
                              call s:QuickfixSet(a:nr, buffer, 'a')
                            
                              silent exe s:DoAutocmd('QuickFixCmdPost ' . event)
                              if a:first && len(s:QuickfixGet(a:nr))
                                call s:BlurStatus()
                                return a:nr < 0 ? 'cfirst' : 'lfirst'
                              else
                                return 'exe'
                              endif
                            endfunction
                            
    1              0.000005 let s:common_efm = ''
                                  \ . '%+Egit:%.%#,'
                                  \ . '%+Eusage:%.%#,'
                                  \ . '%+Eerror:%.%#,'
                                  \ . '%+Efatal:%.%#,'
                                  \ . '%-G%.%#%\e[K%.%#,'
                                  \ . '%-G%.%#%\r%.%\+'
                            
    1              0.000002 function! fugitive#Cwindow() abort
                              if &buftype == 'quickfix'
                                cwindow
                              else
                                botright cwindow
                                if &buftype == 'quickfix'
                                  wincmd p
                                endif
                              endif
                            endfunction
                            
                            " Section: Git
                            
    1              0.000002 function! s:UserCommandList(...) abort
                              let git = split(get(g:, 'fugitive_git_command', g:fugitive_git_executable), '\s\+')
                              let flags = []
                              if a:0 && type(a:1) == type({})
                                let git = copy(get(a:1, 'git', git))
                                let flags = get(a:1, 'flags', flags)
                                let dir = a:1.dir
                              elseif a:0
                                let dir = a:1
                              else
                                let dir = ''
                              endif
                              if len(dir)
                                let tree = s:Tree(dir)
                                if empty(tree)
                                  call add(git, '--git-dir=' . FugitiveGitPath(dir))
                                elseif len(tree) && s:cpath(tree) !=# s:cpath(getcwd())
                                  if fugitive#GitVersion(1, 8, 5)
                                    call extend(git, ['-C', FugitiveGitPath(tree)])
                                  else
                                    throw 'fugitive: Git 1.8.5 or higher required to change directory'
                                  endif
                                endif
                              endif
                              return git + flags
                            endfunction
                            
    1              0.000001 function! s:UserCommand(...) abort
                              return s:shellesc(call('s:UserCommandList', a:0 ? [a:1] : []) + (a:0 ? a:2 : []))
                            endfunction
                            
    1              0.000002 let s:git_versions = {}
    1              0.000002 function! fugitive#GitVersion(...) abort
                              if !has_key(s:git_versions, g:fugitive_git_executable)
                                let s:git_versions[g:fugitive_git_executable] = matchstr(system(g:fugitive_git_executable.' --version'), '\d[^[:space:]]\+')
                              endif
                              if !a:0
                                return s:git_versions[g:fugitive_git_executable]
                              endif
                              let components = split(s:git_versions[g:fugitive_git_executable], '\D\+')
                              if empty(components)
                                return -1
                              endif
                              for i in range(len(a:000))
                                if a:000[i] > +get(components, i)
                                  return 0
                                elseif a:000[i] < +get(components, i)
                                  return 1
                                endif
                              endfor
                              return a:000[i] ==# get(components, i)
                            endfunction
                            
    1              0.000002 let s:commondirs = {}
    1              0.000001 function! fugitive#CommonDir(dir) abort
                              if empty(a:dir)
                                return ''
                              endif
                              if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
                              endif
                              return s:commondirs[a:dir]
                            endfunction
                            
    1              0.000001 function! s:Dir(...) abort
                              return a:0 ? FugitiveGitDir(a:1) : FugitiveGitDir()
                            endfunction
                            
    1              0.000001 function! s:Tree(...) abort
                              return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()
                            endfunction
                            
    1              0.000001 function! s:HasOpt(args, ...) abort
                              let args = a:args[0 : index(a:args, '--')]
                              let opts = copy(a:000)
                              if type(opts[0]) == type([])
                                if empty(args) || index(opts[0], args[0]) == -1
                                  return 0
                                endif
                                call remove(opts, 0)
                              endif
                              for opt in opts
                                if index(args, opt) != -1
                                  return 1
                                endif
                              endfor
                            endfunction
                            
    1              0.000002 function! s:PreparePathArgs(cmd, dir, literal) abort
                              let literal_supported = fugitive#GitVersion(1, 9)
                              if a:literal && literal_supported
                                call insert(a:cmd, '--literal-pathspecs')
                              endif
                              let split = index(a:cmd, '--')
                              for i in range(split < 0 ? len(a:cmd) : split)
                                if type(a:cmd[i]) == type(0)
                                  let a:cmd[i] = fugitive#Path(bufname(a:cmd[i]), './', a:dir)
                                endif
                              endfor
                              if split < 0
                                return a:cmd
                              endif
                              for i in range(split + 1, len(a:cmd) - 1)
                                if type(a:cmd[i]) == type(0)
                                  let a:cmd[i] = fugitive#Path(bufname(a:cmd[i]), './', a:dir)
                                elseif a:literal
                                  let a:cmd[i] = fugitive#Path(a:cmd[i], './', a:dir)
                                elseif !literal_supported
                                  let a:cmd[i] = substitute(a:cmd[i], '^:\%(/\|([^)]*)\)\=:\=', './', '')
                                endif
                              endfor
                              return a:cmd
                            endfunction
                            
    1              0.000005 let s:prepare_env = {
                                  \ 'sequence.editor': 'GIT_SEQUENCE_EDITOR',
                                  \ 'core.editor': 'GIT_EDITOR',
                                  \ 'core.askpass': 'GIT_ASKPASS',
                                  \ }
    1              0.000002 function! fugitive#PrepareDirEnvArgv(...) abort
                              if a:0 && type(a:1) ==# type([])
                                let cmd = a:000[1:-1] + a:1
                              else
                                let cmd = copy(a:000)
                              endif
                              let env = {}
                              let i = 0
                              while i < len(cmd)
                                if cmd[i] =~# '^$\|[\/.]' && cmd[i] !~# '^-'
                                  let dir = remove(cmd, 0)
                                elseif cmd[i] =~# '^--git-dir='
                                  let dir = remove(cmd, 0)[10:-1]
                                elseif type(cmd[i]) ==# type(0)
                                  let dir = s:Dir(remove(cmd, i))
                                elseif cmd[i] ==# '-c' && len(cmd) > i + 1
                                  let key = matchstr(cmd[i+1], '^[^=]*')
                                  if has_key(s:prepare_env, tolower(key)) || key !~# '\.'
                                    let var = get(s:prepare_env, tolower(key), key)
                                    let val = matchstr(cmd[i+1], '=\zs.*')
                                    let env[var] = val
                                  endif
                                  if fugitive#GitVersion(1, 8) && cmd[i+1] =~# '\.'
                                    let i += 2
                                  else
                                    call remove(cmd, i, i + 1)
                                  endif
                                elseif cmd[i] =~# '^--.*pathspecs$'
                                  let explicit_pathspec_option = 1
                                  if fugitive#GitVersion(1, 9)
                                    let i += 1
                                  else
                                    call remove(cmd, i)
                                  endif
                                elseif cmd[i] !~# '^-'
                                  break
                                else
                                  let i += 1
                                endif
                              endwhile
                              if !exists('dir')
                                let dir = s:Dir()
                              endif
                              call s:PreparePathArgs(cmd, dir, !exists('explicit_pathspec_option'))
                              return [dir, env, cmd]
                            endfunction
                            
    1              0.000002 function! s:BuildEnvPrefix(env) abort
                              let pre = ''
                              let env = items(a:env)
                              if empty(env)
                                return ''
                              elseif &shellcmdflag =~# '-Command'
                                return join(map(env, '"$Env:" . v:val[0] . " = ''" . substitute(v:val[1], "''", "''''", "g") . "''; "'), '')
                              elseif s:winshell()
                                return join(map(env, '"set " . substitute(join(v:val, "="), "[&|<>^]", "^^^&", "g") . "& "'), '')
                              else
                                return 'env ' . s:shellesc(map(env, 'join(v:val, "=")')) . ' '
                              endif
                            endfunction
                            
    1              0.000001 function! s:JobOpts(cmd, env) abort
                              if empty(a:env)
                                return [a:cmd, {}]
                              elseif has('patch-8.1.0902') && !has('nvim') && (!has('win32') || empty(filter(keys(a:env), 'exists("$" . v:val)')))
                                return [a:cmd, {'env': a:env}]
                              endif
                              let envlist = map(items(a:env), 'join(v:val, "=")')
                              if !has('win32')
                                return [['env'] + envlist + a:cmd, {}]
                              else
                                let pre = join(map(envlist, '"set " . substitute(v:val, "[&|<>^]", "^^^&", "g") . "& "'), '')
                                if len(a:cmd) == 3 && a:cmd[0] ==# 'cmd.exe' && a:cmd[1] ==# '/c'
                                  return [a:cmd[0:1] + [pre . a:cmd[2]], {}]
                                else
                                  return [['cmd.exe', '/c', pre . s:WinShellEsc(a:cmd)], {}]
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! s:BuildShell(dir, env, args) abort
                              let cmd = copy(a:args)
                              let tree = s:Tree(a:dir)
                              let pre = s:BuildEnvPrefix(a:env)
                              if empty(tree) || index(cmd, '--') == len(cmd) - 1
                                call insert(cmd, '--git-dir=' . FugitiveGitPath(a:dir))
                              elseif fugitive#GitVersion(1, 8, 5)
                                call extend(cmd, ['-C', FugitiveGitPath(tree)], 'keep')
                              else
                                let pre = 'cd ' . s:shellesc(tree) . (s:winshell() ? '& ' : '; ') . pre
                              endif
                              return pre . g:fugitive_git_executable . ' ' . join(map(cmd, 's:shellesc(v:val)'))
                            endfunction
                            
    1              0.000001 function! fugitive#Prepare(...) abort
                              let [dir, env, argv] = call('fugitive#PrepareDirEnvArgv', a:000)
                              return s:BuildShell(dir, env, argv)
                            endfunction
                            
    1              0.000002 function! s:SystemError(cmd, ...) abort
                              try
                                if &shellredir ==# '>' && &shell =~# 'sh\|cmd'
                                  let shellredir = &shellredir
                                  if &shell =~# 'csh'
                                    set shellredir=>&
                                  else
                                    set shellredir=>%s\ 2>&1
                                  endif
                                endif
                                let out = call('system', [type(a:cmd) ==# type([]) ? fugitive#Prepare(a:cmd) : a:cmd] + a:000)
                                return [out, v:shell_error]
                              catch /^Vim\%((\a\+)\)\=:E484:/
                                let opts = ['shell', 'shellcmdflag', 'shellredir', 'shellquote', 'shellxquote', 'shellxescape', 'shellslash']
                                call filter(opts, 'exists("+".v:val) && !empty(eval("&".v:val))')
                                call map(opts, 'v:val."=".eval("&".v:val)')
                                call s:throw('failed to run `' . a:cmd . '` with ' . join(opts, ' '))
                              finally
                                if exists('shellredir')
                                  let &shellredir = shellredir
                                endif
                              endtry
                            endfunction
                            
    1              0.000002 function! s:ChompError(...) abort
                              let [out, exec_error] = s:SystemError(call('fugitive#Prepare', a:000))
                              return [s:sub(out, '\n$', ''), exec_error]
                            endfunction
                            
    1              0.000001 function! s:ChompDefault(default, ...) abort
                              let [out, exec_error] = call('s:ChompError', a:000)
                              return exec_error ? a:default : out
                            endfunction
                            
    1              0.000001 function! s:LinesError(...) abort
                              let [out, exec_error] = call('s:ChompError', a:000)
                              return [len(out) && !exec_error ? split(out, "\n", 1) : [], exec_error]
                            endfunction
                            
    1              0.000002 function! s:NullError(...) abort
                              let [out, exec_error] = s:SystemError(call('fugitive#Prepare', a:000))
                              return [exec_error ? [] : split(out, "\1"), exec_error ? substitute(out, "\n$", "", "") : '', exec_error]
                            endfunction
                            
    1              0.000001 function! s:TreeChomp(...) abort
                              let cmd = call('fugitive#Prepare', a:000)
                              let [out, exec_error] = s:SystemError(cmd)
                              let out = s:sub(out, '\n$', '')
                              if !exec_error
                                return out
                              endif
                              throw 'fugitive: error running `' . cmd . '`: ' . out
                            endfunction
                            
    1              0.000002 function! s:EchoExec(...) abort
                              if s:RunJobs()
                                return 'Git ' . s:fnameescape(a:000)
                              else
                                echo call('s:ChompError', a:000)[0]
                                call fugitive#ReloadStatus(-1, 1)
                                return 'checktime'
                              endif
                            endfunction
                            
    1              0.000002 let s:head_cache = {}
                            
    1              0.000021 function! fugitive#Head(...) abort
                              let dir = a:0 > 1 ? a:2 : s:Dir()
                              if empty(dir)
                                return ''
                              endif
                              let file = fugitive#Find('.git/HEAD', dir)
                              let ftime = getftime(file)
                              if ftime == -1
                                return ''
                              elseif ftime != get(s:head_cache, dir, [-1])[0]
                                let s:head_cache[dir] = [ftime, readfile(file)[0]]
                              endif
                              let head = s:head_cache[dir][1]
                              if head =~# '^ref: '
                                return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40,\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#RevParse(rev, ...) abort
                              let [hash, exec_error] = s:ChompError([a:0 ? a:1 : s:Dir(), 'rev-parse', '--verify', a:rev, '--'])
                              if !exec_error && hash =~# '^\x\{40,\}$'
                                return hash
                              endif
                              throw 'fugitive: rev-parse '.a:rev.': '.hash
                            endfunction
                            
    1              0.000002 function! s:ConfigTimestamps(dir, dict) abort
                              let files = ['/etc/gitconfig', '~/.gitconfig',
                                    \ len($XDG_CONFIG_HOME) ? $XDG_CONFIG_HOME . '/git/config' : '~/.config/git/config']
                              if len(a:dir)
                                call add(files, fugitive#Find('.git/config', a:dir))
                              endif
                              call extend(files, get(a:dict, 'include.path', []))
                              return join(map(files, 'getftime(expand(v:val))'), ',')
                            endfunction
                            
    1              0.000001 let s:config = {}
    1              0.000002 function! fugitive#Config(...) abort
                              let dir = s:Dir()
                              let name = ''
                              if a:0 >= 2 && type(a:2) == type({})
                                let name = substitute(a:1, '^[^.]\+\|[^.]\+$', '\L&', 'g')
                                return len(a:1) ? get(get(a:2, name, []), 0, '') : a:2
                              elseif a:0 >= 2
                                let dir = a:2
                                let name = a:1
                              elseif a:0 == 1 && type(a:1) == type({})
                                return a:1
                              elseif a:0 == 1 && a:1 =~# '^[[:alnum:]-]\+\.'
                                let name = a:1
                              elseif a:0 == 1
                                let dir = a:1
                              endif
                              let name = substitute(name, '^[^.]\+\|[^.]\+$', '\L&', 'g')
                              let key = len(dir) ? dir : '_'
                              if has_key(s:config, key) && s:config[key][0] ==# s:ConfigTimestamps(dir, s:config[key][1])
                                let dict = s:config[key][1]
                              else
                                let dict = {}
                                let [lines, message, exec_error] = s:NullError([dir, 'config', '--list', '-z'])
                                if exec_error
                                  return {}
                                endif
                                for line in lines
                                  let key = matchstr(line, "^[^\n]*")
                                  if !has_key(dict, key)
                                    let dict[key] = []
                                  endif
                                  if len(key) ==# len(line)
                                    call add(dict[key], 1)
                                  else
                                    call add(dict[key], strpart(line, len(key) + 1))
                                  endif
                                endfor
                                let s:config[dir] = [s:ConfigTimestamps(dir, dict), dict]
                                lockvar! dict
                              endif
                              return len(name) ? get(get(dict, name, []), 0, '') : dict
                            endfunction
                            
    1              0.000002 function! s:Remote(dir) abort
                              let head = FugitiveHead(0, a:dir)
                              let remote = len(head) ? fugitive#Config('branch.' . head . '.remote') : ''
                              let i = 10
                              while remote ==# '.' && i > 0
                                let head = matchstr(fugitive#Config('branch.' . head . '.merge'), 'refs/heads/\zs.*')
                                let remote = len(head) ? fugitive#Config('branch.' . head . '.remote') : ''
                                let i -= 1
                              endwhile
                              return remote =~# '^\.\=$' ? 'origin' : remote
                            endfunction
                            
    1              0.000002 function! fugitive#RemoteUrl(...) abort
                              let dir = a:0 > 1 ? a:2 : s:Dir()
                              let remote = !a:0 || a:1 =~# '^\.\=$' ? s:Remote(dir) : a:1
                              if !fugitive#GitVersion(2, 7)
                                return fugitive#Config('remote.' . remote . '.url')
                              endif
                              return s:ChompDefault('', [dir, 'remote', 'get-url', remote, '--'])
                            endfunction
                            
                            " Section: Repository Object
                            
    1              0.000002 function! s:add_methods(namespace, method_names) abort
                              for name in a:method_names
                                let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
                              endfor
                            endfunction
                            
    1              0.000002 let s:repo_prototype = {}
    1              0.000002 let s:repos = {}
                            
    1              0.000002 function! fugitive#repo(...) abort
                              let dir = a:0 ? s:Dir(a:1) : (len(s:Dir()) ? s:Dir() : FugitiveExtractGitDir(expand('%:p')))
                              if dir !=# ''
                                if has_key(s:repos, dir)
                                  let repo = get(s:repos, dir)
                                else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
                                return extend(repo, s:repo_prototype, 'keep')
                              endif
                              call s:throw('not a Git repository')
                            endfunction
                            
    1              0.000001 function! s:repo_dir(...) dict abort
                              return join([self.git_dir]+a:000,'/')
                            endfunction
                            
    1              0.000002 function! s:repo_tree(...) dict abort
                              let dir = s:Tree(self.git_dir)
                              if dir ==# ''
                                call s:throw('no work tree')
                              else
                                return join([dir]+a:000,'/')
                              endif
                            endfunction
                            
    1              0.000002 function! s:repo_bare() dict abort
                              if self.dir() =~# '/\.git$'
                                return 0
                              else
                                return s:Tree(self.git_dir) ==# ''
                              endif
                            endfunction
                            
    1              0.000002 function! s:repo_find(object) dict abort
                              return fugitive#Find(a:object, self.git_dir)
                            endfunction
                            
    1              0.000002 function! s:repo_translate(rev) dict abort
                              return s:Slash(fugitive#Find(substitute(a:rev, '^/', ':(top)', ''), self.git_dir))
                            endfunction
                            
    1              0.000001 function! s:repo_head(...) dict abort
                              return fugitive#Head(a:0 ? a:1 : 0, self.git_dir)
                            endfunction
                            
    1   0.000202   0.000014 call s:add_methods('repo',['dir','tree','bare','find','translate','head'])
                            
    1              0.000002 function! s:repo_prepare(...) dict abort
                              return call('fugitive#Prepare', [self.git_dir] + a:000)
                            endfunction
                            
    1              0.000002 function! s:repo_git_command(...) dict abort
                              let git = g:fugitive_git_executable . ' --git-dir='.s:shellesc(self.git_dir)
                              return git.join(map(copy(a:000),'" ".s:shellesc(v:val)'),'')
                            endfunction
                            
    1              0.000002 function! s:repo_git_chomp(...) dict abort
                              return s:sub(system(FugitivePrepare(a:000, self.git_dir)), '\n$', '')
                            endfunction
                            
    1              0.000001 function! s:repo_git_chomp_in_tree(...) dict abort
                              return call(self.git_chomp, a:000, self)
                            endfunction
                            
    1              0.000002 function! s:repo_rev_parse(rev) dict abort
                              return fugitive#RevParse(a:rev, self.git_dir)
                            endfunction
                            
    1   0.000154   0.000013 call s:add_methods('repo',['prepare','git_command','git_chomp','git_chomp_in_tree','rev_parse'])
                            
    1              0.000002 function! s:repo_superglob(base) dict abort
                              return map(fugitive#CompleteObject(a:base, self.git_dir), 'substitute(v:val, ''\\\(.\)'', ''\1'', "g")')
                            endfunction
                            
    1   0.000037   0.000006 call s:add_methods('repo',['superglob'])
                            
    1              0.000002 function! s:repo_config(name) dict abort
                              return fugitive#Config(a:name, self.git_dir)
                            endfunction
                            
    1              0.000002 function! s:repo_user() dict abort
                              let username = self.config('user.name')
                              let useremail = self.config('user.email')
                              return username.' <'.useremail.'>'
                            endfunction
                            
    1   0.000068   0.000006 call s:add_methods('repo',['config', 'user'])
                            
                            " Section: File API
                            
    1              0.000002 function! s:DirCommitFile(path) abort
                              let vals = matchlist(s:Slash(a:path), '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40,\}\|[0-3]\)\(/.*\)\=$')
                              if empty(vals)
                                return ['', '', '']
                              endif
                              return vals[1:3]
                            endfunction
                            
    1              0.000002 function! s:DirRev(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              return [dir, (commit =~# '^.$' ? ':' : '') . commit . substitute(file, '^/', ':', '')]
                            endfunction
                            
    1              0.000003 let s:merge_heads = ['MERGE_HEAD', 'REBASE_HEAD', 'CHERRY_PICK_HEAD', 'REVERT_HEAD']
    1              0.000001 function! s:MergeHead(...) abort
                              let dir = fugitive#Find('.git/', a:0 ? a:1 : s:Dir())
                              for head in s:merge_heads
                                if filereadable(dir . head)
                                  return head
                                endif
                              endfor
                              return ''
                            endfunction
                            
    1              0.000002 function! s:Owner(path, ...) abort
                              let dir = a:0 ? a:1 : s:Dir()
                              if empty(dir)
                                return ''
                              endif
                              let actualdir = fugitive#Find('.git/', dir)
                              let [pdir, commit, file] = s:DirCommitFile(a:path)
                              if s:cpath(dir, pdir)
                                if commit =~# '^\x\{40,\}$'
                                  return commit
                                elseif commit ==# '2'
                                  return 'HEAD^{}'
                                elseif commit ==# '0'
                                  return ''
                                endif
                                let merge_head = s:MergeHead()
                                if empty(merge_head)
                                  return ''
                                endif
                                if commit ==# '3'
                                  return merge_head . '^{}'
                                elseif commit ==# '1'
                                  return s:TreeChomp('merge-base', 'HEAD', merge_head, '--')
                                endif
                              endif
                              let path = fnamemodify(a:path, ':p')
                              if s:cpath(actualdir, strpart(path, 0, len(actualdir))) && a:path =~# 'HEAD$'
                                return strpart(path, len(actualdir))
                              endif
                              let refs = fugitive#Find('.git/refs', dir)
                              if s:cpath(refs . '/', path[0 : len(refs)]) && path !~# '[\/]$'
                                return strpart(path, len(refs) - 4)
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 function! fugitive#Real(url) abort
                              if empty(a:url)
                                return ''
                              endif
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if len(dir)
                                let tree = s:Tree(dir)
                                return FugitiveVimPath((len(tree) ? tree : dir) . file)
                              endif
                              let pre = substitute(matchstr(a:url, '^\a\a\+\ze:'), '^.', '\u&', '')
                              if len(pre) && pre !=? 'fugitive' && exists('*' . pre . 'Real')
                                let url = {pre}Real(a:url)
                              else
                                let url = fnamemodify(a:url, ':p' . (a:url =~# '[\/]$' ? '' : ':s?[\/]$??'))
                              endif
                              return FugitiveVimPath(empty(url) ? a:url : url)
                            endfunction
                            
    1              0.000002 function! fugitive#Path(url, ...) abort
                              if empty(a:url)
                                return ''
                              endif
                              let dir = a:0 > 1 ? a:2 : s:Dir()
                              let tree = s:Tree(dir)
                              if !a:0
                                return fugitive#Real(a:url)
                              elseif a:1 =~# '\.$'
                                let path = s:Slash(fugitive#Real(a:url))
                                let cwd = getcwd()
                                let lead = ''
                                while s:cpath(tree . '/', (cwd . '/')[0 : len(tree)])
                                  if s:cpath(cwd . '/', path[0 : len(cwd)])
                                    if strpart(path, len(cwd) + 1) =~# '^\.git\%(/\|$\)'
                                      break
                                    endif
                                    return a:1[0:-2] . (empty(lead) ? './' : lead) . strpart(path, len(cwd) + 1)
                                  endif
                                  let cwd = fnamemodify(cwd, ':h')
                                  let lead .= '../'
                                endwhile
                                return a:1[0:-2] . path
                              endif
                              let url = a:url
                              let temp_state = s:TempState(url)
                              if has_key(temp_state, 'bufnr')
                                let url = bufname(temp_state.bufnr)
                              endif
                              let url = s:Slash(fnamemodify(url, ':p'))
                              if url =~# '/$' && s:Slash(a:url) !~# '/$'
                                let url = url[0:-2]
                              endif
                              let [argdir, commit, file] = s:DirCommitFile(a:url)
                              if len(argdir) && s:cpath(argdir) !=# s:cpath(dir)
                                let file = ''
                              elseif len(dir) && s:cpath(url[0 : len(dir)]) ==# s:cpath(dir . '/')
                                let file = '/.git'.url[strlen(dir) : -1]
                              elseif len(tree) && s:cpath(url[0 : len(tree)]) ==# s:cpath(tree . '/')
                                let file = url[len(tree) : -1]
                              elseif s:cpath(url) ==# s:cpath(tree)
                                let file = '/'
                              endif
                              if empty(file) && a:1 =~# '^$\|^[.:]/$'
                                return FugitiveGitPath(fugitive#Real(a:url))
                              endif
                              return substitute(file, '^/', a:1, '')
                            endfunction
                            
    1              0.000001 function! s:Relative(...) abort
                              return fugitive#Path(@%, a:0 ? a:1 : ':(top)', a:0 > 1 ? a:2 : s:Dir())
                            endfunction
                            
    1              0.000001 function! fugitive#Find(object, ...) abort
                              if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
                              elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
                              elseif s:Slash(a:object) =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
                              elseif s:Slash(a:object) =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
                              endif
                              let dir = a:0 ? a:1 : s:Dir()
                              if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*', '', '')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return fnamemodify(FugitiveVimPath(len(file) ? file : a:object), ':p')
                                endif
                              endif
                              let rev = s:Slash(a:object)
                              let tree = s:Tree(dir)
                              let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
                              if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
                              elseif rev =~# '^\.git/'
                                let f = substitute(rev, '^\.git', '', '')
                                let cdir = fugitive#CommonDir(dir)
                                if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
                                elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
                                elseif cdir !=# dir && (
                                      \ f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' ||
                                      \ f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' &&
                                      \ getftime(FugitiveVimPath(dir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
                                else
                                  let f = simplify(dir . f)
                                endif
                              elseif rev ==# ':/'
                                let f = base
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                else
                                  let f = fugitive#Find('.git/index', dir)
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\|^:.*'), '^@\%($\|[~^]\|@{\)\@=', 'HEAD', '')
                                  let file = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) || v:val ==# "@" ? "HEAD" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit . (len(file) ? '^{}' : ''), '--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
                              endif
                              return FugitiveVimPath(f)
                            endfunction
                            
    1              0.000002 function! s:Generate(rev, ...) abort
                              return fugitive#Find(a:rev, a:0 ? a:1 : s:Dir())
                            endfunction
                            
    1              0.000002 function! s:DotRelative(path, ...) abort
                              let cwd = a:0 ? a:1 : getcwd()
                              let path = substitute(a:path, '^[~$]\i*', '\=expand(submatch(0))', '')
                              if len(cwd) && s:cpath(cwd . '/', (path . '/')[0 : len(cwd)])
                                return '.' . strpart(path, len(cwd))
                              endif
                              return a:path
                            endfunction
                            
    1              0.000001 function! fugitive#Object(...) abort
                              let dir = a:0 > 1 ? a:2 : s:Dir()
                              let [fdir, rev] = s:DirRev(a:0 ? a:1 : @%)
                              if s:cpath(dir) !=# s:cpath(fdir)
                                let rev = ''
                              endif
                              let tree = s:Tree(dir)
                              let full = a:0 ? a:1 : @%
                              let full = fnamemodify(full, ':p' . (s:Slash(full) =~# '/$' ? '' : ':s?/$??'))
                              if empty(rev) && empty(tree)
                                return FugitiveGitPath(full)
                              elseif empty(rev)
                                let rev = fugitive#Path(full, './', dir)
                                if rev =~# '^\./.git\%(/\|$\)'
                                  return FugitiveGitPath(full)
                                endif
                              endif
                              if rev !~# '^\.\%(/\|$\)' || s:cpath(getcwd(), tree)
                                return rev
                              else
                                return FugitiveGitPath(tree . rev[1:-1])
                              endif
                            endfunction
                            
    1              0.000002 let s:var = '\%(%\|#<\=\d\+\|##\=\)'
    1              0.000003 let s:flag = '\%(:[p8~.htre]\|:g\=s\(.\).\{-\}\1.\{-\}\1\)'
    1              0.000004 let s:expand = '\%(\(' . s:var . '\)\(' . s:flag . '*\)\(:S\)\=\)'
                            
    1              0.000002 function! s:BufName(var) abort
                              if a:var ==# '%'
                                return bufname(get(s:TempState(), 'bufnr', ''))
                              elseif a:var =~# '^#\d*$'
                                let nr = get(s:TempState(bufname(+a:var[1:-1])), 'bufnr', '')
                                return bufname(nr ? nr : +a:var[1:-1])
                              else
                                return expand(a:var)
                              endif
                            endfunction
                            
    1              0.000003 function! s:ExpandVarLegacy(str) abort
                              if get(g:, 'fugitive_legacy_quoting', 1)
                                return substitute(a:str, '\\\ze[%#!]', '', 'g')
                              else
                                return a:str
                              endif
                            endfunction
                            
    1              0.000003 function! s:ExpandVar(other, var, flags, esc, ...) abort
                              let cwd = a:0 ? a:1 : getcwd()
                              if a:other =~# '^\'
                                return a:other[1:-1]
                              elseif a:other =~# '^'''
                                return s:ExpandVarLegacy(substitute(a:other[1:-2], "''", "'", "g"))
                              elseif a:other =~# '^"'
                                return s:ExpandVarLegacy(substitute(a:other[1:-2], '""', '"', "g"))
                              elseif a:other =~# '^!'
                                let buffer = s:BufName(len(a:other) > 1 ? '#'. a:other[1:-1] : '%')
                                let owner = s:Owner(buffer)
                                return len(owner) ? owner : '@'
                              endif
                              let flags = a:flags
                              let file = s:DotRelative(fugitive#Real(s:BufName(a:var)), cwd)
                              while len(flags)
                                let flag = matchstr(flags, s:flag)
                                let flags = strpart(flags, len(flag))
                                if flag ==# ':.'
                                  let file = s:DotRelative(file, cwd)
                                else
                                  let file = fnamemodify(file, flag)
                                endif
                              endwhile
                              let file = s:Slash(file)
                              return (len(a:esc) ? shellescape(file) : file)
                            endfunction
                            
    1              0.000002 function! s:Expand(rev, ...) abort
                              if a:rev =~# '^:[0-3]$'
                                let file = len(expand('%')) ? a:rev . ':%' : '%'
                              elseif a:rev ==# '>'
                                let file = '%'
                              elseif a:rev =~# '^>[~^]'
                                let file = len(expand('%')) ? '!' . a:rev[1:-1] . ':%' : '%'
                              elseif a:rev =~# '^>[> ]\@!'
                                let file = len(expand('%')) ? a:rev[1:-1] . ':%' : '%'
                              else
                                let file = a:rev
                              endif
                              return substitute(file,
                                    \ '\(\\[' . s:fnameescape . ']\|^\\[>+-]\|!\d*\)\|' . s:expand,
                                    \ '\=s:ExpandVar(submatch(1),submatch(2),submatch(3),"", a:0 ? a:1 : getcwd())', 'g')
                            endfunction
                            
    1              0.000002 function! fugitive#Expand(object) abort
                              return substitute(a:object,
                                    \ '\(\\[' . s:fnameescape . ']\|^\\[>+-]\|!\d*\)\|' . s:expand,
                                    \ '\=s:ExpandVar(submatch(1),submatch(2),submatch(3),submatch(5))', 'g')
                            endfunction
                            
    1              0.000002 function! s:ExpandSplit(string, ...) abort
                              let list = []
                              let string = a:string
                              let handle_bar = a:0 && a:1
                              let dquote = handle_bar ? '"\%([^"]\|""\|\\"\)*"\|' : ''
                              let cwd = a:0 > 1 ? a:2 : getcwd()
                              while string =~# '\S'
                                if handle_bar && string =~# '^\s*|'
                                  return [list, substitute(string, '^\s*', '', '')]
                                endif
                                let arg = matchstr(string, '^\s*\%(' . dquote . '''[^'']*''\|\\.\|[^[:space:] ' . (handle_bar ? '|' : '') . ']\)\+')
                                let string = strpart(string, len(arg))
                                let arg = substitute(arg, '^\s\+', '', '')
                                if !exists('seen_separator')
                                  let arg = substitute(arg, '^\%([^:.][^:]*:\|^:\|^:[0-3]:\)\=\zs\.\.\=\%(/.*\)\=$',
                                        \ '\=s:DotRelative(s:Slash(simplify(getcwd() . "/" . submatch(0))), cwd)', '')
                                endif
                                let arg = substitute(arg,
                                      \ '\(' . dquote . '''\%(''''\|[^'']\)*''\|\\[' . s:fnameescape . ']\|^\\[>+-]\|!\d*\)\|' . s:expand,
                                      \ '\=s:ExpandVar(submatch(1),submatch(2),submatch(3),submatch(5), cwd)', 'g')
                                call add(list, arg)
                                if arg ==# '--'
                                  let seen_separator = 1
                                endif
                              endwhile
                              return handle_bar ? [list, ''] : list
                            endfunction
                            
    1              0.000002 function! s:SplitExpand(string, ...) abort
                              return s:ExpandSplit(a:string, 0, a:0 ? a:1 : getcwd())
                            endfunction
                            
    1              0.000002 function! s:SplitExpandChain(string, ...) abort
                              return s:ExpandSplit(a:string, 1, a:0 ? a:1 : getcwd())
                            endfunction
                            
    1              0.000002 let s:trees = {}
    1              0.000002 let s:indexes = {}
    1              0.000002 function! s:TreeInfo(dir, commit) abort
                              if a:commit =~# '^:\=[0-3]$'
                                let index = get(s:indexes, a:dir, [])
                                let newftime = getftime(fugitive#Find('.git/index', a:dir))
                                if get(index, 0, -1) < newftime
                                  let [lines, exec_error] = s:LinesError([a:dir, 'ls-files', '--stage', '--'])
                                  let s:indexes[a:dir] = [newftime, {'0': {}, '1': {}, '2': {}, '3': {}}]
                                  if exec_error
                                    return [{}, -1]
                                  endif
                                  for line in lines
                                    let [info, filename] = split(line, "\t")
                                    let [mode, sha, stage] = split(info, '\s\+')
                                    let s:indexes[a:dir][1][stage][filename] = [newftime, mode, 'blob', sha, -2]
                                    while filename =~# '/'
                                      let filename = substitute(filename, '/[^/]*$', '', '')
                                      let s:indexes[a:dir][1][stage][filename] = [newftime, '040000', 'tree', '', 0]
                                    endwhile
                                  endfor
                                endif
                                return [get(s:indexes[a:dir][1], a:commit[-1:-1], {}), newftime]
                              elseif a:commit =~# '^\x\{40,\}$'
                                if !has_key(s:trees, a:dir)
                                  let s:trees[a:dir] = {}
                                endif
                                if !has_key(s:trees[a:dir], a:commit)
                                  let [ftime, exec_error] = s:ChompError([a:dir, 'log', '-1', '--pretty=format:%ct', a:commit, '--'])
                                  if exec_error
                                    let s:trees[a:dir][a:commit] = [{}, -1]
                                    return s:trees[a:dir][a:commit]
                                  endif
                                  let s:trees[a:dir][a:commit] = [{}, +ftime]
                                  let [lines, exec_error] = s:LinesError([a:dir, 'ls-tree', '-rtl', '--full-name', a:commit, '--'])
                                  if exec_error
                                    return s:trees[a:dir][a:commit]
                                  endif
                                  for line in lines
                                    let [info, filename] = split(line, "\t")
                                    let [mode, type, sha, size] = split(info, '\s\+')
                                    let s:trees[a:dir][a:commit][0][filename] = [+ftime, mode, type, sha, +size, filename]
                                  endfor
                                endif
                                return s:trees[a:dir][a:commit]
                              endif
                              return [{}, -1]
                            endfunction
                            
    1              0.000002 function! s:PathInfo(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if empty(dir) || !get(g:, 'fugitive_file_api', 1)
                                return [-1, '000000', '', '', -1]
                              endif
                              let path = substitute(file[1:-1], '/*$', '', '')
                              let [tree, ftime] = s:TreeInfo(dir, commit)
                              let entry = empty(path) ? [ftime, '040000', 'tree', '', -1] : get(tree, path, [])
                              if empty(entry) || file =~# '/$' && entry[2] !=# 'tree'
                                return [-1, '000000', '', '', -1]
                              else
                                return entry
                              endif
                            endfunction
                            
    1              0.000002 function! fugitive#simplify(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if empty(dir)
                                return ''
                              endif
                              if file =~# '/\.\.\%(/\|$\)'
                                let tree = s:Tree(dir)
                                if len(tree)
                                  let path = simplify(tree . file)
                                  if strpart(path . '/', 0, len(tree) + 1) !=# tree . '/'
                                    return FugitiveVimPath(path)
                                  endif
                                endif
                              endif
                              return FugitiveVimPath('fugitive://' . simplify(dir) . '//' . commit . simplify(file))
                            endfunction
                            
    1              0.000002 function! fugitive#resolve(url) abort
                              let url = fugitive#simplify(a:url)
                              if url =~? '^fugitive:'
                                return url
                              else
                                return resolve(url)
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#getftime(url) abort
                              return s:PathInfo(a:url)[0]
                            endfunction
                            
    1              0.000001 function! fugitive#getfsize(url) abort
                              let entry = s:PathInfo(a:url)
                              if entry[4] == -2 && entry[2] ==# 'blob' && len(entry[3])
                                let dir = s:DirCommitFile(a:url)[0]
                                let entry[4] = +s:ChompDefault(-1, [dir, 'cat-file', '-s', entry[3]])
                              endif
                              return entry[4]
                            endfunction
                            
    1              0.000001 function! fugitive#getftype(url) abort
                              return get({'tree': 'dir', 'blob': 'file'}, s:PathInfo(a:url)[2], '')
                            endfunction
                            
    1              0.000002 function! fugitive#filereadable(url) abort
                              return s:PathInfo(a:url)[2] ==# 'blob'
                            endfunction
                            
    1              0.000002 function! fugitive#filewritable(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if commit !~# '^\d$' || !filewritable(fugitive#Find('.git/index', dir))
                                return 0
                              endif
                              return s:PathInfo(a:url)[2] ==# 'blob' ? 1 : 2
                            endfunction
                            
    1              0.000002 function! fugitive#isdirectory(url) abort
                              return s:PathInfo(a:url)[2] ==# 'tree'
                            endfunction
                            
    1              0.000002 function! fugitive#getfperm(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              let perm = getfperm(dir)
                              let fperm = s:PathInfo(a:url)[1]
                              if fperm ==# '040000'
                                let fperm = '000755'
                              endif
                              if fperm !~# '[15]'
                                let perm = tr(perm, 'x', '-')
                              endif
                              if fperm !~# '[45]$'
                                let perm = tr(perm, 'rw', '--')
                              endif
                              if commit !~# '^\d$'
                                let perm = tr(perm, 'w', '-')
                              endif
                              return perm ==# '---------' ? '' : perm
                            endfunction
                            
    1              0.000002 function! fugitive#setfperm(url, perm) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              let entry = s:PathInfo(a:url)
                              let perm = fugitive#getfperm(a:url)
                              if commit !~# '^\d$' || entry[2] !=# 'blob' ||
                                  \ substitute(perm, 'x', '-', 'g') !=# substitute(a:perm, 'x', '-', 'g')
                                return -2
                              endif
                              let exec_error = s:SystemError([dir, 'update-index', '--index-info'],
                                    \ (a:perm =~# 'x' ? '000755 ' : '000644 ') . entry[3] . ' ' . commit . "\t" . file[1:-1])[1]
                              return exec_error ? -1 : 0
                            endfunction
                            
    1              0.000002 function! s:TempCmd(out, cmd) abort
                              try
                                let cmd = (type(a:cmd) == type([]) ? fugitive#Prepare(a:cmd) : a:cmd)
                                let redir = ' > ' . a:out
                                if (s:winshell() || &shellcmdflag ==# '-Command') && !has('nvim')
                                  let cmd_escape_char = &shellxquote == '(' ?  '^' : '^^^'
                                  return s:SystemError('cmd /c "' . s:gsub(cmd, '[<>%]', cmd_escape_char . '&') . redir . '"')
                                elseif &shell =~# 'fish'
                                  return s:SystemError(' begin;' . cmd . redir . ';end ')
                                else
                                  return s:SystemError(' (' . cmd . redir . ') ')
                                endif
                              endtry
                            endfunction
                            
    1              0.000004 if !exists('s:blobdirs')
    1              0.000002   let s:blobdirs = {}
    1              0.000001 endif
    1              0.000002 function! s:BlobTemp(url) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if empty(file)
                                return ''
                              endif
                              if !has_key(s:blobdirs, dir)
                                let s:blobdirs[dir] = tempname()
                              endif
                              let tempfile = s:blobdirs[dir] . '/' . commit . file
                              let tempparent = fnamemodify(tempfile, ':h')
                              if !isdirectory(tempparent)
                                call mkdir(tempparent, 'p')
                              endif
                              if commit =~# '^\d$' || !filereadable(tempfile)
                                let rev = s:DirRev(a:url)[1]
                                let exec_error = s:TempCmd(tempfile, [dir, 'cat-file', 'blob', rev])[1]
                                if exec_error
                                  call delete(tempfile)
                                  return ''
                                endif
                              endif
                              return s:Resolve(tempfile)
                            endfunction
                            
    1              0.000001 function! fugitive#readfile(url, ...) abort
                              let entry = s:PathInfo(a:url)
                              if entry[2] !=# 'blob'
                                return []
                              endif
                              let temp = s:BlobTemp(a:url)
                              if empty(temp)
                                return []
                              endif
                              return call('readfile', [temp] + a:000)
                            endfunction
                            
    1              0.000002 function! fugitive#writefile(lines, url, ...) abort
                              let url = type(a:url) ==# type('') ? a:url : ''
                              let [dir, commit, file] = s:DirCommitFile(url)
                              let entry = s:PathInfo(url)
                              if commit =~# '^\d$' && entry[2] !=# 'tree'
                                let temp = tempname()
                                if a:0 && a:1 =~# 'a' && entry[2] ==# 'blob'
                                  call writefile(fugitive#readfile(url, 'b'), temp, 'b')
                                endif
                                call call('writefile', [a:lines, temp] + a:000)
                                let [hash, exec_error] = s:ChompError([dir, 'hash-object', '-w', temp])
                                let mode = len(entry[1]) ? entry[1] : '100644'
                                if !exec_error && hash =~# '^\x\{40,\}$'
                                  let exec_error = s:SystemError([dir, 'update-index', '--index-info'],
                                        \ mode . ' ' . hash . ' ' . commit . "\t" . file[1:-1])[1]
                                  if !exec_error
                                    return 0
                                  endif
                                endif
                              endif
                              return call('writefile', [a:lines, a:url] + a:000)
                            endfunction
                            
    1              0.000006 let s:globsubs = {
                                  \ '/**/': '/\%([^./][^/]*/\)*',
                                  \ '/**': '/\%([^./][^/]\+/\)*[^./][^/]*',
                                  \ '**/': '[^/]*\%(/[^./][^/]*\)*',
                                  \ '**': '.*',
                                  \ '/*': '/[^/.][^/]*',
                                  \ '*': '[^/]*',
                                  \ '?': '[^/]'}
    1              0.000002 function! fugitive#glob(url, ...) abort
                              let [dirglob, commit, glob] = s:DirCommitFile(a:url)
                              let append = matchstr(glob, '/*$')
                              let glob = substitute(glob, '/*$', '', '')
                              let pattern = '^' . substitute(glob, '/\=\*\*/\=\|/\=\*\|[.?\$]\|^^', '\=get(s:globsubs, submatch(0), "\\" . submatch(0))', 'g')[1:-1] . '$'
                              let results = []
                              for dir in dirglob =~# '[*?]' ? split(glob(dirglob), "\n") : [dirglob]
                                if empty(dir) || !get(g:, 'fugitive_file_api', 1) || !filereadable(fugitive#Find('.git/HEAD', dir))
                                  continue
                                endif
                                let files = items(s:TreeInfo(dir, commit)[0])
                                if len(append)
                                  call filter(files, 'v:val[1][2] ==# "tree"')
                                endif
                                call map(files, 'v:val[0]')
                                call filter(files, 'v:val =~# pattern')
                                let prepend = 'fugitive://' . dir . '//' . substitute(commit, '^:', '', '') . '/'
                                call sort(files)
                                call map(files, 'FugitiveVimPath(prepend . v:val . append)')
                                call extend(results, files)
                              endfor
                              if a:0 > 1 && a:2
                                return results
                              else
                                return join(results, "\n")
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#delete(url, ...) abort
                              let [dir, commit, file] = s:DirCommitFile(a:url)
                              if a:0 && len(a:1) || commit !~# '^\d$'
                                return -1
                              endif
                              let entry = s:PathInfo(a:url)
                              if entry[2] !=# 'blob'
                                return -1
                              endif
                              let exec_error = s:SystemError([dir, 'update-index', '--index-info'],
                                    \ '000000 0000000000000000000000000000000000000000 ' . commit . "\t" . file[1:-1])[1]
                              return exec_error ? -1 : 0
                            endfunction
                            
                            " Section: Buffer Object
                            
    1              0.000002 let s:buffer_prototype = {}
                            
    1              0.000001 function! fugitive#buffer(...) abort
                              let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
                              call extend(buffer, s:buffer_prototype, 'keep')
                              return buffer
                            endfunction
                            
    1              0.000002 function! s:buffer_repo() dict abort
                              return fugitive#repo(self['#'])
                            endfunction
                            
    1              0.000002 function! s:buffer_type(...) dict abort
                              return 'see b:fugitive_type'
                            endfunction
                            
    1   0.000086   0.000011 call s:add_methods('buffer', ['repo', 'type'])
                            
                            " Section: Completion
                            
    1              0.000002 function! s:FilterEscape(items, ...) abort
                              let items = copy(a:items)
                              call map(items, 's:fnameescape(v:val)')
                              if a:0 && type(a:1) == type('')
                                let cmp = s:FileIgnoreCase(1) ? '==?' : '==#'
                                call filter(items, 'strpart(v:val, 0, strlen(a:1)) ' . cmp . ' a:1')
                              endif
                              return items
                            endfunction
                            
    1              0.000002 function! s:GlobComplete(lead, pattern) abort
                              if a:lead ==# '/'
                                return []
                              elseif v:version >= 704
                                let results = glob(a:lead . a:pattern, 0, 1)
                              else
                                let results = split(glob(a:lead . a:pattern), "\n")
                              endif
                              call map(results, 'v:val !~# "/$" && isdirectory(v:val) ? v:val."/" : v:val')
                              call map(results, 'v:val[ strlen(a:lead) : -1 ]')
                              return results
                            endfunction
                            
    1              0.000001 function! fugitive#CompletePath(base, ...) abort
                              let dir = a:0 == 1 ? a:1 : a:0 == 3 ? a:3 : s:Dir()
                              let tree = s:Tree(dir) . '/'
                              let strip = '^\%(:/:\=\|:(top)\|:(top,literal)\|:(literal,top)\|:(literal)\)'
                              let base = substitute(a:base, strip, '', '')
                              if base =~# '^\.git/'
                                let pattern = s:gsub(base[5:-1], '/', '*&').'*'
                                let matches = s:GlobComplete(dir . '/', pattern)
                                let cdir = fugitive#CommonDir(dir)
                                if len(cdir) && s:cpath(dir) !=# s:cpath(cdir)
                                  call extend(matches, s:GlobComplete(cdir . '/', pattern))
                                endif
                                call s:Uniq(matches)
                                call map(matches, "'.git/' . v:val")
                              elseif base =~# '^\~/'
                                let matches = map(s:GlobComplete(expand('~/'), base[2:-1] . '*'), '"~/" . v:val')
                              elseif a:base =~# '^/\|^\a\+:\|^\.\.\=/\|^:(literal)'
                                let matches = s:GlobComplete('', base . '*')
                              elseif len(tree) > 1
                                let matches = s:GlobComplete(tree, s:gsub(base, '/', '*&').'*')
                              else
                                let matches = []
                              endif
                              call map(matches, 's:fnameescape(s:Slash(matchstr(a:base, strip) . v:val))')
                              return matches
                            endfunction
                            
    1              0.000001 function! fugitive#PathComplete(...) abort
                              return call('fugitive#CompletePath', a:000)
                            endfunction
                            
    1              0.000002 function! s:CompleteHeads(dir) abort
                              let dir = fugitive#Find('.git/', a:dir)
                              return sort(filter(['HEAD', 'FETCH_HEAD', 'ORIG_HEAD'] + s:merge_heads, 'filereadable(dir . v:val)')) +
                                    \ sort(s:LinesError('rev-parse', '--symbolic', '--branches', '--tags', '--remotes')[0])
                            endfunction
                            
    1              0.000001 function! fugitive#CompleteObject(base, ...) abort
                              let dir = a:0 == 1 ? a:1 : a:0 == 3 ? a:3 : s:Dir()
                              let cwd = getcwd()
                              let tree = s:Tree(dir) . '/'
                              let subdir = ''
                              if len(tree) > 1 && s:cpath(tree, cwd[0 : len(tree) - 1])
                                let subdir = strpart(cwd, len(tree)) . '/'
                              endif
                            
                              if a:base =~# '^\.\=/\|^:(' || a:base !~# ':'
                                let results = []
                                if a:base =~# '^refs/'
                                  let results += map(s:GlobComplete(fugitive#CommonDir(dir) . '/', a:base . '*'), 's:Slash(v:val)')
                                  call map(results, 's:fnameescape(v:val)')
                                elseif a:base !~# '^\.\=/\|^:('
                                  let heads = s:CompleteHeads(dir)
                                  if filereadable(fugitive#Find('.git/refs/stash', dir))
                                    let heads += ["stash"]
                                    let heads += sort(s:LinesError(["stash","list","--pretty=format:%gd"], dir)[0])
                                  endif
                                  let results += s:FilterEscape(heads, a:base)
                                endif
                                if !empty(tree)
                                  let results += a:0 == 1 ? fugitive#CompletePath(a:base, dir) : fugitive#CompletePath(a:base)
                                endif
                                return results
                            
                              elseif a:base =~# '^:'
                                let entries = s:LinesError(['ls-files','--stage'], dir)[0]
                                if a:base =~# ':\./'
                                  call map(entries, 'substitute(v:val, "\\M\t\\zs" . subdir, "./", "")')
                                endif
                                call map(entries,'s:sub(v:val,".*(\\d)\\t(.*)",":\\1:\\2")')
                                if a:base !~# '^:[0-3]\%(:\|$\)'
                                  call filter(entries,'v:val[1] == "0"')
                                  call map(entries,'v:val[2:-1]')
                                endif
                            
                              else
                                let tree = matchstr(a:base, '.*[:/]')
                                let entries = s:LinesError(['ls-tree', substitute(tree,  ':\zs\./', '\=subdir', '')], dir)[0]
                                call map(entries,'s:sub(v:val,"^04.*\\zs$","/")')
                                call map(entries,'tree.s:sub(v:val,".*\t","")')
                            
                              endif
                              return s:FilterEscape(entries, a:base)
                            endfunction
                            
    1              0.000003 function! s:CompleteSub(subcommand, A, L, P, ...) abort
                              let pre = strpart(a:L, 0, a:P)
                              if pre =~# ' -- '
                                return fugitive#CompletePath(a:A)
                              elseif a:A =~# '^-' || a:A is# 0
                                return s:FilterEscape(split(s:ChompDefault('', a:subcommand, '--git-completion-helper'), ' '), a:A)
                              elseif !a:0
                                return fugitive#CompleteObject(a:A, s:Dir())
                              elseif type(a:1) == type(function('tr'))
                                return call(a:1, [a:A, a:L, a:P])
                              else
                                return s:FilterEscape(a:1, a:A)
                              endif
                            endfunction
                            
    1              0.000002 function! s:CompleteRevision(A, L, P, ...) abort
                              return s:FilterEscape(s:CompleteHeads(s:Dir()), a:A)
                            endfunction
                            
    1              0.000002 function! s:CompleteRemote(A, L, P) abort
                              let remote = matchstr(a:L, '\u\w*[! ] *\zs\S\+\ze ')
                              if !empty(remote)
                                let matches = s:LinesError('ls-remote', remote)[0]
                                call filter(matches, 'v:val =~# "\t" && v:val !~# "{"')
                                call map(matches, 's:sub(v:val, "^.*\t%(refs/%(heads/|tags/)=)=", "")')
                              else
                                let matches = s:LinesError('remote')[0]
                              endif
                              return s:FilterEscape(matches, a:A)
                            endfunction
                            
                            " Section: Buffer auto-commands
                            
    1              0.000002 function! s:ReplaceCmd(cmd) abort
                              let temp = tempname()
                              let [err, exec_error] = s:TempCmd(temp, a:cmd)
                              if exec_error
                                call s:throw((len(err) ? err : filereadable(temp) ? join(readfile(temp), ' ') : 'unknown error running ' . a:cmd))
                              endif
                              silent exe 'lockmarks keepalt 0read ++edit' s:fnameescape(temp)
                              if &foldenable && foldlevel('$') > 0
                                set nofoldenable
                                silent keepjumps $delete _
                                set foldenable
                              else
                                silent keepjumps $delete _
                              endif
                              call delete(temp)
                              if s:cpath(fnamemodify(bufname('$'), ':p'), temp)
                                silent! execute bufnr('$') . 'bwipeout'
                              endif
                            endfunction
                            
    1              0.000002 function! s:QueryLog(refspec) abort
                              let lines = s:LinesError(['log', '-n', '256', '--pretty=format:%h%x09%s', a:refspec, '--'])[0]
                              call map(lines, 'split(v:val, "\t")')
                              call map(lines, '{"type": "Log", "commit": v:val[0], "subject": v:val[-1]}')
                              return lines
                            endfunction
                            
    1              0.000001 function! s:FormatLog(dict) abort
                              return a:dict.commit . ' ' . a:dict.subject
                            endfunction
                            
    1              0.000001 function! s:FormatRebase(dict) abort
                              return a:dict.status . ' ' . a:dict.commit . ' ' . a:dict.subject
                            endfunction
                            
    1              0.000002 function! s:FormatFile(dict) abort
                              return a:dict.status . ' ' . a:dict.filename
                            endfunction
                            
    1              0.000002 function! s:Format(val) abort
                              if type(a:val) == type({})
                                return s:Format{a:val.type}(a:val)
                              elseif type(a:val) == type([])
                                return map(copy(a:val), 's:Format(v:val)')
                              else
                                return '' . a:val
                              endif
                            endfunction
                            
    1              0.000001 function! s:AddHeader(key, value) abort
                              if empty(a:value)
                                return
                              endif
                              let before = 1
                              while !empty(getline(before))
                                let before += 1
                              endwhile
                              call append(before - 1, [a:key . ':' . (len(a:value) ? ' ' . a:value : '')])
                              if before == 1 && line('$') == 2
                                silent keepjumps 2delete _
                              endif
                            endfunction
                            
    1              0.000002 function! s:AddSection(label, lines, ...) abort
                              let note = a:0 ? a:1 : ''
                              if empty(a:lines) && empty(note)
                                return
                              endif
                              call append(line('$'), ['', a:label . (len(note) ? ': ' . note : ' (' . len(a:lines) . ')')] + s:Format(a:lines))
                            endfunction
                            
    1              0.000008 let s:rebase_abbrevs = {
                                  \ 'p': 'pick',
                                  \ 'r': 'reword',
                                  \ 'e': 'edit',
                                  \ 's': 'squash',
                                  \ 'f': 'fixup',
                                  \ 'x': 'exec',
                                  \ 'd': 'drop',
                                  \ 'l': 'label',
                                  \ 't': 'reset',
                                  \ 'm': 'merge',
                                  \ 'b': 'break',
                                  \ }
                            
    1              0.000001 function! fugitive#BufReadStatus() abort
                              let amatch = s:Slash(expand('%:p'))
                              let b:fugitive_type = 'index'
                              unlet! b:fugitive_reltime
                              try
                                silent doautocmd BufReadPre
                                let config = fugitive#Config()
                            
                                let cmd = [fnamemodify(amatch, ':h')]
                                setlocal noro ma nomodeline buftype=nowrite
                                if s:cpath(fnamemodify($GIT_INDEX_FILE !=# '' ? $GIT_INDEX_FILE : fugitive#Find('.git/index'), ':p')) !=# s:cpath(amatch)
                                  let cmd += ['-c', 'GIT_INDEX_FILE=' . amatch]
                                endif
                            
                                if fugitive#GitVersion(2, 15)
                                  call add(cmd, '--no-optional-locks')
                                endif
                            
                                let b:fugitive_files = {'Staged': {}, 'Unstaged': {}}
                                let [staged, unstaged, untracked] = [[], [], []]
                                let props = {}
                            
                                if fugitive#GitVersion(2, 11)
                                  let cmd += ['status', '--porcelain=v2', '-bz']
                                  let [output, message, exec_error] = s:NullError(cmd)
                                  if exec_error
                                    throw 'fugitive: ' . message
                                  endif
                            
                                  let i = 0
                                  while i < len(output)
                                    let line = output[i]
                                    let prop = matchlist(line, '# \(\S\+\) \(.*\)')
                                    if len(prop)
                                      let props[prop[1]] = prop[2]
                                    elseif line[0] ==# '?'
                                      call add(untracked, {'type': 'File', 'status': line[0], 'filename': line[2:-1]})
                                    elseif line[0] !=# '#'
                                      if line[0] ==# 'u'
                                        let file = matchstr(line, '^.\{37\} \x\{40,\} \x\{40,\} \x\{40,\} \zs.*$')
                                      else
                                        let file = matchstr(line, '^.\{30\} \x\{40,\} \x\{40,\} \zs.*$')
                                      endif
                                      if line[0] ==# '2'
                                        let i += 1
                                        let file = matchstr(file, ' \zs.*')
                                        let files = output[i] . ' -> ' . file
                                      else
                                        let files = file
                                      endif
                                      let sub = matchstr(line, '^[12u] .. \zs....')
                                      if line[2] !=# '.'
                                        call add(staged, {'type': 'File', 'status': line[2], 'filename': files, 'sub': sub})
                                      endif
                                      if line[3] !=# '.'
                                        call add(unstaged, {'type': 'File', 'status': get({'C':'M','M':'?','U':'?'}, matchstr(sub, 'S\.*\zs[CMU]'), line[3]), 'filename': file, 'sub': sub})
                                      endif
                                    endif
                                    let i += 1
                                  endwhile
                                  let branch = substitute(get(props, 'branch.head', '(unknown)'), '\C^(\%(detached\|unknown\))$', '', '')
                                  if len(branch)
                                    let head = branch
                                  elseif has_key(props, 'branch.oid')
                                    let head = props['branch.oid'][0:10]
                                  else
                                    let head = FugitiveHead(11)
                                  endif
                                  let pull = get(props, 'branch.upstream', '')
                                else " git < 2.11
                                  let cmd += ['status', '--porcelain', '-bz']
                                  let [output, message, exec_error] = s:NullError(cmd)
                                  if exec_error
                                    throw 'fugitive: ' . message
                                  endif
                            
                                  while get(output, 0, '') =~# '^\l\+:'
                                    call remove(output, 0)
                                  endwhile
                                  let head = matchstr(output[0], '^## \zs\S\+\ze\%($\| \[\)')
                                  let pull = ''
                                  if head =~# '\.\.\.'
                                    let [head, pull] = split(head, '\.\.\.')
                                    let branch = head
                                  elseif head ==# 'HEAD' || empty(head)
                                    let head = FugitiveHead(11)
                                    let branch = ''
                                  else
                                    let branch = head
                                  endif
                            
                                  let i = 0
                                  while i < len(output)
                                    let line = output[i]
                                    let file = line[3:-1]
                                    let files = file
                                    let i += 1
                                    if line[2] !=# ' '
                                      continue
                                    endif
                                    if line[0:1] =~# '[RC]'
                                      let files = output[i] . ' -> ' . file
                                      let i += 1
                                    endif
                                    if line[0] !~# '[ ?!#]'
                                      call add(staged, {'type': 'File', 'status': line[0], 'filename': files, 'sub': ''})
                                    endif
                                    if line[0:1] ==# '??'
                                      call add(untracked, {'type': 'File', 'status': line[1], 'filename': files})
                                    elseif line[1] !~# '[ !#]'
                                      call add(unstaged, {'type': 'File', 'status': line[1], 'filename': file, 'sub': ''})
                                    endif
                                  endwhile
                                endif
                            
                                if empty(s:Tree())
                                  let [unstaged, untracked] = [[], []]
                                endif
                            
                                for dict in staged
                                  let b:fugitive_files['Staged'][dict.filename] = dict
                                endfor
                                for dict in unstaged
                                  let b:fugitive_files['Unstaged'][dict.filename] = dict
                                endfor
                            
                                let pull_type = 'Pull'
                                if len(pull)
                                  let rebase = fugitive#Config('branch.' . branch . '.rebase', config)
                                  if empty(rebase)
                                    let rebase = fugitive#Config('pull.rebase', config)
                                  endif
                                  if rebase =~# '^\%(true\|yes\|on\|1\|interactive\|merges\|preserve\)$'
                                    let pull_type = 'Rebase'
                                  elseif rebase =~# '^\%(false\|no|off\|0\|\)$'
                                    let pull_type = 'Merge'
                                  endif
                                endif
                            
                                let push_remote = fugitive#Config('branch.' . branch . '.pushRemote', config)
                                if empty(push_remote)
                                  let push_remote = fugitive#Config('remote.pushDefault', config)
                                endif
                                let fetch_remote = fugitive#Config('branch.' . branch . '.remote', config)
                                if empty(fetch_remote)
                                  let fetch_remote = 'origin'
                                endif
                                if empty(push_remote)
                                  let push_remote = fetch_remote
                                endif
                            
                                let push_default = fugitive#Config('push.default')
                                if empty(push_default)
                                  let push_default = fugitive#GitVersion(2) ? 'simple' : 'matching'
                                endif
                                if push_default ==# 'upstream'
                                  let push = pull
                                else
                                  let push = len(branch) ? (push_remote ==# '.' ? '' : push_remote . '/') . branch : ''
                                endif
                            
                                if isdirectory(fugitive#Find('.git/rebase-merge/'))
                                  let rebasing_dir = fugitive#Find('.git/rebase-merge/')
                                elseif isdirectory(fugitive#Find('.git/rebase-apply/'))
                                  let rebasing_dir = fugitive#Find('.git/rebase-apply/')
                                endif
                            
                                let rebasing = []
                                let rebasing_head = 'detached HEAD'
                                if exists('rebasing_dir') && filereadable(rebasing_dir . 'git-rebase-todo')
                                  let rebasing_head = substitute(readfile(rebasing_dir . 'head-name')[0], '\C^refs/heads/', '', '')
                                  let len = 11
                                  let lines = readfile(rebasing_dir . 'git-rebase-todo')
                                  for line in lines
                                    let hash = matchstr(line, '^[^a-z].*\s\zs[0-9a-f]\{4,\}\ze\.\.')
                                    if len(hash)
                                      let len = len(hash)
                                      break
                                    endif
                                  endfor
                                  if getfsize(rebasing_dir . 'done') > 0
                                    let done = readfile(rebasing_dir . 'done')
                                    call map(done, 'substitute(v:val, ''^\l\+\>'', "done", "")')
                                    let done[-1] = substitute(done[-1], '^\l\+\>', 'stop', '')
                                    let lines = done + lines
                                  endif
                                  call reverse(lines)
                                  for line in lines
                                    let match = matchlist(line, '^\(\l\+\)\s\+\(\x\{4,\}\)\s\+\(.*\)')
                                    if len(match) && match[1] !~# 'exec\|merge\|label'
                                      call add(rebasing, {'type': 'Rebase', 'status': get(s:rebase_abbrevs, match[1], match[1]), 'commit': strpart(match[2], 0, len), 'subject': match[3]})
                                    endif
                                  endfor
                                endif
                            
                                let diff = {'Staged': [], 'Unstaged': []}
                                if len(staged)
                                  let diff['Staged'] =
                                      \ s:LinesError(['diff', '--color=never', '--no-ext-diff', '--no-prefix', '--cached'])[0]
                                endif
                                if len(unstaged)
                                  let diff['Unstaged'] =
                                      \ s:LinesError(['diff', '--color=never', '--no-ext-diff', '--no-prefix'])[0]
                                endif
                                let b:fugitive_diff = diff
                                let expanded = get(b:, 'fugitive_expanded', {'Staged': {}, 'Unstaged': {}})
                                let b:fugitive_expanded = {'Staged': {}, 'Unstaged': {}}
                            
                                silent keepjumps %delete_
                            
                                call s:AddHeader('Head', head)
                                call s:AddHeader(pull_type, pull)
                                if push !=# pull
                                  call s:AddHeader('Push', push)
                                endif
                                if empty(s:Tree())
                                  call s:AddHeader('Bare', 'yes')
                                endif
                                call s:AddSection('Rebasing ' . rebasing_head, rebasing)
                                call s:AddSection('Untracked', untracked)
                                call s:AddSection('Unstaged', unstaged)
                                let unstaged_end = len(unstaged) ? line('$') : 0
                                call s:AddSection('Staged', staged)
                                let staged_end = len(staged) ? line('$') : 0
                            
                                if len(pull) && get(props, 'branch.ab') !~# ' -0$'
                                  call s:AddSection('Unpulled from ' . pull, s:QueryLog(head . '..' . pull))
                                endif
                                if len(push) && push !=# pull
                                  call s:AddSection('Unpulled from ' . push, s:QueryLog(head . '..' . push))
                                endif
                                if len(pull) && push !=# pull
                                  call s:AddSection('Unpushed to ' . pull, s:QueryLog(pull . '..' . head))
                                endif
                                if len(push) && !(push ==# pull && get(props, 'branch.ab') =~# '^+0 ')
                                  call s:AddSection('Unpushed to ' . push, s:QueryLog(push . '..' . head))
                                endif
                            
                                setlocal nomodified readonly noswapfile
                                silent doautocmd BufReadPost
                                setlocal nomodifiable
                                if &bufhidden ==# ''
                                  setlocal bufhidden=delete
                                endif
                                let b:dispatch = ':Git fetch --all'
                                call fugitive#MapJumps()
                                call s:Map('n', '-', ":<C-U>execute <SID>Do('Toggle',0)<CR>", '<silent>')
                                call s:Map('x', '-', ":<C-U>execute <SID>Do('Toggle',1)<CR>", '<silent>')
                                call s:Map('n', 's', ":<C-U>execute <SID>Do('Stage',0)<CR>", '<silent>')
                                call s:Map('x', 's', ":<C-U>execute <SID>Do('Stage',1)<CR>", '<silent>')
                                call s:Map('n', 'u', ":<C-U>execute <SID>Do('Unstage',0)<CR>", '<silent>')
                                call s:Map('x', 'u', ":<C-U>execute <SID>Do('Unstage',1)<CR>", '<silent>')
                                call s:Map('n', 'U', ":exe <SID>EchoExec('reset', '-q')<CR>", '<silent>')
                                call s:MapMotion('gu', "exe <SID>StageJump(v:count, 'Untracked', 'Unstaged')")
                                call s:MapMotion('gU', "exe <SID>StageJump(v:count, 'Unstaged', 'Untracked')")
                                call s:MapMotion('gs', "exe <SID>StageJump(v:count, 'Staged')")
                                call s:MapMotion('gp', "exe <SID>StageJump(v:count, 'Unpushed')")
                                call s:MapMotion('gP', "exe <SID>StageJump(v:count, 'Unpulled')")
                                call s:MapMotion('gr', "exe <SID>StageJump(v:count, 'Rebasing')")
                                call s:Map('n', 'C', ":echoerr ':Gstatus C has been removed in favor of cc'<CR>", '<silent>')
                                call s:Map('n', 'a', ":<C-U>execute <SID>Do('Toggle',0)<CR>", '<silent>')
                                call s:Map('n', 'i', ":<C-U>execute <SID>NextExpandedHunk(v:count1)<CR>", '<silent>')
                                call s:Map('n', "=", ":<C-U>execute <SID>StageInline('toggle',line('.'),v:count)<CR>", '<silent>')
                                call s:Map('n', "<", ":<C-U>execute <SID>StageInline('hide',  line('.'),v:count)<CR>", '<silent>')
                                call s:Map('n', ">", ":<C-U>execute <SID>StageInline('show',  line('.'),v:count)<CR>", '<silent>')
                                call s:Map('x', "=", ":<C-U>execute <SID>StageInline('toggle',line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
                                call s:Map('x', "<", ":<C-U>execute <SID>StageInline('hide',  line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
                                call s:Map('x', ">", ":<C-U>execute <SID>StageInline('show',  line(\"'<\"),line(\"'>\")-line(\"'<\")+1)<CR>", '<silent>')
                                call s:Map('n', 'D', ":<C-U>execute <SID>StageDiff('Gdiffsplit')<Bar>redraw<Bar>echohl WarningMsg<Bar> echo ':Gstatus D is deprecated in favor of dd'<Bar>echohl NONE<CR>", '<silent>')
                                call s:Map('n', 'dd', ":<C-U>execute <SID>StageDiff('Gdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'dh', ":<C-U>execute <SID>StageDiff('Ghdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'ds', ":<C-U>execute <SID>StageDiff('Ghdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'dp', ":<C-U>execute <SID>StageDiffEdit()<CR>", '<silent>')
                                call s:Map('n', 'dv', ":<C-U>execute <SID>StageDiff('Gvdiffsplit')<CR>", '<silent>')
                                call s:Map('n', 'd?', ":<C-U>help fugitive_d<CR>", '<silent>')
                                call s:Map('n', 'P', ":<C-U>execute <SID>StagePatch(line('.'),line('.')+v:count1-1)<CR>", '<silent>')
                                call s:Map('x', 'P', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
                                call s:Map('n', 'p', ":<C-U>if v:count<Bar>silent exe <SID>GF('pedit')<Bar>else<Bar>echoerr 'Use = for inline diff, P for :Git add/reset --patch, 1p for :pedit'<Bar>endif<CR>", '<silent>')
                                call s:Map('x', 'p', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
                                call s:Map('n', 'I', ":<C-U>execute <SID>StagePatch(line('.'),line('.'))<CR>", '<silent>')
                                call s:Map('x', 'I', ":<C-U>execute <SID>StagePatch(line(\"'<\"),line(\"'>\"))<CR>", '<silent>')
                                if empty(mapcheck('q', 'n'))
                                  nnoremap <buffer> <silent> q :<C-U>if bufnr('$') == 1<Bar>quit<Bar>else<Bar>bdelete<Bar>endif<Bar>echohl WarningMsg<Bar>echo ':Gstatus q is deprecated in favor of gq or the built-in <Lt>C-W>q'<Bar>echohl NONE<CR>
                                endif
                                call s:Map('n', 'gq', ":<C-U>if bufnr('$') == 1<Bar>quit<Bar>else<Bar>bdelete<Bar>endif<CR>", '<silent>')
                                call s:Map('n', 'R', ":echohl WarningMsg<Bar>echo 'Reloading is automatic.  Use :e to force'<Bar>echohl NONE<CR>", '<silent>')
                                call s:Map('n', 'g<Bar>', ":<C-U>echoerr 'Changed to X'<CR>", '<silent>')
                                call s:Map('x', 'g<Bar>', ":<C-U>echoerr 'Changed to X'<CR>", '<silent>')
                                call s:Map('n', 'X', ":<C-U>execute <SID>StageDelete(line('.'), 0, v:count)<CR>", '<silent>')
                                call s:Map('x', 'X', ":<C-U>execute <SID>StageDelete(line(\"'<\"), line(\"'>\"), v:count)<CR>", '<silent>')
                                call s:Map('n', 'gI', ":<C-U>execute <SID>StageIgnore(line('.'), line('.'), v:count)<CR>", '<silent>')
                                call s:Map('x', 'gI', ":<C-U>execute <SID>StageIgnore(line(\"'<\"), line(\"'>\"), v:count)<CR>", '<silent>')
                                call s:Map('n', '.', ':<C-U> <C-R>=<SID>StageArgs(0)<CR><Home>')
                                call s:Map('x', '.', ':<C-U> <C-R>=<SID>StageArgs(1)<CR><Home>')
                                setlocal filetype=fugitive
                            
                                for [lnum, section] in [[staged_end, 'Staged'], [unstaged_end, 'Unstaged']]
                                  while len(getline(lnum))
                                    let filename = matchstr(getline(lnum), '^[A-Z?] \zs.*')
                                    if has_key(expanded[section], filename)
                                      call s:StageInline('show', lnum)
                                    endif
                                    let lnum -= 1
                                  endwhile
                                endfor
                            
                                let b:fugitive_reltime = reltime()
                                return 'silent ' . s:DoAutocmd('User FugitiveIndex')
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction
                            
    1              0.000002 function! fugitive#FileReadCmd(...) abort
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              let [dir, rev] = s:DirRev(amatch)
                              let line = a:0 > 1 ? a:2 : line("'[")
                              if empty(dir)
                                return 'noautocmd ' . line . 'read ' . s:fnameescape(amatch)
                              endif
                              if rev !~# ':' && s:ChompDefault('', [dir, 'cat-file', '-t', rev]) =~# '^\%(commit\|tag\)$'
                                let cmd = fugitive#Prepare(dir, 'log', '--pretty=format:%B', '-1', rev, '--')
                              else
                                let cmd = fugitive#Prepare(dir, 'cat-file', '-p', rev)
                              endif
                              return line . 'read !' . escape(cmd, '!#%')
                            endfunction
                            
    1              0.000002 function! fugitive#FileWriteCmd(...) abort
                              let tmp = tempname()
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              let autype = a:0 > 1 ? 'Buf' : 'File'
                              if exists('#' . autype . 'WritePre')
                                execute s:DoAutocmd(autype . 'WritePre ' . s:fnameescape(amatch))
                              endif
                              try
                                let [dir, commit, file] = s:DirCommitFile(amatch)
                                if commit !~# '^[0-3]$' || !v:cmdbang && (line("'[") != 1 || line("']") != line('$'))
                                  return "noautocmd '[,']write" . (v:cmdbang ? '!' : '') . ' ' . s:fnameescape(amatch)
                                endif
                                silent execute "'[,']write !".fugitive#Prepare(dir, 'hash-object', '-w', '--stdin', '--').' > '.tmp
                                let sha1 = readfile(tmp)[0]
                                let old_mode = matchstr(s:SystemError([dir, 'ls-files', '--stage', '.' . file])[0], '^\d\+')
                                if empty(old_mode)
                                  let old_mode = executable(s:Tree(dir) . file) ? '100755' : '100644'
                                endif
                                let info = old_mode.' '.sha1.' '.commit."\t".file[1:-1]
                                let [error, exec_error] = s:SystemError([dir, 'update-index', '--index-info'], info . "\n")
                                if !exec_error
                                  setlocal nomodified
                                  if exists('#' . autype . 'WritePost')
                                    execute s:DoAutocmd(autype . 'WritePost ' . s:fnameescape(amatch))
                                  endif
                                  return ''
                                else
                                  return 'echoerr '.string('fugitive: '.error)
                                endif
                              finally
                                call delete(tmp)
                              endtry
                            endfunction
                            
    1              0.000001 function! fugitive#BufReadCmd(...) abort
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              try
                                let [dir, rev] = s:DirRev(amatch)
                                if empty(dir)
                                  return 'echo "Invalid Fugitive URL"'
                                endif
                                if rev =~# '^:\d$'
                                  let b:fugitive_type = 'stage'
                                else
                                  let [b:fugitive_type, exec_error] = s:ChompError([dir, 'cat-file', '-t', rev])
                                  if exec_error && rev =~# '^:0'
                                    let sha = s:ChompDefault('', dir, 'write-tree', '--prefix=' . rev[3:-1])
                                    let exec_error = empty(sha)
                                    let b:fugitive_type = exec_error ? '' : 'tree'
                                  endif
                                  if exec_error
                                    let error = b:fugitive_type
                                    unlet b:fugitive_type
                                    setlocal noswapfile
                                    if empty(&bufhidden)
                                      setlocal bufhidden=delete
                                    endif
                                    if rev =~# '^:\d:'
                                      let &l:readonly = !filewritable(fugitive#Find('.git/index', dir))
                                      return 'silent doautocmd BufNewFile'
                                    else
                                      setlocal readonly nomodifiable
                                      return 'silent doautocmd BufNewFile|echo ' . string(error)
                                    endif
                                  elseif b:fugitive_type !~# '^\%(tag\|commit\|tree\|blob\)$'
                                    return "echoerr ".string("fugitive: unrecognized git type '".b:fugitive_type."'")
                                  endif
                                  if !exists('b:fugitive_display_format') && b:fugitive_type != 'blob'
                                    let b:fugitive_display_format = +getbufvar('#','fugitive_display_format')
                                  endif
                                endif
                            
                                if b:fugitive_type !=# 'blob'
                                  setlocal nomodeline
                                endif
                            
                                setlocal noreadonly modifiable
                                let pos = getpos('.')
                                silent keepjumps %delete_
                                setlocal endofline
                            
                                try
                                  silent exe s:DoAutocmd('BufReadPre')
                                  if b:fugitive_type ==# 'tree'
                                    let b:fugitive_display_format = b:fugitive_display_format % 2
                                    if b:fugitive_display_format
                                      call s:ReplaceCmd([dir, 'ls-tree', exists('sha') ? sha : rev])
                                    else
                                      if !exists('sha')
                                        let sha = s:TreeChomp(dir, 'rev-parse', '--verify', rev, '--')
                                      endif
                                      call s:ReplaceCmd([dir, 'show', '--no-color', sha])
                                    endif
                                  elseif b:fugitive_type ==# 'tag'
                                    let b:fugitive_display_format = b:fugitive_display_format % 2
                                    if b:fugitive_display_format
                                      call s:ReplaceCmd([dir, 'cat-file', b:fugitive_type, rev])
                                    else
                                      call s:ReplaceCmd([dir, 'cat-file', '-p', rev])
                                    endif
                                  elseif b:fugitive_type ==# 'commit'
                                    let b:fugitive_display_format = b:fugitive_display_format % 2
                                    if b:fugitive_display_format
                                      call s:ReplaceCmd([dir, 'cat-file', b:fugitive_type, rev])
                                    else
                                      call s:ReplaceCmd([dir, 'show', '--no-color', '-m', '--first-parent', '--pretty=format:tree%x20%T%nparent%x20%P%nauthor%x20%an%x20<%ae>%x20%ad%ncommitter%x20%cn%x20<%ce>%x20%cd%nencoding%x20%e%n%n%s%n%n%b', rev])
                                      keepjumps 1
                                      keepjumps call search('^parent ')
                                      if getline('.') ==# 'parent '
                                        silent keepjumps delete_
                                      else
                                        silent exe (exists(':keeppatterns') ? 'keeppatterns' : '') 'keepjumps s/\m\C\%(^parent\)\@<! /\rparent /e' . (&gdefault ? '' : 'g')
                                      endif
                                      keepjumps let lnum = search('^encoding \%(<unknown>\)\=$','W',line('.')+3)
                                      if lnum
                                        silent keepjumps delete_
                                      end
                                      silent exe (exists(':keeppatterns') ? 'keeppatterns' : '') 'keepjumps 1,/^diff --git\|\%$/s/\r$//e'
                                      keepjumps 1
                                    endif
                                  elseif b:fugitive_type ==# 'stage'
                                    call s:ReplaceCmd([dir, 'ls-files', '--stage'])
                                  elseif b:fugitive_type ==# 'blob'
                                    call s:ReplaceCmd([dir, 'cat-file', b:fugitive_type, rev])
                                  endif
                                finally
                                  keepjumps call setpos('.',pos)
                                  setlocal nomodified noswapfile
                                  let modifiable = rev =~# '^:.:' && b:fugitive_type !=# 'tree'
                                  let &l:readonly = !modifiable || !filewritable(fugitive#Find('.git/index', dir))
                                  if empty(&bufhidden)
                                    setlocal bufhidden=delete
                                  endif
                                  let &l:modifiable = modifiable
                                  if b:fugitive_type !=# 'blob'
                                    setlocal filetype=git foldmethod=syntax
                                    call s:Map('n', 'a', ":<C-U>let b:fugitive_display_format += v:count1<Bar>exe fugitive#BufReadCmd(@%)<CR>", '<silent>')
                                    call s:Map('n', 'i', ":<C-U>let b:fugitive_display_format -= v:count1<Bar>exe fugitive#BufReadCmd(@%)<CR>", '<silent>')
                                  endif
                                  call fugitive#MapJumps()
                                endtry
                            
                                setlocal modifiable
                            
                                let browsex = maparg('<Plug>NetrwBrowseX', 'n')
                                let remote_check = '\Cnetrw#CheckIfRemote(\%(netrw#GX()\)\=)'
                                if browsex =~# remote_check
                                  exe 'nnoremap <silent> <buffer> <Plug>NetrwBrowseX' substitute(browsex, remote_check, '0', 'g')
                                endif
                            
                                return 'silent ' . s:DoAutocmd('BufReadPost') .
                                      \ (modifiable ? '' : '|setl nomodifiable') . '|silent ' .
                                      \ s:DoAutocmd('User Fugitive' . substitute(b:fugitive_type, '^\l', '\u&', ''))
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction
                            
    1              0.000002 function! fugitive#BufWriteCmd(...) abort
                              return fugitive#FileWriteCmd(a:0 ? a:1 : expand('<amatch>'), 1)
                            endfunction
                            
    1              0.000001 function! fugitive#SourceCmd(...) abort
                              let amatch = a:0 ? a:1 : expand('<amatch>')
                              let temp = s:BlobTemp(amatch)
                              if empty(temp)
                                return 'noautocmd source ' . s:fnameescape(amatch)
                              endif
                              if !exists('g:virtual_scriptnames')
                                let g:virtual_scriptnames = {}
                              endif
                              let g:virtual_scriptnames[temp] = amatch
                              return 'source ' . s:fnameescape(temp)
                            endfunction
                            
                            " Section: Temp files
                            
    1              0.000003 if !exists('s:temp_files')
    1              0.000002   let s:temp_files = {}
    1              0.000001 endif
                            
    1              0.000001 function! s:TempState(...) abort
                              return get(s:temp_files, s:cpath(fnamemodify(a:0 ? a:1 : @%, ':p')), {})
                            endfunction
                            
    1              0.000001 function! s:TempReadPre(file) abort
                              if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                setlocal nomodeline
                                setlocal bufhidden=delete
                                setlocal buftype=nowrite
                                setlocal nomodifiable
                                if len(dict.dir)
                                  let b:git_dir = dict.dir
                                  call extend(b:, {'fugitive_type': 'temp'}, 'keep')
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! s:TempReadPost(file) abort
                              if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                setlocal nobuflisted
                                if has_key(dict, 'filetype') && dict.filetype !=# &l:filetype
                                  let &l:filetype = dict.filetype
                                endif
                                setlocal foldmarker=<<<<<<<,>>>>>>>
                                if empty(mapcheck('q', 'n'))
                                  nnoremap <buffer> <silent> q    :<C-U>bdelete<Bar>echohl WarningMsg<Bar>echo "Temp file q is deprecated in favor of the built-in <Lt>C-W>q"<Bar>echohl NONE<CR>
                                endif
                                if !&modifiable
                                  call s:Map('n', 'gq', ":<C-U>bdelete<CR>", '<silent> <unique>')
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000003 augroup fugitive_temp
    1              0.000141   autocmd!
    1              0.000006   autocmd BufReadPre  * exe s:TempReadPre( expand('<amatch>:p'))
    1              0.000004   autocmd BufReadPost * exe s:TempReadPost(expand('<amatch>:p'))
    1              0.000001 augroup END
                            
                            " Section: :Git
                            
    1              0.000001 function! s:RunJobs() abort
                              return exists('*job_start') || exists('*jobstart')
                            endfunction
                            
    1              0.000002 function! s:RunReceive(state, job, data, ...) abort
                              call add(a:state.log, a:data)
                              let data = type(a:data) == type([]) ? join(a:data, "\n") : a:data
                              if has_key(a:state, 'buffer')
                                let data = remove(a:state, 'buffer') . data
                              endif
                              let escape = "\033]51;[^\007]*"
                              let a:state.buffer = matchstr(data, escape . "$\\|[\r\n]\\+$")
                              if len(a:state.buffer)
                                let data = strpart(data, 0, len(data) - len(a:state.buffer))
                              endif
                              let cmd = matchstr(data, escape . "\007")[5:-2]
                              let data = substitute(data, escape . "\007", '', 'g')
                              echon substitute(data, "\r\\ze\n", '', 'g')
                              if cmd =~# '^fugitive:'
                                let a:state.request = strpart(cmd, 9)
                              endif
                            endfunction
                            
    1              0.000002 function! s:RunSend(job, str) abort
                              try
                                if type(a:job) == type(0)
                                  call chansend(a:job, a:str)
                                else
                                  call ch_sendraw(a:job, a:str)
                                endif
                                return len(a:str)
                              catch /^Vim\%((\a\+)\)\=:E90[06]:/
                                return 0
                              endtry
                            endfunction
                            
    1              0.000003 if !exists('s:edit_jobs')
    1              0.000002   let s:edit_jobs = {}
    1              0.000001 endif
    1              0.000001 function! s:RunWait(state, job) abort
                              let finished = 0
                              try
                                while get(a:state, 'request', '') !=# 'edit' && (type(a:job) == type(0) ? jobwait([a:job], 1)[0] == -1 : ch_status(a:job) !=# 'closed')
                                  if !exists('*jobwait')
                                    sleep 1m
                                  endif
                                  let peek = getchar(1)
                                  if peek != 0 && !(has('win32') && peek == 128)
                                    let c = getchar()
                                    let c = type(c) == type(0) ? nr2char(c) : c
                                    call s:RunSend(a:job, c)
                                    if !a:state.pty
                                      echon c
                                    endif
                                  endif
                                endwhile
                                sleep 1m
                                echo
                                if get(a:state, 'request', '') == 'edit'
                                  call remove(a:state, 'request')
                                  let file = readfile(a:state.temp . '.edit')[0]
                                  exe substitute(a:state.mods, '\<tab\>', '-tab', 'g') 'keepalt split' s:fnameescape(file)
                                  set bufhidden=wipe
                                  let s:edit_jobs[bufnr('')] = [a:state, a:job]
                                endif
                                let finished = 1
                              finally
                                if !finished
                                  try
                                    if a:state.pty
                                      call s:RunSend(a:job, "\<C-C>")
                                    elseif type(a:job) == type(0)
                                      call jobstop(a:job)
                                    else
                                      call job_stop(a:job)
                                    endif
                                  catch /.*/
                                  endtry
                                endif
                              endtry
                              call fugitive#ReloadStatus(a:state.dir, 1)
                              return ''
                            endfunction
                            
    1              0.000002 if !exists('s:resume_queue')
    1              0.000002   let s:resume_queue = []
    1              0.000001 endif
    1              0.000001 function! fugitive#Resume() abort
                              while len(s:resume_queue)
                                let [state, job] = remove(s:resume_queue, 0)
                                call s:RunWait(state, job)
                              endwhile
                            endfunction
                            
    1              0.000002 function! s:RunBufDelete(bufnr) abort
                              if has_key(s:edit_jobs, a:bufnr) |
                                if filereadable(s:edit_jobs[a:bufnr][0].temp . '.edit')
                                  call delete(s:edit_jobs[a:bufnr][0].temp . '.edit')
                                endif
                                call add(s:resume_queue, remove(s:edit_jobs, a:bufnr))
                                call feedkeys(":redraw!|call fugitive#Resume()|silent checktime\r", 'n')
                              endif
                            endfunction
                            
    1              0.000002 augroup fugitive_job
    1              0.000037   autocmd!
    1              0.000004   autocmd BufDelete * call s:RunBufDelete(expand('<abuf>'))
    1              0.000007   autocmd VimLeave *
                                    \ for s:jobbuf in keys(s:edit_jobs) |
                                    \   call writefile([], s:edit_jobs[s:jobbuf][0].temp . '.exit') |
                                    \   redraw! |
                                    \   call call('s:RunWait', remove(s:edit_jobs, s:jobbuf)) |
                                    \ endfor
    1              0.000001 augroup END
                            
    1              0.000002 function! fugitive#PagerFor(argv, ...) abort
                              let args = a:argv
                              if empty(args)
                                return 0
                              elseif (args[0] ==# 'help' || get(args, 1, '') ==# '--help') && !s:HasOpt(args, '--web')
                                return 1
                              endif
                              if args[0] ==# 'config' && (s:HasOpt(args, '-e', '--edit') ||
                                    \   !s:HasOpt(args, '--list', '--get-all', '--get-regexp', '--get-urlmatch')) ||
                                    \ args[0] =~# '^\%(tag\|branch\)$' && (
                                    \    s:HasOpt(args, '--edit-description', '--unset-upstream', '-m', '-M', '--move', '-c', '-C', '--copy', '-d', '-D', '--delete') ||
                                    \   len(filter(args[1:-1], 'v:val =~# "^[^-]\\|^--set-upstream-to="')) &&
                                    \   !s:HasOpt(args, '--contains', '--no-contains', '--merged', '--no-merged', '--points-at'))
                                return 0
                              endif
                              let config = a:0 ? a:1 : fugitive#Config()
                              let value = get(FugitiveConfigGetAll('pager.' . args[0], config), 0, -1)
                              if value =~# '^\%(true\|yes\|on\|1\)$'
                                return 1
                              elseif value =~# '^\%(false\|no|off\|0\|\)$'
                                return 0
                              elseif type(value) == type('')
                                return value
                              elseif args[0] =~# 'diff\%(tool\)\@!\|log\|^show$\|^config$\|^branch$\|^tag$' ||
                                    \ (args[0] ==# 'stash' && get(args, 1, '') ==# 'show') ||
                                    \ (args[0] ==# 'am' && s:HasOpt(args, '--show-current-patch'))
                                return 1
                              else
                                return 0
                              endif
                            endfunction
                            
    1              0.000002 let s:disable_colors = []
   13              0.000018 for s:colortype in ['advice', 'branch', 'diff', 'grep', 'interactive', 'pager', 'push', 'remote', 'showBranch', 'status', 'transport', 'ui']
   12              0.000041   call extend(s:disable_colors, ['-c', 'color.' . s:colortype . '=false'])
   13              0.000007 endfor
    1              0.000002 unlet s:colortype
    1              0.000002 function! fugitive#Command(line1, line2, range, bang, mods, arg) abort
                              let dir = s:Dir()
                              let config = copy(fugitive#Config(dir))
                              let [args, after] = s:SplitExpandChain(a:arg, s:Tree(dir))
                              let flags = []
                              let pager = -1
                              while len(args)
                                if args[0] ==# '-c' && len(args) > 1
                                  call extend(flags, remove(args, 0, 1))
                                elseif args[0] =~# '^-p$\|^--paginate$'
                                  let pager = 1
                                  call remove(args, 0)
                                elseif args[0] =~# '^-P$\|^--no-pager$'
                                  let pager = 0
                                  call remove(args, 0)
                                elseif args[0] =~# '^--\%([[:lower:]-]\+-pathspecs\|no-optional-locks\)$'
                                  call add(flags, remove(args, 0))
                                elseif args[0] =~# '^-C$\|^--\%(exec-path=\|git-dir=\|work-tree=\|bare$\)'
                                  return 'echoerr ' . string('fugitive: ' . args[0] . ' is not supported')
                                else
                                  break
                                endif
                              endwhile
                              if pager is# 0
                                call add(flags, '--no-pager')
                              endif
                              if empty(args) && pager is# -1
                                let cmd = s:StatusCommand(a:line1, a:line2, a:range, a:line2, a:bang, a:mods, '', '', [])
                                return (empty(cmd) ? 'exe' : cmd) . after
                              endif
                              let alias = fugitive#Config('alias.' . get(args, 0, ''), config)
                              if get(args, 1, '') !=# '--help' && alias !~# '^$\|^!\|[\"'']' && !filereadable(s:ExecPath() . '/git-' . args[0])
                                    \ && !(has('win32') && filereadable(s:ExecPath() . '/git-' . args[0] . '.exe'))
                                call remove(args, 0)
                                call extend(args, split(alias, '\s\+'), 'keep')
                              endif
                              let name = substitute(get(args, 0, ''), '\%(^\|-\)\(\l\)', '\u\1', 'g')
                              let git = split(get(g:, 'fugitive_git_command', g:fugitive_git_executable), '\s\+')
                              let options = {'git': git, 'dir': dir, 'flags': flags}
                              if pager is# -1 && exists('*s:' . name . 'Subcommand') && get(args, 1, '') !=# '--help'
                                try
                                  let overrides = s:{name}Subcommand(a:line1, a:line2, a:range, a:bang, a:mods, extend({'command': args[0], 'args': args[1:-1]}, options))
                                  if type(overrides) == type('')
                                    return 'exe ' . string(overrides) . after
                                  endif
                                  let args = [get(overrides, 'command', args[0])] + get(overrides, 'insert_args', []) + args[1:-1]
                                catch /^fugitive:/
                                  return 'echoerr ' . string(v:exception)
                                endtry
                              else
                                let overrides = {}
                              endif
                              let env = get(overrides, 'env', {})
                              let i = 0
                              while i < len(flags) - 1
                                if flags[i] ==# '-c'
                                  let i += 1
                                  let config_name = tolower(matchstr(flags[i], '^[^=]\+'))
                                  if has_key(s:prepare_env, config_name) && flags[i] =~# '=.'
                                    let env[s:prepare_env[config_name]] = matchstr(flags[i], '=\zs.*')
                                  endif
                                  if flags[i] =~# '='
                                    let config[config_name] = [matchstr(flags[i], '=\zs.*')]
                                  else
                                    let config[config_name] = [1]
                                  endif
                                endif
                                let i += 1
                              endwhile
                              let editcmd = (a:line2 > 0 ? a:line2 : '') . (a:line2 ? 'split' : 'edit')
                              if pager is# 1
                                if a:bang && a:line2 >= 0
                                  let editcmd = 'read'
                                elseif a:bang
                                  let editcmd = 'pedit'
                                endif
                              elseif pager is# -1
                                let pager = fugitive#PagerFor(args, config)
                                if a:bang && pager isnot# 1
                                  return 'echoerr ' .  string('fugitive: :Git! for temp buffer output has been replaced by :Git --paginate')
                                endif
                              endif
                              if pager is# 1
                                if editcmd ==# 'read'
                                  return s:ReadExec(a:line1, a:line2, a:range, a:mods, env, args, options) . after
                                else
                                  return s:OpenExec(editcmd, a:mods, env, args, options) . after
                                endif
                              endif
                              if s:HasOpt(args, ['add', 'checkout', 'commit', 'stage', 'stash', 'reset'], '-p', '--patch') ||
                                    \ s:HasOpt(args, ['add', 'clean', 'stage'], '-i', '--interactive') ||
                                    \ type(pager) == type('')
                                let mods = substitute(s:Mods(a:mods), '\<tab\>', '-tab', 'g')
                                let assign = len(dir) ? '|let b:git_dir = ' . string(dir) : ''
                                if has('nvim')
                                  if &autowrite || &autowriteall | silent! wall | endif
                                  return mods . (a:line2 ? 'split' : 'edit') . ' term://' . s:fnameescape(s:UserCommand(options, args)) . assign . '|startinsert' . after
                                elseif has('terminal')
                                  if &autowrite || &autowriteall | silent! wall | endif
                                  return 'exe ' . string(mods . 'terminal ' . (a:line2 ? '' : '++curwin ') . join(map(s:UserCommandList(options) + args, 's:fnameescape(v:val)'))) . assign . after
                                endif
                              endif
                              if s:RunJobs()
                                let state = {'dir': dir, 'mods': s:Mods(a:mods), 'temp': tempname(), 'log': []}
                                let state.pty = get(g:, 'fugitive_pty', has('unix') && (has('patch-8.0.0744') || has('nvim')))
                                if !state.pty
                                  let args = s:AskPassArgs(dir) + args
                                endif
                                let env.FUGITIVE_TEMP = state.temp
                                let editor = 'sh ' . s:TempScript(
                                      \ '[ -f "$FUGITIVE_TEMP.exit" ] && exit 1',
                                      \ 'echo "$1" > "$FUGITIVE_TEMP.edit"',
                                      \ 'printf "\033]51;fugitive:edit\007"',
                                      \ 'while [ -f "$FUGITIVE_TEMP.edit" -a ! -f "$FUGITIVE_TEMP.exit" ]; do sleep 0.05 2>/dev/null || sleep 1; done',
                                      \ 'exit 0')
                                call extend(env, {
                                      \ 'NO_COLOR': '1',
                                      \ 'GIT_EDITOR': editor,
                                      \ 'GIT_SEQUENCE_EDITOR': editor,
                                      \ 'GIT_MERGE_AUTOEDIT': '1',
                                      \ 'GIT_PAGER': 'cat',
                                      \ 'PAGER': 'cat'}, 'keep')
                                let args = s:disable_colors + flags + ['-c', 'advice.waitingForEditor=false'] + args
                                let argv = s:UserCommandList({'git': git, 'dir': dir}) + args
                                let [argv, jobopts] = s:JobOpts(argv, env)
                                let state.cmd = argv
                                let g:_fugitive_last_job = state
                                if &autowrite || &autowriteall | silent! wall | endif
                                if exists('*job_start')
                                  call extend(jobopts, {
                                        \ 'mode': 'raw',
                                        \ 'callback': function('s:RunReceive', [state]),
                                        \ })
                                  if state.pty
                                    let jobopts.pty = 1
                                  endif
                                  let job = job_start(argv, jobopts)
                                else
                                  let job = jobstart(argv, extend(jobopts, {
                                        \ 'pty': state.pty,
                                        \ 'TERM': 'dumb',
                                        \ 'on_stdout': function('s:RunReceive', [state]),
                                        \ 'on_stderr': function('s:RunReceive', [state]),
                                        \ }))
                                endif
                                let state.job = job
                                call s:RunWait(state, job)
                                return 'silent checktime' . after
                              elseif has('win32')
                                return 'echoerr ' . string('fugitive: Vim 8 with job support required to use :Git on Windows')
                              elseif has('gui_running')
                                return 'echoerr ' . string('fugitive: Vim 8 with job support required to use :Git in GVim')
                              else
                                let pre = s:BuildEnvPrefix(env)
                                return 'exe ' . string('noautocmd !' . escape(pre . s:UserCommand(options, args), '!#%')) .
                                      \ '|call fugitive#ReloadStatus(' . string(dir) . ', 1)' .
                                      \ after
                              endif
                            endfunction
                            
    1              0.000002 let s:exec_paths = {}
    1              0.000002 function! s:ExecPath() abort
                              if !has_key(s:exec_paths, g:fugitive_git_executable)
                                let s:exec_paths[g:fugitive_git_executable] = s:sub(system(g:fugitive_git_executable.' --exec-path'),'\n$','')
                              endif
                              return s:exec_paths[g:fugitive_git_executable]
                            endfunction
                            
    1              0.000001 function! s:Subcommands() abort
                              let exec_path = s:ExecPath()
                              return map(split(glob(exec_path.'/git-*'),"\n"),'s:sub(v:val[strlen(exec_path)+5 : -1],"\\.exe$","")')
                            endfunction
                            
    1              0.000002 let s:aliases = {}
    1              0.000002 function! s:Aliases(dir) abort
                              if !has_key(s:aliases, a:dir)
                                let s:aliases[a:dir] = {}
                                let lines = s:NullError([a:dir, 'config', '-z', '--get-regexp', '^alias[.]'])[0]
                                for line in lines
                                  let s:aliases[a:dir][matchstr(line, '\.\zs.\{-}\ze\n')] = matchstr(line, '\n\zs.*')
                                endfor
                              endif
                              return s:aliases[a:dir]
                            endfunction
                            
    1              0.000002 function! fugitive#Complete(lead, ...) abort
                              let dir = a:0 == 1 ? a:1 : a:0 == 3 ? a:3 : s:Dir()
                              let pre = a:0 > 1 ? strpart(a:1, 0, a:2) : ''
                              let subcmd = matchstr(pre, '\u\w*[! ] *\zs[[:alnum:]-]\+\ze ')
                              if empty(subcmd)
                                let results = sort(s:Subcommands() + keys(s:Aliases(dir)))
                              elseif a:0 ==# 2 && subcmd =~# '^\%(commit\|revert\|push\|fetch\|pull\|merge\|rebase\)$'
                                let cmdline = substitute(a:1, '\u\w*\([! ] *\)' . subcmd, 'G' . subcmd, '')
                                let caps_subcmd = substitute(subcmd, '\%(^\|-\)\l', '\u&', 'g')
                                return fugitive#{caps_subcmd}Complete(a:lead, cmdline, a:2 + len(cmdline) - len(a:1))
                              elseif pre =~# ' -- '
                                return fugitive#CompletePath(a:lead, dir)
                              elseif a:lead =~# '^-'
                                let results = split(s:ChompDefault('', dir, subcmd, '--git-completion-helper'), ' ')
                              else
                                return fugitive#CompleteObject(a:lead, dir)
                              endif
                              return filter(results, 'strpart(v:val, 0, strlen(a:lead)) ==# a:lead')
                            endfunction
                            
                            " Section: :Gcd, :Glcd
                            
    1              0.000002 function! fugitive#CdComplete(A, L, P) abort
                              return filter(fugitive#CompletePath(a:A), 'v:val =~# "/$"')
                            endfunction
                            
    1              0.000001 function! fugitive#Cd(path, ...) abort
                              let path = substitute(a:path, '^:/:\=\|^:(\%(top\|top,literal\|literal,top\|literal\))', '', '')
                              if path !~# '^/\|^\a\+:\|^\.\.\=\%(/\|$\)'
                                let dir = s:Dir()
                                exe s:DirCheck(dir)
                                let path = (empty(s:Tree(dir)) ? dir : s:Tree(dir)) . '/' . path
                              endif
                              return (a:0 && a:1 ? 'lcd ' : 'cd ') . s:fnameescape(FugitiveVimPath(path))
                            endfunction
                            
                            " Section: :Gstatus
                            
    1              0.000003 function! s:StatusCommand(line1, line2, range, count, bang, mods, reg, arg, args, ...) abort
                              let dir = a:0 ? a:1 : s:Dir()
                              exe s:DirCheck(dir)
                              try
                                let mods = s:Mods(a:mods, &splitbelow ? 'botright' : 'topleft')
                                let file = fugitive#Find(':', dir)
                                let arg = ' +setl\ foldmethod=syntax\ foldlevel=1\|let\ w:fugitive_status=FugitiveGitDir() ' .
                                      \ s:fnameescape(file)
                                for winnr in range(1, winnr('$'))
                                  if s:cpath(file, fnamemodify(bufname(winbufnr(winnr)), ':p'))
                                    if winnr == winnr()
                                      call s:ReloadStatus()
                                    else
                                      call s:ExpireStatus(dir)
                                      exe winnr . 'wincmd w'
                                    endif
                                    let w:fugitive_status = dir
                                    1
                                    return ''
                                  endif
                                endfor
                                if a:count ==# 0
                                  return mods . 'edit' . (a:bang ? '!' : '') . arg
                                elseif a:bang
                                  return mods . 'pedit' . arg . '|wincmd P'
                                else
                                  return mods . 'keepalt ' . (a:count > 0 ? a:count : '') . 'split' . arg
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              return ''
                            endfunction
                            
    1              0.000002 function! s:StageJump(offset, section, ...) abort
                              let line = search('^\%(' . a:section . '\)', 'nw')
                              if !line && a:0
                                let line = search('^\%(' . a:1 . '\)', 'nw')
                              endif
                              if line
                                exe line
                                if a:offset
                                  for i in range(a:offset)
                                    call search(s:file_commit_pattern . '\|^$', 'W')
                                    if empty(getline('.')) && a:0 && getline(line('.') + 1) =~# '^\%(' . a:1 . '\)'
                                      call search(s:file_commit_pattern . '\|^$', 'W')
                                    endif
                                    if empty(getline('.'))
                                      return ''
                                    endif
                                  endfor
                                  call s:StageReveal()
                                else
                                  call s:StageReveal()
                                  +
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 function! s:StageSeek(info, fallback) abort
                              let info = a:info
                              if empty(info.section)
                                return a:fallback
                              endif
                              let line = search('^' . info.section, 'wn')
                              if !line
                                for section in get({'Staged': ['Unstaged', 'Untracked'], 'Unstaged': ['Untracked', 'Staged'], 'Untracked': ['Unstaged', 'Staged']}, info.section, [])
                                  let line = search('^' . section, 'wn')
                                  if line
                                    return line + (info.index > 0 ? 1 : 0)
                                  endif
                                endfor
                                return 1
                              endif
                              let i = 0
                              while len(getline(line))
                                let filename = matchstr(getline(line), '^[A-Z?] \zs.*')
                                if len(filename) &&
                                      \ ((info.filename[-1:-1] ==# '/' && filename[0 : len(info.filename) - 1] ==# info.filename) ||
                                      \ (filename[-1:-1] ==# '/' && filename ==# info.filename[0 : len(filename) - 1]) ||
                                      \ filename ==# info.filename)
                                  if info.offset < 0
                                    return line
                                  else
                                    if getline(line+1) !~# '^@'
                                      exe s:StageInline('show', line)
                                    endif
                                    if getline(line+1) !~# '^@'
                                      return line
                                    endif
                                    let type = info.sigil ==# '-' ? '-' : '+'
                                    let offset = -1
                                    while offset < info.offset
                                      let line += 1
                                      if getline(line) =~# '^@'
                                        let offset = +matchstr(getline(line), type . '\zs\d\+') - 1
                                      elseif getline(line) =~# '^[ ' . type . ']'
                                        let offset += 1
                                      elseif getline(line) !~# '^[ @\+-]'
                                        return line - 1
                                      endif
                                    endwhile
                                    return line
                                  endif
                                endif
                                let commit = matchstr(getline(line), '^\%(\%(\x\x\x\)\@!\l\+\s\+\)\=\zs[0-9a-f]\+')
                                if len(commit) && commit ==# info.commit
                                  return line
                                endif
                                if i ==# info.index
                                  let backup = line
                                endif
                                let i += getline(line) !~# '^[ @\+-]'
                                let line += 1
                              endwhile
                              return exists('backup') ? backup : line - 1
                            endfunction
                            
    1              0.000002 function! s:DoAutocmdChanged(dir) abort
                              let dir = a:dir is# -2 ? '' : FugitiveGitDir(a:dir)
                              if empty(dir) || !exists('#User#FugitiveChanged') || exists('g:fugitive_event')
                                return ''
                              endif
                              try
                                let g:fugitive_event = dir
                                exe s:DoAutocmd('User FugitiveChanged')
                              finally
                                unlet! g:fugitive_event
                                " Force statusline reload with the buffer's Git dir
                                let &ro = &ro
                              endtry
                              return ''
                            endfunction
                            
    1              0.000002 function! s:ReloadStatusBuffer(...) abort
                              if get(b:, 'fugitive_type', '') !=# 'index'
                                return ''
                              endif
                              let original_lnum = a:0 ? a:1 : line('.')
                              let info = s:StageInfo(original_lnum)
                              call fugitive#BufReadStatus()
                              exe s:StageSeek(info, original_lnum)
                              normal! 0
                              return ''
                            endfunction
                            
    1              0.000001 function! s:ReloadStatus(...) abort
                              call s:ExpireStatus(-1)
                              call s:ReloadStatusBuffer(a:0 ? a:1 : line('.'))
                              exe s:DoAutocmdChanged(-1)
                              return ''
                            endfunction
                            
    1              0.000003 let s:last_time = reltime()
    1              0.000003 if !exists('s:last_times')
    1              0.000003   let s:last_times = {}
    1              0.000001 endif
                            
    1              0.000002 function! s:ExpireStatus(bufnr) abort
                              if a:bufnr == -2
                                let s:head_cache = {}
                                let s:last_time = reltime()
                                return ''
                              endif
                              let dir = s:Dir(a:bufnr)
                              if len(dir)
                                let s:last_times[s:cpath(dir)] = reltime()
                                if has_key(s:head_cache, dir)
                                  call remove(s:head_cache, dir)
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! s:ReloadWinStatus(...) abort
                              if get(b:, 'fugitive_type', '') !=# 'index' || &modified
                                return
                              endif
                              if !exists('b:fugitive_reltime')
                                exe s:ReloadStatusBuffer()
                                return
                              endif
                              let t = b:fugitive_reltime
                              if reltimestr(reltime(s:last_time, t)) =~# '-\|\d\{10\}\.' ||
                                    \ reltimestr(reltime(get(s:last_times, s:cpath(s:Dir()), t), t)) =~# '-\|\d\{10\}\.'
                                exe s:ReloadStatusBuffer()
                              endif
                            endfunction
                            
    1              0.000002 function! s:ReloadTabStatus(...) abort
                              let mytab = tabpagenr()
                              let tab = a:0 ? a:1 : mytab
                              for winnr in range(1, tabpagewinnr(tab, '$'))
                                if getbufvar(tabpagebuflist(tab)[winnr-1], 'fugitive_type') ==# 'index'
                                  execute 'tabnext '.tab
                                  if winnr != winnr()
                                    execute winnr.'wincmd w'
                                    let restorewinnr = 1
                                  endif
                                  try
                                    call s:ReloadWinStatus()
                                  finally
                                    if exists('restorewinnr')
                                      unlet restorewinnr
                                      wincmd p
                                    endif
                                    execute 'tabnext '.mytab
                                  endtry
                                endif
                              endfor
                              unlet! t:fugitive_reload_status
                            endfunction
                            
    1              0.000002 function! fugitive#ReloadStatus(...) abort
                              call s:ExpireStatus(a:0 ? a:1 : -1)
                              if a:0 > 1 ? a:2 : 1
                                let t = reltime()
                                let t:fugitive_reload_status = t
                                for tabnr in exists('*settabvar') ? range(1, tabpagenr('$')) : []
                                  call settabvar(tabnr, 'fugitive_reload_status', t)
                                endfor
                                call s:ReloadTabStatus()
                                exe s:DoAutocmdChanged(a:0 ? a:1 : -1)
                              else
                                call s:ReloadWinStatus()
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! fugitive#EfmDir(...) abort
                              let dir = matchstr(a:0 ? a:1 : &errorformat, '\c,%\\&\%(git\|fugitive\)_\=dir=\zs\%(\\.\|[^,]\)*')
                              let dir = substitute(dir, '%%', '%', 'g')
                              let dir = substitute(dir, '\\\ze[\,]', '', 'g')
                              return dir
                            endfunction
                            
    1              0.000001 augroup fugitive_status
    1              0.000038   autocmd!
    1              0.000009   autocmd BufWritePost         * call fugitive#ReloadStatus(-1, 0)
    1              0.000008   autocmd ShellCmdPost,ShellFilterPost * nested call fugitive#ReloadStatus(-2, 0)
    1              0.000006   autocmd BufDelete * nested
                                    \ if getbufvar(+expand('<abuf>'), 'buftype') ==# 'terminal' |
                                    \   if !empty(FugitiveGitDir(+expand('<abuf>'))) |
                                    \     call fugitive#ReloadStatus(+expand('<abuf>'), 1) |
                                    \   else |
                                    \     call fugitive#ReloadStatus(-2, 0) |
                                    \  endif |
                                    \ endif
    1              0.000011   autocmd QuickFixCmdPost make,lmake,[cl]file,[cl]getfile nested
                                    \ call fugitive#ReloadStatus(fugitive#EfmDir(), 1)
    1              0.000004   if !has('win32')
    1              0.000005     autocmd FocusGained        * call fugitive#ReloadStatus(-2, 0)
    1              0.000001   endif
    1              0.000005   autocmd BufEnter index,index.lock
                                    \ call s:ReloadWinStatus()
    1              0.000005   autocmd TabEnter *
                                    \ if exists('t:fugitive_reload_status') |
                                    \    call s:ReloadTabStatus() |
                                    \ endif
    1              0.000000 augroup END
                            
    1              0.000002 function! s:StageInfo(...) abort
                              let lnum = a:0 ? a:1 : line('.')
                              let sigil = matchstr(getline(lnum), '^[ @\+-]')
                              let offset = -1
                              if len(sigil)
                                let type = sigil ==# '-' ? '-' : '+'
                                while lnum > 0 && getline(lnum) !~# '^@'
                                  if getline(lnum) =~# '^[ '.type.']'
                                    let offset += 1
                                  endif
                                  let lnum -= 1
                                endwhile
                                let offset += matchstr(getline(lnum), type.'\zs\d\+')
                                while getline(lnum) =~# '^[ @\+-]'
                                  let lnum -= 1
                                endwhile
                              endif
                              let slnum = lnum + 1
                              let section = ''
                              let index = 0
                              while len(getline(slnum - 1)) && empty(section)
                                let slnum -= 1
                                let section = matchstr(getline(slnum), '^\u\l\+\ze.* (\d\+)$')
                                if empty(section) && getline(slnum) !~# '^[ @\+-]'
                                  let index += 1
                                endif
                              endwhile
                              let text = matchstr(getline(lnum), '^[A-Z?] \zs.*')
                              return {'section': section,
                                    \ 'heading': getline(slnum),
                                    \ 'sigil': sigil,
                                    \ 'offset': offset,
                                    \ 'filename': text,
                                    \ 'relative': reverse(split(text, ' -> ')),
                                    \ 'paths': map(reverse(split(text, ' -> ')), 's:Tree() . "/" . v:val'),
                                    \ 'commit': matchstr(getline(lnum), '^\%(\%(\x\x\x\)\@!\l\+\s\+\)\=\zs[0-9a-f]\{4,\}\ze '),
                                    \ 'status': matchstr(getline(lnum), '^[A-Z?]\ze \|^\%(\x\x\x\)\@!\l\+\ze [0-9a-f]'),
                                    \ 'sub': get(get(get(b:fugitive_files, section, {}), text, {}), 'sub', ''),
                                    \ 'index': index}
                            endfunction
                            
    1              0.000002 function! s:Selection(arg1, ...) abort
                              if a:arg1 ==# 'n'
                                let arg1 = line('.')
                                let arg2 = -v:count
                              elseif a:arg1 ==# 'v'
                                let arg1 = line("'<")
                                let arg2 = line("'>")
                              else
                                let arg1 = a:arg1
                                let arg2 = a:0 ? a:1 : 0
                              endif
                              let first = arg1
                              if arg2 < 0
                                let last = first - arg2 - 1
                              elseif arg2 > 0
                                let last = arg2
                              else
                                let last = first
                              endif
                              while getline(first) =~# '^$\|^[A-Z][a-z]'
                                let first += 1
                              endwhile
                              if first > last || &filetype !=# 'fugitive'
                                return []
                              endif
                              let flnum = first
                              while getline(flnum) =~# '^[ @\+-]'
                                let flnum -= 1
                              endwhile
                              let slnum = flnum + 1
                              let section = ''
                              let index = 0
                              while len(getline(slnum - 1)) && empty(section)
                                let slnum -= 1
                                let heading = matchstr(getline(slnum), '^\u\l\+.* (\d\+)$')
                                if empty(heading) && getline(slnum) !~# '^[ @\+-]'
                                  let index += 1
                                endif
                              endwhile
                              let results = []
                              let template = {
                                    \ 'heading': heading,
                                    \ 'section': matchstr(heading, '^\u\l\+\ze.* (\d\+)$'),
                                    \ 'filename': '',
                                    \ 'relative': [],
                                    \ 'paths': [],
                                    \ 'commit': '',
                                    \ 'status': '',
                                    \ 'patch': 0,
                                    \ 'index': index}
                              let line = getline(flnum)
                              let lnum = first - (arg1 == flnum ? 0 : 1)
                              let root = s:Tree() . '/'
                              while lnum <= last
                                if line =~# '^\u\l\+\ze.* (\d\+)$'
                                  let template.heading = getline(lnum)
                                  let template.section = matchstr(template.heading, '^\u\l\+\ze.* (\d\+)$')
                                  let template.index = 0
                                elseif line =~# '^[ @\+-]'
                                  let template.index -= 1
                                  if !results[-1].patch
                                    let results[-1].patch = lnum
                                  endif
                                  let results[-1].lnum = lnum
                                elseif line =~# '^[A-Z?] '
                                  let filename = matchstr(line, '^[A-Z?] \zs.*')
                                  call add(results, extend(deepcopy(template), {
                                        \ 'lnum': lnum,
                                        \ 'filename': filename,
                                        \ 'relative': reverse(split(filename, ' -> ')),
                                        \ 'paths': map(reverse(split(filename, ' -> ')), 'root . v:val'),
                                        \ 'status': matchstr(line, '^[A-Z?]'),
                                        \ }))
                                elseif line =~# '^\x\x\x\+ '
                                  call add(results, extend({
                                        \ 'lnum': lnum,
                                        \ 'commit': matchstr(line, '^\x\x\x\+'),
                                        \ }, template, 'keep'))
                                elseif line =~# '^\l\+ \x\x\x\+ '
                                  call add(results, extend({
                                        \ 'lnum': lnum,
                                        \ 'commit': matchstr(line, '^\l\+ \zs\x\x\x\+'),
                                        \ 'status': matchstr(line, '^\l\+'),
                                        \ }, template, 'keep'))
                                endif
                                let lnum += 1
                                let template.index += 1
                                let line = getline(lnum)
                              endwhile
                              if len(results) && results[0].patch && arg2 == 0
                                while getline(results[0].patch) =~# '^[ \+-]'
                                  let results[0].patch -= 1
                                endwhile
                                while getline(results[0].lnum + 1) =~# '^[ \+-]'
                                  let results[0].lnum += 1
                                endwhile
                              endif
                              return results
                            endfunction
                            
    1              0.000002 function! s:StageArgs(visual) abort
                              let commits = []
                              let paths = []
                              for record in s:Selection(a:visual ? 'v' : 'n')
                                if len(record.commit)
                                  call add(commits, record.commit)
                                endif
                                call extend(paths, record.paths)
                              endfor
                              if s:cpath(s:Tree(), getcwd())
                                call map(paths, 'fugitive#Path(v:val, "./")')
                              endif
                              return join(map(commits + paths, 's:fnameescape(v:val)'), ' ')
                            endfunction
                            
    1              0.000002 function! s:Do(action, visual) abort
                              let line = getline('.')
                              let reload = 0
                              if !a:visual && !v:count && line =~# '^[A-Z][a-z]'
                                let header = matchstr(line, '^\S\+\ze:')
                                if len(header) && exists('*s:Do' . a:action . header . 'Header')
                                  let reload = s:Do{a:action}{header}Header(matchstr(line, ': \zs.*')) > 0
                                else
                                  let section = matchstr(line, '^\S\+')
                                  if exists('*s:Do' . a:action . section . 'Heading')
                                    let reload = s:Do{a:action}{section}Heading(line) > 0
                                  endif
                                endif
                                return reload ? s:ReloadStatus() : ''
                              endif
                              let selection = s:Selection(a:visual ? 'v' : 'n')
                              if empty(selection)
                                return ''
                              endif
                              call filter(selection, 'v:val.section ==# selection[0].section')
                              let status = 0
                              let err = ''
                              try
                                for record in selection
                                  if exists('*s:Do' . a:action . record.section)
                                    let status = s:Do{a:action}{record.section}(record)
                                  else
                                    continue
                                  endif
                                  if !status
                                    return ''
                                  endif
                                  let reload = reload || (status > 0)
                                endfor
                                if status < 0
                                  execute record.lnum + 1
                                endif
                                let success = 1
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              finally
                                if reload
                                  execute s:ReloadStatus()
                                endif
                                if exists('success')
                                  call s:StageReveal()
                                endif
                              endtry
                              return ''
                            endfunction
                            
    1              0.000002 function! s:StageReveal() abort
                              exe 'normal! zv'
                              let begin = line('.')
                              if getline(begin) =~# '^@'
                                let end = begin + 1
                                while getline(end) =~# '^[ \+-]'
                                  let end += 1
                                endwhile
                              elseif getline(begin) =~# '^commit '
                                let end = begin
                                while end < line('$') && getline(end + 1) !~# '^commit '
                                  let end += 1
                                endwhile
                              elseif getline(begin) =~# s:section_pattern
                                let end = begin
                                while len(getline(end + 1))
                                  let end += 1
                                endwhile
                              endif
                              if exists('end')
                                while line('.') > line('w0') + &scrolloff && end > line('w$')
                                  execute "normal! \<C-E>"
                                endwhile
                              endif
                            endfunction
                            
    1              0.000002 let s:file_pattern = '^[A-Z?] .\|^diff --'
    1              0.000003 let s:file_commit_pattern = s:file_pattern . '\|^\%(\l\{3,\} \)\=[0-9a-f]\{4,\} '
    1              0.000003 let s:item_pattern = s:file_commit_pattern . '\|^@@'
                            
    1              0.000002 function! s:NextHunk(count) abort
                              if &filetype ==# 'fugitive' && getline('.') =~# s:file_pattern
                                exe s:StageInline('show')
                              endif
                              for i in range(a:count)
                                if &filetype ==# 'fugitive'
                                  call search(s:file_pattern . '\|^@', 'W')
                                  if getline('.') =~# s:file_pattern
                                    exe s:StageInline('show')
                                    if getline(line('.') + 1) =~# '^@'
                                      +
                                    endif
                                  endif
                                else
                                  call search('^@@', 'W')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'
                            endfunction
                            
    1              0.000002 function! s:PreviousHunk(count) abort
                              for i in range(a:count)
                                if &filetype ==# 'fugitive'
                                  let lnum = search(s:file_pattern . '\|^@','Wbn')
                                  call s:StageInline('show', lnum)
                                  call search('^? .\|^@','Wb')
                                else
                                  call search('^@@', 'Wb')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'
                            endfunction
                            
    1              0.000001 function! s:NextFile(count) abort
                              for i in range(a:count)
                                exe s:StageInline('hide')
                                if !search(s:file_pattern, 'W')
                                  break
                                endif
                              endfor
                              exe s:StageInline('hide')
                              return '.'
                            endfunction
                            
    1              0.000001 function! s:PreviousFile(count) abort
                              exe s:StageInline('hide')
                              for i in range(a:count)
                                if !search(s:file_pattern, 'Wb')
                                  break
                                endif
                                exe s:StageInline('hide')
                              endfor
                              return '.'
                            endfunction
                            
    1              0.000001 function! s:NextItem(count) abort
                              for i in range(a:count)
                                if !search(s:item_pattern, 'W') && getline('.') !~# s:item_pattern
                                  call search('^commit ', 'W')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'
                            endfunction
                            
    1              0.000002 function! s:PreviousItem(count) abort
                              for i in range(a:count)
                                if !search(s:item_pattern, 'Wbe') && getline('.') !~# s:item_pattern
                                  call search('^commit ', 'Wbe')
                                endif
                              endfor
                              call s:StageReveal()
                              return '.'
                            endfunction
                            
    1              0.000002 let s:section_pattern = '^[A-Z][a-z][^:]*$'
    1              0.000005 let s:section_commit_pattern = s:section_pattern . '\|^commit '
                            
    1              0.000002 function! s:NextSection(count) abort
                              let orig = line('.')
                              if getline('.') !~# '^commit '
                                -
                              endif
                              for i in range(a:count)
                                if !search(s:section_commit_pattern, 'W')
                                  break
                                endif
                              endfor
                              if getline('.') =~# s:section_commit_pattern
                                call s:StageReveal()
                                return getline('.') =~# s:section_pattern ? '+' : ':'
                              else
                                return orig
                              endif
                            endfunction
                            
    1              0.000002 function! s:PreviousSection(count) abort
                              let orig = line('.')
                              if getline('.') !~# '^commit '
                                -
                              endif
                              for i in range(a:count)
                                if !search(s:section_commit_pattern . '\|\%^', 'bW')
                                  break
                                endif
                              endfor
                              if getline('.') =~# s:section_commit_pattern || line('.') == 1
                                call s:StageReveal()
                                return getline('.') =~# s:section_pattern ? '+' : ':'
                              else
                                return orig
                              endif
                            endfunction
                            
    1              0.000002 function! s:NextSectionEnd(count) abort
                              +
                              if empty(getline('.'))
                                +
                              endif
                              for i in range(a:count)
                                if !search(s:section_commit_pattern, 'W')
                                  return '$'
                                endif
                              endfor
                              return search('^.', 'Wb')
                            endfunction
                            
    1              0.000002 function! s:PreviousSectionEnd(count) abort
                              let old = line('.')
                              for i in range(a:count)
                                if search(s:section_commit_pattern, 'Wb') <= 1
                                  exe old
                                  if i
                                    break
                                  else
                                    return ''
                                  endif
                                endif
                                let old = line('.')
                              endfor
                              return search('^.', 'Wb')
                            endfunction
                            
    1              0.000002 function! s:PatchSearchExpr(reverse) abort
                              let line = getline('.')
                              if col('.') ==# 1 && line =~# '^[+-]'
                                if line =~# '^[+-]\{3\} '
                                  let pattern = '^[+-]\{3\} ' . substitute(escape(strpart(line, 4), '^$.*[]~\'), '^\w/', '\\w/', '') . '$'
                                else
                                  let pattern = '^[+-]\s*' . escape(substitute(strpart(line, 1), '^\s*\|\s*$', '', ''), '^$.*[]~\') . '\s*$'
                                endif
                                if a:reverse
                                  return '?' . escape(pattern, '/?') . "\<CR>"
                                else
                                  return '/' . escape(pattern, '/') . "\<CR>"
                                endif
                              endif
                              return a:reverse ? '#' : '*'
                            endfunction
                            
    1              0.000002 function! s:StageInline(mode, ...) abort
                              if &filetype !=# 'fugitive'
                                return ''
                              endif
                              let lnum1 = a:0 ? a:1 : line('.')
                              let lnum = lnum1 + 1
                              if a:0 > 1 && a:2 == 0
                                let info = s:StageInfo(lnum - 1)
                                if empty(info.paths) && len(info.section)
                                  while len(getline(lnum))
                                    let lnum += 1
                                  endwhile
                                endif
                              elseif a:0 > 1
                                let lnum += a:2 - 1
                              endif
                              while lnum > lnum1
                                let lnum -= 1
                                while lnum > 0 && getline(lnum) =~# '^[ @\+-]'
                                  let lnum -= 1
                                endwhile
                                let info = s:StageInfo(lnum)
                                if !has_key(b:fugitive_diff, info.section)
                                  continue
                                endif
                                if getline(lnum + 1) =~# '^[ @\+-]'
                                  let lnum2 = lnum + 1
                                  while getline(lnum2 + 1) =~# '^[ @\+-]'
                                    let lnum2 += 1
                                  endwhile
                                  if a:mode !=# 'show'
                                    setlocal modifiable noreadonly
                                    exe 'silent keepjumps ' . (lnum + 1) . ',' . lnum2 . 'delete _'
                                    call remove(b:fugitive_expanded[info.section], info.filename)
                                    setlocal nomodifiable readonly nomodified
                                  endif
                                  continue
                                endif
                                if !has_key(b:fugitive_diff, info.section) || info.status !~# '^[ADMRU]$' || a:mode ==# 'hide'
                                  continue
                                endif
                                let mode = ''
                                let diff = []
                                let index = 0
                                let start = -1
                                for line in b:fugitive_diff[info.section]
                                  if mode ==# 'await' && line[0] ==# '@'
                                    let mode = 'capture'
                                  endif
                                  if mode !=# 'head' && line !~# '^[ @\+-]'
                                    if len(diff)
                                      break
                                    endif
                                    let start = index
                                    let mode = 'head'
                                  elseif mode ==# 'head' && substitute(line, "\t$", '', '') ==# '--- ' . info.relative[-1]
                                    let mode = 'await'
                                  elseif mode ==# 'head' && substitute(line, "\t$", '', '') ==# '+++ ' . info.relative[0]
                                    let mode = 'await'
                                  elseif mode ==# 'capture'
                                    call add(diff, line)
                                  elseif line[0] ==# '@'
                                    let mode = ''
                                  endif
                                  let index += 1
                                endfor
                                if len(diff)
                                  setlocal modifiable noreadonly
                                  silent call append(lnum, diff)
                                  let b:fugitive_expanded[info.section][info.filename] = [start, len(diff)]
                                  setlocal nomodifiable readonly nomodified
                                endif
                              endwhile
                              return lnum
                            endfunction
                            
    1              0.000001 function! s:NextExpandedHunk(count) abort
                              for i in range(a:count)
                                call s:StageInline('show', line('.'), 1)
                                call search(s:file_pattern . '\|^@','W')
                              endfor
                              return '.'
                            endfunction
                            
    1              0.000001 function! s:StageDiff(diff) abort
                              let lnum = line('.')
                              let info = s:StageInfo(lnum)
                              let prefix = info.offset > 0 ? '+' . info.offset : ''
                              if info.sub =~# '^S'
                                if info.section ==# 'Staged'
                                  return 'Git --paginate diff --no-ext-diff --submodule=log --cached -- ' . info.paths[0]
                                elseif info.sub =~# '^SC'
                                  return 'Git --paginate diff --no-ext-diff --submodule=log -- ' . info.paths[0]
                                else
                                  return 'Git --paginate diff --no-ext-diff --submodule=diff -- ' . info.paths[0]
                                endif
                              elseif empty(info.paths) && info.section ==# 'Staged'
                                return 'Git --paginate diff --no-ext-diff --cached'
                              elseif empty(info.paths)
                                return 'Git --paginate diff --no-ext-diff'
                              elseif len(info.paths) > 1
                                execute 'Gedit' . prefix s:fnameescape(':0:' . info.paths[0])
                                return a:diff . '! HEAD:'.s:fnameescape(info.paths[1])
                              elseif info.section ==# 'Staged' && info.sigil ==# '-'
                                execute 'Gedit' prefix s:fnameescape(':0:'.info.paths[0])
                                return a:diff . '! :0:%'
                              elseif info.section ==# 'Staged'
                                execute 'Gedit' prefix s:fnameescape(':0:'.info.paths[0])
                                return a:diff . '! @:%'
                              elseif info.sigil ==# '-'
                                execute 'Gedit' prefix s:fnameescape(':0:'.info.paths[0])
                                return a:diff . '! :(top)%'
                              else
                                execute 'Gedit' prefix s:fnameescape(':(top)'.info.paths[0])
                                return a:diff . '!'
                              endif
                            endfunction
                            
    1              0.000001 function! s:StageDiffEdit() abort
                              let info = s:StageInfo(line('.'))
                              let arg = (empty(info.paths) ? s:Tree() : info.paths[0])
                              if info.section ==# 'Staged'
                                return 'Git --paginate diff --no-ext-diff --cached '.s:fnameescape(arg)
                              elseif info.status ==# '?'
                                call s:TreeChomp('add', '--intent-to-add', '--', arg)
                                return s:ReloadStatus()
                              else
                                return 'Git --paginate diff --no-ext-diff '.s:fnameescape(arg)
                              endif
                            endfunction
                            
    1              0.000002 function! s:StageApply(info, reverse, extra) abort
                              if a:info.status ==# 'R'
                                call s:throw('fugitive: patching renamed file not yet supported')
                              endif
                              let cmd = ['apply', '-p0', '--recount'] + a:extra
                              let info = a:info
                              let start = info.patch
                              let end = info.lnum
                              let lines = getline(start, end)
                              if empty(filter(copy(lines), 'v:val =~# "^[+-]"'))
                                return -1
                              endif
                              while getline(end) =~# '^[-+ ]'
                                let end += 1
                                if getline(end) =~# '^[' . (a:reverse ? '+' : '-') . ' ]'
                                  call add(lines, ' ' . getline(end)[1:-1])
                                endif
                              endwhile
                              while start > 0 && getline(start) !~# '^@'
                                let start -= 1
                                if getline(start) =~# '^[' . (a:reverse ? '+' : '-') . ' ]'
                                  call insert(lines, ' ' . getline(start)[1:-1])
                                elseif getline(start) =~# '^@'
                                  call insert(lines, getline(start))
                                endif
                              endwhile
                              if start == 0
                                throw 'fugitive: cold not find hunk'
                              elseif getline(start) !~# '^@@ '
                                throw 'fugitive: cannot apply conflict hunk'
                              endif
                              let i = b:fugitive_expanded[info.section][info.filename][0]
                              let head = []
                              while get(b:fugitive_diff[info.section], i, '@') !~# '^@'
                                call add(head, b:fugitive_diff[info.section][i])
                                let i += 1
                              endwhile
                              call extend(lines, head, 'keep')
                              let temp = tempname()
                              call writefile(lines, temp)
                              if a:reverse
                                call add(cmd, '--reverse')
                              endif
                              call extend(cmd, ['--', temp])
                              let [output, exec_error] = s:ChompError(cmd)
                              if !exec_error
                                return 1
                              endif
                              call s:throw(output)
                            endfunction
                            
    1              0.000002 function! s:StageDelete(lnum1, lnum2, count) abort
                              let restore = []
                              let err = ''
                              try
                                for info in s:Selection(a:lnum1, a:lnum2)
                                  if empty(info.paths)
                                    continue
                                  endif
                                  let sub = get(get(get(b:fugitive_files, info.section, {}), info.filename, {}), 'sub')
                                  if sub =~# '^S'
                                    if info.status ==# 'A'
                                      continue
                                    endif
                                    if info.section ==# 'Staged'
                                      call s:TreeChomp('reset', '--', info.paths[0])
                                    endif
                                    if info.status =~# '[MD]'
                                      call s:TreeChomp('submodule', 'update', '--', info.paths[0])
                                      call add(restore, ':Git -C ' . info.relative[0] . ' checkout -')
                                    endif
                                    continue
                                  endif
                                  if info.status ==# 'D'
                                    let undo = 'Gremove'
                                  elseif info.paths[0] =~# '/$'
                                    let err .= '|echoerr ' . string('fugitive: will not delete directory ' . string(info.relative[0]))
                                    break
                                  else
                                    let undo = 'Gread ' . s:TreeChomp('hash-object', '-w', '--', info.paths[0])[0:10]
                                  endif
                                  if info.patch
                                    call s:StageApply(info, 1, info.section ==# 'Staged' ? ['--index'] : [])
                                  elseif info.status ==# '?'
                                    call s:TreeChomp('clean', '-f', '--', info.paths[0])
                                  elseif a:count == 2
                                    call s:TreeChomp('checkout', '--ours', '--', info.paths[0])
                                  elseif a:count == 3
                                    call s:TreeChomp('checkout', '--theirs', '--', info.paths[0])
                                  elseif info.status =~# '[ADU]' &&
                                        \ get(b:fugitive_files[info.section ==# 'Staged' ? 'Unstaged' : 'Staged'], info.filename, {'status': ''}).status =~# '[AU]'
                                    call s:TreeChomp('checkout', info.section ==# 'Staged' ? '--ours' : '--theirs', '--', info.paths[0])
                                  elseif info.status ==# 'U'
                                    call s:TreeChomp('rm', '--', info.paths[0])
                                  elseif info.status ==# 'A'
                                    call s:TreeChomp('rm', '-f', '--', info.paths[0])
                                  elseif info.section ==# 'Unstaged'
                                    call s:TreeChomp('checkout', '--', info.paths[0])
                                  else
                                    call s:TreeChomp('checkout', 'HEAD^{}', '--', info.paths[0])
                                  endif
                                  call add(restore, ':Gsplit ' . s:fnameescape(info.relative[0]) . '|' . undo)
                                endfor
                              catch /^fugitive:/
                                let err .= '|echoerr ' . string(v:exception)
                              endtry
                              if empty(restore)
                                return err[1:-1]
                              endif
                              exe s:ReloadStatus()
                              call s:StageReveal()
                              if len(restore)
                                return 'checktime|redraw|echomsg ' . string('To restore, ' . join(restore, '|')) . err
                              else
                                return 'checktime|redraw' . err
                              endif
                            endfunction
                            
    1              0.000002 function! s:StageIgnore(lnum1, lnum2, count) abort
                              let paths = []
                              for info in s:Selection(a:lnum1, a:lnum2)
                                call extend(paths, info.relative)
                              endfor
                              call map(paths, '"/" . v:val')
                              exe 'Gsplit' (a:count ? '.gitignore' : '.git/info/exclude')
                              let last = line('$')
                              if last == 1 && empty(getline(1))
                                call setline(last, paths)
                              else
                                call append(last, paths)
                                exe last + 1
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 function! s:DoToggleHeadHeader(value) abort
                              exe 'edit' s:fnameescape(s:Dir())
                              call search('\C^index$', 'wc')
                            endfunction
                            
    1              0.000002 function! s:DoStagePushHeader(value) abort
                              let remote = matchstr(a:value, '\zs[^/]\+\ze/')
                              if empty(remote)
                                let remote = '.'
                              endif
                              let branch = matchstr(a:value, '\%([^/]\+/\)\=\zs\S\+')
                              call feedkeys(':Git push ' . remote . ' ' . branch)
                            endfunction
                            
    1              0.000002 function! s:DoTogglePushHeader(value) abort
                              return s:DoStagePushHeader(a:value)
                            endfunction
                            
    1              0.000002 function! s:DoStageUnpushedHeading(heading) abort
                              let remote = matchstr(a:heading, 'to \zs[^/]\+\ze/')
                              if empty(remote)
                                let remote = '.'
                              endif
                              let branch = matchstr(a:heading, 'to \%([^/]\+/\)\=\zs\S\+')
                              call feedkeys(':Git push ' . remote . ' ' . 'HEAD:' . 'refs/heads/' . branch)
                            endfunction
                            
    1              0.000001 function! s:DoToggleUnpushedHeading(heading) abort
                              return s:DoStageUnpushedHeading(a:heading)
                            endfunction
                            
    1              0.000002 function! s:DoStageUnpushed(record) abort
                              let remote = matchstr(a:record.heading, 'to \zs[^/]\+\ze/')
                              if empty(remote)
                                let remote = '.'
                              endif
                              let branch = matchstr(a:record.heading, 'to \%([^/]\+/\)\=\zs\S\+')
                              call feedkeys(':Git push ' . remote . ' ' . a:record.commit . ':' . 'refs/heads/' . branch)
                            endfunction
                            
    1              0.000001 function! s:DoToggleUnpushed(record) abort
                              return s:DoStageUnpushed(a:record)
                            endfunction
                            
    1              0.000002 function! s:DoUnstageUnpulledHeading(heading) abort
                              call feedkeys(':Git rebase')
                            endfunction
                            
    1              0.000001 function! s:DoToggleUnpulledHeading(heading) abort
                              call s:DoUnstageUnpulledHeading(a:heading)
                            endfunction
                            
    1              0.000002 function! s:DoUnstageUnpulled(record) abort
                              call feedkeys(':Git rebase ' . a:record.commit)
                            endfunction
                            
    1              0.000001 function! s:DoToggleUnpulled(record) abort
                              call s:DoUnstageUnpulled(a:record)
                            endfunction
                            
    1              0.000002 function! s:DoUnstageUnpushed(record) abort
                              call feedkeys(':Git -c sequence.editor=true rebase --interactive --autosquash ' . a:record.commit . '^')
                            endfunction
                            
    1              0.000002 function! s:DoToggleStagedHeading(...) abort
                              call s:TreeChomp('reset', '-q')
                              return 1
                            endfunction
                            
    1              0.000002 function! s:DoUnstageStagedHeading(heading) abort
                              return s:DoToggleStagedHeading(a:heading)
                            endfunction
                            
    1              0.000002 function! s:DoToggleUnstagedHeading(...) abort
                              call s:TreeChomp('add', '-u')
                              return 1
                            endfunction
                            
    1              0.000002 function! s:DoStageUnstagedHeading(heading) abort
                              return s:DoToggleUnstagedHeading(a:heading)
                            endfunction
                            
    1              0.000002 function! s:DoToggleUntrackedHeading(...) abort
                              call s:TreeChomp('add', '.')
                              return 1
                            endfunction
                            
    1              0.000001 function! s:DoStageUntrackedHeading(heading) abort
                              return s:DoToggleUntrackedHeading(a:heading)
                            endfunction
                            
    1              0.000002 function! s:DoToggleStaged(record) abort
                              if a:record.patch
                                return s:StageApply(a:record, 1, ['--cached'])
                              else
                                call s:TreeChomp(['reset', '-q', '--'] + a:record.paths)
                                return 1
                              endif
                            endfunction
                            
    1              0.000002 function! s:DoUnstageStaged(record) abort
                              return s:DoToggleStaged(a:record)
                            endfunction
                            
    1              0.000002 function! s:DoToggleUnstaged(record) abort
                              if a:record.patch && a:record.status !=# 'A'
                                return s:StageApply(a:record, 0, ['--cached'])
                              else
                                call s:TreeChomp(['add', '-A', '--'] + a:record.paths)
                                return 1
                              endif
                            endfunction
                            
    1              0.000002 function! s:DoStageUnstaged(record) abort
                              return s:DoToggleUnstaged(a:record)
                            endfunction
                            
    1              0.000001 function! s:DoUnstageUnstaged(record) abort
                              if a:record.status ==# 'A'
                                call s:TreeChomp(['reset', '-q', '--'] + a:record.paths)
                                return 1
                              else
                                return -1
                              endif
                            endfunction
                            
    1              0.000002 function! s:DoToggleUntracked(record) abort
                              call s:TreeChomp(['add', '--'] + a:record.paths)
                              return 1
                            endfunction
                            
    1              0.000001 function! s:DoStageUntracked(record) abort
                              return s:DoToggleUntracked(a:record)
                            endfunction
                            
    1              0.000002 function! s:StagePatch(lnum1,lnum2) abort
                              let add = []
                              let reset = []
                              let intend = []
                            
                              for lnum in range(a:lnum1,a:lnum2)
                                let info = s:StageInfo(lnum)
                                if empty(info.paths) && info.section ==# 'Staged'
                                  return 'Git reset --patch'
                                elseif empty(info.paths) && info.section ==# 'Unstaged'
                                  return 'Git add --patch'
                                elseif empty(info.paths) && info.section ==# 'Untracked'
                                  return 'Git add --interactive'
                                elseif empty(info.paths)
                                  continue
                                endif
                                execute lnum
                                if info.section ==# 'Staged'
                                  let reset += info.relative
                                elseif info.section ==# 'Untracked'
                                  let intend += info.paths
                                elseif info.status !~# '^D'
                                  let add += info.relative
                                endif
                              endfor
                              try
                                if !empty(intend)
                                  call s:TreeChomp(['add', '--intent-to-add', '--'] + intend)
                                endif
                                if !empty(add)
                                  execute "Git add --patch -- ".join(map(add,'s:fnameescape(v:val)'))
                                endif
                                if !empty(reset)
                                  execute "Git reset --patch -- ".join(map(reset,'s:fnameescape(v:val)'))
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              return s:ReloadStatus()
                            endfunction
                            
                            " Section: :Git commit, :Git revert
                            
    1              0.000003 function! s:CommitInteractive(line1, line2, range, bang, mods, options, patch) abort
                              let status = s:StatusCommand(a:line1, a:line2, a:range, a:line2, a:bang, a:mods, '', '', [], a:options.dir)
                              let status = len(status) ? status . '|' : ''
                              if a:patch
                                return status . 'if search("^Unstaged")|exe "normal >"|exe "+"|endif'
                              else
                                return status . 'if search("^Untracked\\|^Unstaged")|exe "+"|endif'
                              endif
                            endfunction
                            
    1              0.000002 function! s:CommitSubcommand(line1, line2, range, bang, mods, options) abort
                              let argv = copy(a:options.args)
                              let i = 0
                              while get(argv, i, '--') !=# '--'
                                if argv[i] =~# '^-[apzsneiovq].'
                                  call insert(argv, argv[i][0:1])
                                  let argv[i+1] = '-' . argv[i+1][2:-1]
                                else
                                  let i += 1
                                endif
                              endwhile
                              if s:HasOpt(argv, '-i', '--interactive')
                                return s:CommitInteractive(a:line1, a:line2, a:range, a:bang, a:mods, a:options, 0)
                              elseif s:HasOpt(argv, '-p', '--patch')
                                return s:CommitInteractive(a:line1, a:line2, a:range, a:bang, a:mods, a:options, 1)
                              else
                                return {}
                              endif
                            endfunction
                            
    1              0.000003 function! s:RevertSubcommand(line1, line2, range, bang, mods, options) abort
                              return {'insert_args': ['--edit']}
                            endfunction
                            
    1              0.000002 function! fugitive#CommitComplete(A, L, P) abort
                              if a:A =~# '^--fixup=\|^--squash='
                                let commits = s:LinesError(['log', '--pretty=format:%s', '@{upstream}..'])[0]
                                let pre = matchstr(a:A, '^--\w*=''\=') . ':/^'
                                if pre =~# "'"
                                  call map(commits, 'pre . string(tr(v:val, "|\"^$*[]", "......."))[1:-1]')
                                  call filter(commits, 'strpart(v:val, 0, strlen(a:A)) ==# a:A')
                                  return commits
                                else
                                  return s:FilterEscape(map(commits, 'pre . tr(v:val, "\\ !^$*?[]()''\"`&;<>|#", "....................")'), a:A)
                                endif
                              else
                                return s:CompleteSub('commit', a:A, a:L, a:P, function('fugitive#CompletePath'))
                              endif
                              return []
                            endfunction
                            
    1              0.000002 function! fugitive#RevertComplete(A, L, P) abort
                              return s:CompleteSub('revert', a:A, a:L, a:P, function('s:CompleteRevision'))
                            endfunction
                            
                            " Section: :Git merge, :Git rebase, :Git pull
                            
    1              0.000002 function! fugitive#MergeComplete(A, L, P) abort
                              return s:CompleteSub('merge', a:A, a:L, a:P, function('s:CompleteRevision'))
                            endfunction
                            
    1              0.000002 function! fugitive#RebaseComplete(A, L, P) abort
                              return s:CompleteSub('rebase', a:A, a:L, a:P, function('s:CompleteRevision'))
                            endfunction
                            
    1              0.000002 function! fugitive#PullComplete(A, L, P) abort
                              return s:CompleteSub('pull', a:A, a:L, a:P, function('s:CompleteRemote'))
                            endfunction
                            
    1              0.000002 function! s:MergeSubcommand(line1, line2, range, bang, mods, options) abort
                              let dir = a:options.dir
                              if empty(a:options.args) && (
                                    \ filereadable(fugitive#Find('.git/MERGE_MSG', dir)) ||
                                    \ isdirectory(fugitive#Find('.git/rebase-apply', dir)) ||
                                    \  !empty(s:TreeChomp(dir, 'diff-files', '--diff-filter=U')))
                                return 'echohl WarningMsg|echo ":Git merge for loading conflicts is deprecated in favor of :Git mergetool"|echohl NONE|silent Git' . (a:bang ? '!' : '') . s:fnameescape(a:options.flags + ['mergetool'])
                              endif
                              return {}
                            endfunction
                            
    1              0.000003 function! s:RebaseSubcommand(line1, line2, range, bang, mods, options) abort
                              let args = a:options.args
                              if s:HasOpt(args, '--autosquash') && !s:HasOpt(args, '-i', '--interactive')
                                return {'env': {'GIT_SEQUENCE_EDITOR': 'true'}, 'insert_args': ['--interactive']}
                              endif
                              return {}
                            endfunction
                            
                            " Section: :Git difftool, :Git mergetool
                            
    1              0.000002 function! s:ToolItems(state, from, to, offsets, text, ...) abort
                              let items = []
                              for i in range(len(a:state.diff))
                                let diff = a:state.diff[i]
                                let path = (i == len(a:state.diff) - 1) ? a:to : a:from
                                if empty(path)
                                  return []
                                endif
                                let item = {
                                      \ 'valid': a:0 ? a:1 : 1,
                                      \ 'filename': diff.filename . FugitiveVimPath(path),
                                      \ 'lnum': matchstr(get(a:offsets, i), '\d\+'),
                                      \ 'text': a:text}
                                if len(get(diff, 'module', ''))
                                  let item.module = diff.module . path
                                endif
                                call add(items, item)
                              endfor
                              let diff = items[0:-2]
                              let items[-1].context = {'diff': items[0:-2]}
                              return [items[-1]]
                            endfunction
                            
    1              0.000001 function! s:ToolToFrom(str) abort
                              if a:str =~# ' => '
                                let str = a:str =~# '{.* => .*}' ? a:str : '{' . a:str . '}'
                                return [substitute(str, '{.* => \(.*\)}', '\1', ''),
                                      \ substitute(str, '{\(.*\) => .*}', '\1', '')]
                              else
                                return [a:str, a:str]
                              endif
                            endfunction
                            
    1              0.000002 function! s:ToolParse(state, line) abort
                              if type(a:line) !=# type('') || a:state.mode ==# 'hunk' && a:line =~# '^[ +-]'
                                return []
                              elseif a:line =~# '^diff '
                                let a:state.mode = 'diffhead'
                                let a:state.from = ''
                                let a:state.to = ''
                              elseif a:state.mode ==# 'diffhead' && a:line =~# '^--- [^/]'
                                let a:state.from = a:line[4:-1]
                                let a:state.to = a:state.from
                              elseif a:state.mode ==# 'diffhead' && a:line =~# '^+++ [^/]'
                                let a:state.to = a:line[4:-1]
                                if empty(get(a:state, 'from', ''))
                                  let a:state.from = a:state.to
                                endif
                              elseif a:line[0] ==# '@'
                                let a:state.mode = 'hunk'
                                if has_key(a:state, 'from')
                                  let offsets = split(matchstr(a:line, '^@\+ \zs[-+0-9, ]\+\ze @'), ' ')
                                  return s:ToolItems(a:state, a:state.from, a:state.to, offsets, matchstr(a:line, ' @@\+ \zs.*'))
                                endif
                              elseif a:line =~# '^\* Unmerged path .'
                                let file = a:line[16:-1]
                                return s:ToolItems(a:state, file, file, [], '')
                              elseif a:line =~# '^[A-Z]\d*\t.\|^:.*\t.'
                                " --raw, --name-status
                                let [status; files] = split(a:line, "\t")
                                return s:ToolItems(a:state, files[0], files[-1], [], a:state.name_only ? '' : status)
                              elseif a:line =~# '^ \S.* |'
                                " --stat
                                let [_, to, changes; __] = matchlist(a:line, '^ \(.\{-\}\) \+|\zs \(.*\)$')
                                let [to, from] = s:ToolToFrom(to)
                                return s:ToolItems(a:state, from, to, [], changes)
                              elseif a:line =~# '^ *\([0-9.]\+%\) .'
                                " --dirstat
                                let [_, changes, to; __] = matchlist(a:line, '^ *\([0-9.]\+%\) \(.*\)')
                                return s:ToolItems(a:state, to, to, [], changes)
                              elseif a:line =~# '^\(\d\+\|-\)\t\(\d\+\|-\)\t.'
                                " --numstat
                                let [_, add, remove, to; __] = matchlist(a:line, '^\(\d\+\|-\)\t\(\d\+\|-\)\t\(.*\)')
                                let [to, from] = s:ToolToFrom(to)
                                return s:ToolItems(a:state, from, to, [], add ==# '-' ? 'Binary file' : '+' . add . ' -' . remove, add !=# '-')
                              elseif a:state.mode !=# 'diffhead' && a:state.mode !=# 'hunk' && len(a:line) || a:line =~# '^git: \|^usage: \|^error: \|^fatal: '
                                return [{'text': a:line}]
                              endif
                              return []
                            endfunction
                            
    1              0.000003 function! s:ToolStream(line1, line2, range, bang, mods, options, args, state) abort
                              let i = 0
                              let argv = copy(a:args)
                              let prompt = 1
                              let state = a:state
                              while i < len(argv)
                                let match = matchlist(argv[i], '^\(-[a-zABDFH-KN-RT-Z]\)\ze\(.*\)')
                                if len(match) && len(match[2])
                                  call insert(argv, match[1])
                                  let argv[i+1] = '-' . match[2]
                                  continue
                                endif
                                let arg = argv[i]
                                if arg =~# '^-t$\|^--tool=\|^--tool-help$\|^--help$'
                                  return {}
                                elseif arg =~# '^-y$\|^--no-prompt$'
                                  let prompt = 0
                                  call remove(argv, i)
                                  continue
                                elseif arg ==# '--prompt'
                                  let prompt = 1
                                  call remove(argv, i)
                                  continue
                                elseif arg =~# '^--\%(no-\)\=\(symlinks\|trust-exit-code\|gui\)$'
                                  call remove(argv, i)
                                  continue
                                elseif arg ==# '--'
                                  break
                                endif
                                let i += 1
                              endwhile
                              let a:state.mode = 'init'
                              let a:state.from = ''
                              let a:state.to = ''
                              let exec = s:UserCommandList({'git': a:options.git, 'dir': a:options.dir})
                              if fugitive#GitVersion(1, 9) || (!s:HasOpt(argv, '--name-status') && !prompt)
                                let exec += ['-c', 'diff.context=0']
                              endif
                              let exec += a:options.flags + ['--no-pager', 'diff', '--no-ext-diff', '--no-color', '--no-prefix'] + argv
                              if prompt
                                let title = ':Git ' . s:fnameescape(a:options.flags + [a:options.command] + a:options.args)
                                return s:QuickfixStream(a:line2, 'difftool', title, exec, !a:bang, s:function('s:ToolParse'), a:state)
                              else
                                let filename = ''
                                let cmd = []
                                let tabnr = tabpagenr() + 1
                                for line in split(s:SystemError(s:shellesc(exec))[0], "\n")
                                  for item in s:ToolParse(a:state, line)
                                    if len(get(item, 'filename', '')) && item.filename != filename
                                      call add(cmd, 'tabedit ' . s:fnameescape(item.filename))
                                      for i in reverse(range(len(get(item.context, 'diff', []))))
                                        call add(cmd, (i ? 'rightbelow' : 'leftabove') . ' vert Gdiffsplit! ' . s:fnameescape(item.context.diff[i].filename))
                                      endfor
                                      call add(cmd, 'wincmd =')
                                      let filename = item.filename
                                    endif
                                  endfor
                                endfor
                                return join(cmd, '|') . (empty(cmd) ? '' : '|' . tabnr . 'tabnext')
                              endif
                            endfunction
                            
    1              0.000002 function! s:MergetoolSubcommand(line1, line2, range, bang, mods, options) abort
                              let dir = a:options.dir
                              exe s:DirCheck(dir)
                              let i = 0
                              let prompt = 1
                              let cmd = ['diff', '--diff-filter=U']
                              let state = {'name_only': 0}
                              let state.diff = [{'prefix': ':2:', 'module': ':2:'}, {'prefix': ':3:', 'module': ':3:'}, {'prefix': ':(top)'}]
                              call map(state.diff, 'extend(v:val, {"filename": fugitive#Find(v:val.prefix, dir)})')
                              return s:ToolStream(a:line1, a:line2, a:range, a:bang, a:mods, a:options, ['--diff-filter=U'] + a:options.args, state)
                            endfunction
                            
    1              0.000003 function! s:DifftoolSubcommand(line1, line2, range, bang, mods, options) abort
                              let dir = a:options.dir
                              exe s:DirCheck(dir)
                              let i = 0
                              let argv = copy(a:options.args)
                              let commits = []
                              let cached = 0
                              let reverse = 1
                              let prompt = 1
                              let state = {'name_only': 0}
                              let merge_base_against = {}
                              let dash = (index(argv, '--') > i ? ['--'] : [])
                              while i < len(argv)
                                let match = matchlist(argv[i], '^\(-[a-zABDFH-KN-RT-Z]\)\ze\(.*\)')
                                if len(match) && len(match[2])
                                  call insert(argv, match[1])
                                  let argv[i+1] = '-' . match[2]
                                  continue
                                endif
                                let arg = argv[i]
                                if arg ==# '--cached'
                                  let cached = 1
                                elseif arg ==# '-R'
                                  let reverse = 1
                                elseif arg ==# '--name-only'
                                  let state.name_only = 1
                                  let argv[0] = '--name-status'
                                elseif arg ==# '--'
                                  break
                                elseif arg !~# '^-\|^\.\.\=\%(/\|$\)'
                                  let parsed = s:LinesError(['rev-parse', '--revs-only', substitute(arg, ':.*', '', '')] + dash)[0]
                                  call map(parsed, '{"uninteresting": v:val =~# "^\\^", "prefix": substitute(v:val, "^\\^", "", "") . ":"}')
                                  let merge_base_against = {}
                                  if arg =~# '\.\.\.' && len(parsed) > 2
                                    let display = map(split(arg, '\.\.\.', 1), 'empty(v:val) ? "@" : v:val')
                                    if len(display) == 2
                                      let parsed[0].module = display[1] . ':'
                                      let parsed[1].module = display[0] . ':'
                                    endif
                                    let parsed[2].module = arg . ':'
                                    if empty(commits)
                                      let merge_base_against = parsed[0]
                                      let parsed = [parsed[2]]
                                    endif
                                  elseif arg =~# '\.\.' && len(parsed) == 2
                                    let display = map(split(arg, '\.\.', 1), 'empty(v:val) ? "@" : v:val')
                                    if len(display) == 2
                                      let parsed[0].module = display[0] . ':'
                                      let parsed[1].module = display[1] . ':'
                                    endif
                                  elseif len(parsed) == 1
                                    let parsed[0].module = arg . ':'
                                  endif
                                  call extend(commits, parsed)
                                endif
                                let i += 1
                              endwhile
                              if len(merge_base_against)
                                call add(commits, merge_base_against)
                              endif
                              let commits = filter(copy(commits), 'v:val.uninteresting') + filter(commits, '!v:val.uninteresting')
                              if cached
                                if empty(commits)
                                  call add(commits, {'prefix': '@:', 'module': '@:'})
                                endif
                                call add(commits, {'prefix': ':0:', 'module': ':0:'})
                              elseif len(commits) < 2
                                call add(commits, {'prefix': ':(top)'})
                                if len(commits) < 2
                                  call insert(commits, {'prefix': ':0:', 'module': ':0:'})
                                endif
                              endif
                              if reverse
                                let commits = [commits[-1]] + repeat([commits[0]], len(commits) - 1)
                                call reverse(commits)
                              endif
                              if len(commits) > 2
                                call add(commits, remove(commits, 0))
                              endif
                              call map(commits, 'extend(v:val, {"filename": fugitive#Find(v:val.prefix, dir)})')
                              let state.diff = commits
                              return s:ToolStream(a:line1, a:line2, a:range, a:bang, a:mods, a:options, argv, state)
                            endfunction
                            
                            " Section: :Ggrep, :Glog
                            
    1              0.000004 if !exists('g:fugitive_summary_format')
    1              0.000014   let g:fugitive_summary_format = '%s'
    1              0.000001 endif
                            
    1              0.000002 function! fugitive#GrepComplete(A, L, P) abort
                              return s:CompleteSub('grep', a:A, a:L, a:P)
                            endfunction
                            
    1              0.000002 function! fugitive#LogComplete(A, L, P) abort
                              return s:CompleteSub('log', a:A, a:L, a:P)
                            endfunction
                            
    1              0.000002 function! s:GrepParseLine(prefix, name_only, dir, line) abort
                              let entry = {'valid': 1}
                              let match = matchlist(a:line, '^\(.\{-\}\):\(\d\+\):\(\d\+:\)\=\(.*\)$')
                              if len(match)
                                let entry.module = match[1]
                                let entry.lnum = +match[2]
                                let entry.col = +match[3]
                                let entry.text = match[4]
                              elseif a:line =~# '^git: \|^usage: \|^error: \|^fatal: '
                                return {'text': a:line}
                              else
                                let entry.module = matchstr(a:line, '\CBinary file \zs.*\ze matches$')
                                if len(entry.module)
                                  let entry.text = 'Binary file'
                                  let entry.valid = 0
                                endif
                              endif
                              if empty(entry.module) && a:name_only
                                let entry.module = a:line
                              endif
                              if empty(entry.module)
                                return {'text': a:line}
                              endif
                              if entry.module !~# ':'
                                let entry.filename = a:prefix . entry.module
                              else
                                let entry.filename = fugitive#Find(entry.module, a:dir)
                              endif
                              return entry
                            endfunction
                            
    1              0.000003 function! s:GrepSubcommand(line1, line2, range, bang, mods, options) abort
                              let dir = a:options.dir
                              exe s:DirCheck(dir)
                              let listnr = a:line1 == 0 ? a:line1 : a:line2
                              let cmd = ['--no-pager', 'grep', '-n', '--no-color', '--full-name']
                              if fugitive#GitVersion(2, 19)
                                call add(cmd, '--column')
                              endif
                              let tree = s:Tree(dir)
                              let args = a:options.args
                              let name_only = s:HasOpt(args, '-l', '--files-with-matches', '--name-only', '-L', '--files-without-match')
                              let title = [listnr < 0 ? ':Ggrep' : ':Glgrep'] + args
                              if listnr > 0
                                exe listnr 'wincmd w'
                              else
                                call s:BlurStatus()
                              endif
                              redraw
                              call s:QuickfixCreate(listnr, {'title': (listnr < 0 ? ':Ggrep ' : ':Glgrep ') . s:fnameescape(args)})
                              let tempfile = tempname()
                              let event = listnr < 0 ? 'grep-fugitive' : 'lgrep-fugitive'
                              silent exe s:DoAutocmd('QuickFixCmdPre ' . event)
                              let prefix = FugitiveVimPath(s:HasOpt(args, '--cached') || empty(tree) ?
                                    \ 'fugitive://' . dir . '//0/' :
                                    \ s:cpath(getcwd(), tree) ? '' : tree . '/')
                              exe '!' . escape(s:UserCommand(a:options, cmd + args), '%#!')
                                    \ printf(&shellpipe . (&shellpipe =~# '%s' ? '' : ' %s'), s:shellesc(tempfile))
                              let list = map(readfile(tempfile), 's:GrepParseLine(prefix, name_only, dir, v:val)')
                              call s:QuickfixSet(listnr, list, 'a')
                              silent exe s:DoAutocmd('QuickFixCmdPost ' . event)
                              if !has('gui_running')
                                redraw
                              endif
                              if !a:bang && !empty(list)
                                return (listnr < 0 ? 'c' : 'l').'first'
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000004 let s:log_diff_context = '{"filename": fugitive#Find(v:val . from, a:dir), "lnum": get(offsets, v:key), "module": strpart(v:val, 0, len(a:state.base_module)) . from}'
                            
    1              0.000001 function! s:LogFlushQueue(state, dir) abort
                              let queue = remove(a:state, 'queue')
                              if a:state.child_found && get(a:state, 'ignore_summary')
                                call remove(queue, 0)
                              elseif len(queue) && len(a:state.target) && len(get(a:state, 'parents', []))
                                let from = substitute(a:state.target, '^/', ':', '')
                                let offsets = []
                                let queue[0].context.diff = map(copy(a:state.parents), s:log_diff_context)
                              endif
                              if len(queue) && queue[-1] ==# {'text': ''}
                                call remove(queue, -1)
                              endif
                              return queue
                            endfunction
                            
    1              0.000002 function! s:LogParse(state, dir, line) abort
                              if a:state.mode ==# 'hunk' && a:line =~# '^[-+ ]'
                                return []
                              endif
                              let list = matchlist(a:line, '^\%(fugitive \(.\{-\}\)\t\|commit \|From \)\=\(\x\{40,\}\)\%( \(.*\)\)\=$')
                              if len(list)
                                let queue = s:LogFlushQueue(a:state, a:dir)
                                let a:state.mode = 'commit'
                                let a:state.base = 'fugitive://' . a:dir . '//' . list[2]
                                if len(list[1])
                                  let [a:state.base_module; a:state.parents] = split(list[1], ' ')
                                else
                                  let a:state.base_module = list[2]
                                  let a:state.parents = []
                                endif
                                let a:state.message = list[3]
                                let a:state.from = ''
                                let a:state.to = ''
                                let context = {}
                                let a:state.queue = [{
                                      \ 'valid': 1,
                                      \ 'context': context,
                                      \ 'filename': a:state.base . a:state.target,
                                      \ 'module': a:state.base_module . substitute(a:state.target, '^/', ':', ''),
                                      \ 'text': a:state.message}]
                                let a:state.child_found = 0
                                return queue
                              elseif type(a:line) == type(0)
                                return s:LogFlushQueue(a:state, a:dir)
                              elseif a:line =~# '^diff'
                                let a:state.mode = 'diffhead'
                                let a:state.from = ''
                                let a:state.to = ''
                              elseif a:state.mode ==# 'diffhead' && a:line =~# '^--- \w/'
                                let a:state.from = a:line[6:-1]
                                let a:state.to = a:state.from
                              elseif a:state.mode ==# 'diffhead' && a:line =~# '^+++ \w/'
                                let a:state.to = a:line[6:-1]
                                if empty(get(a:state, 'from', ''))
                                  let a:state.from = a:state.to
                                endif
                              elseif a:line =~# '^@@[^@]*+\d' && len(get(a:state, 'to', '')) && has_key(a:state, 'base')
                                let a:state.mode = 'hunk'
                                if empty(a:state.target) || a:state.target ==# '/' . a:state.to
                                  if !a:state.child_found && len(a:state.queue) && a:state.queue[-1] ==# {'text': ''}
                                    call remove(a:state.queue, -1)
                                  endif
                                  let a:state.child_found = 1
                                  let offsets = map(split(matchstr(a:line, '^@\+ \zs[-+0-9, ]\+\ze @'), ' '), '+matchstr(v:val, "\\d\\+")')
                                  let context = {}
                                  if len(a:state.parents)
                                    let from = ":" . a:state.from
                                    let context.diff = map(copy(a:state.parents), s:log_diff_context)
                                  endif
                                  call add(a:state.queue, {
                                        \ 'valid': 1,
                                        \ 'context': context,
                                        \ 'filename': FugitiveVimPath(a:state.base . '/' . a:state.to),
                                        \ 'module': a:state.base_module . ':' . a:state.to,
                                        \ 'lnum': offsets[-1],
                                        \ 'text': a:state.message . matchstr(a:line, ' @@\+ .\+')})
                                endif
                              elseif a:state.follow &&
                                    \ a:line =~# '^ \%(mode change \d\|\%(create\|delete\) mode \d\|\%(rename\|copy\|rewrite\) .* (\d\+%)$\)'
                                let rename = matchstr(a:line, '^ rename \zs.* => .*\ze (\d\+%)$')
                                if len(rename)
                                  let rename = rename =~# '{.* => .*}' ? rename : '{' . rename . '}'
                                  if a:state.target ==# simplify('/' . substitute(rename, '{.* => \(.*\)}', '\1', ''))
                                    let a:state.target = simplify('/' . substitute(rename, '{\(.*\) => .*}', '\1', ''))
                                  endif
                                endif
                                if !get(a:state, 'ignore_summary')
                                  call add(a:state.queue, {'text': a:line})
                                endif
                              elseif a:state.mode ==# 'commit' || a:state.mode ==# 'init'
                                call add(a:state.queue, {'text': a:line})
                              endif
                              return []
                            endfunction
                            
    1              0.000003 function! fugitive#LogCommand(line1, count, range, bang, mods, args, type) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              let listnr = a:type =~# '^l' ? 0 : -1
                              let [args, after] = s:SplitExpandChain(a:args, s:Tree(dir))
                              let split = index(args, '--')
                              if split > 0
                                let paths = args[split : -1]
                                let args = args[0 : split - 1]
                              elseif split == 0
                                let paths = args
                                let args = []
                              else
                                let paths = []
                              endif
                              if a:line1 == 0 && a:count
                                let path = fugitive#Path(bufname(a:count), '/', dir)
                                let titlepre = ':0,' . a:count
                              elseif a:count >= 0
                                let path = fugitive#Path(@%, '/', dir)
                                let titlepre = a:count == 0 ? ':0,' . bufnr('') : ':'
                              else
                                let titlepre = ':'
                                let path = ''
                              endif
                              let range = ''
                              let extra_args = []
                              let extra_paths = []
                              let state = {'mode': 'init', 'child_found': 0, 'queue': [], 'follow': 0}
                              if path =~# '^/\.git\%(/\|$\)\|^$'
                                let path = ''
                              elseif a:line1 == 0
                                let range = "0," . (a:count ? a:count : bufnr(''))
                                let extra_paths = ['.' . path]
                                if (empty(paths) || paths ==# ['--']) && !s:HasOpt(args, '--no-follow')
                                  let state.follow = 1
                                  if !s:HasOpt(args, '--follow')
                                    call insert(extra_args, '--follow')
                                  endif
                                  if !s:HasOpt(args, '--summary')
                                    call insert(extra_args, '--summary')
                                    let state.ignore_summary = 1
                                  endif
                                endif
                              elseif a:count > 0
                                if !s:HasOpt(args, '--merges', '--no-merges')
                                  call insert(extra_args, '--no-merges')
                                endif
                                call add(args, '-L' . a:line1 . ',' . a:count . ':' . path[1:-1])
                              endif
                              if len(path) && empty(filter(copy(args), 'v:val =~# "^[^-]"'))
                                let owner = s:Owner(@%, dir)
                                if len(owner)
                                  call add(args, owner)
                                endif
                              endif
                              if empty(extra_paths)
                                let path = ''
                              endif
                              if s:HasOpt(args, '-g', '--walk-reflogs')
                                let format = "%gd %P\t%H %gs"
                              else
                                let format = "%h %P\t%H " . g:fugitive_summary_format
                              endif
                              let cmd = ['--no-pager']
                              if fugitive#GitVersion(1, 9)
                                call extend(cmd, ['-c', 'diff.context=0', '-c', 'diff.noprefix=false', 'log'])
                              else
                                call extend(cmd, ['log', '-U0', '-s'])
                              endif
                              call extend(cmd,
                                    \ ['--no-color', '--no-ext-diff', '--pretty=format:fugitive ' . format] +
                                    \ args + extra_args + paths + extra_paths)
                              let state.target = path
                              let title = titlepre . (listnr < 0 ? 'Gclog ' : 'Gllog ') . s:fnameescape(args + paths)
                              if empty(paths + extra_paths) && empty(a:type) && a:count < 0 && len(s:Relative('/'))
                                let after = '|echohl WarningMsg|echo ' . string('Use :0Glog or :0Gclog for old behavior of targeting current file') . '|echohl NONE' . after
                              endif
                              return s:QuickfixStream(listnr, 'log', title, s:UserCommandList(dir) + cmd, !a:bang, s:function('s:LogParse'), state, dir) . after
                            endfunction
                            
                            " Section: :Gedit, :Gpedit, :Gsplit, :Gvsplit, :Gtabedit, :Gread
                            
    1              0.000002 function! s:UsableWin(nr) abort
                              return a:nr && !getwinvar(a:nr, '&previewwindow') && !getwinvar(a:nr, '&winfixwidth') &&
                                    \ (empty(getwinvar(a:nr, 'fugitive_status')) || getbufvar(winbufnr(a:nr), 'fugitive_type') !=# 'index') &&
                                    \ index(['gitrebase', 'gitcommit'], getbufvar(winbufnr(a:nr), '&filetype')) < 0 &&
                                    \ index(['nofile','help','quickfix'], getbufvar(winbufnr(a:nr), '&buftype')) < 0
                            endfunction
                            
    1              0.000002 function! s:OpenParse(args, wants_cmd) abort
                              let opts = []
                              let cmds = []
                              let args = copy(a:args)
                              while !empty(args)
                                if args[0] =~# '^++'
                                  call add(opts, ' ' . escape(remove(args, 0), ' |"'))
                                elseif a:wants_cmd && args[0] =~# '^+'
                                  call add(cmds, remove(args, 0)[1:-1])
                                else
                                  break
                                endif
                              endwhile
                              if len(args)
                                let file = join(args)
                              elseif empty(expand('%'))
                                let file = ''
                              elseif empty(s:DirCommitFile(@%)[1]) && s:Relative('./') !~# '^\./\.git\>'
                                let file = '>:0'
                              else
                                let file = '>'
                              endif
                              let dir = s:Dir()
                              let efile = s:Expand(file)
                              let url = fugitive#Find(efile, dir)
                            
                              if a:wants_cmd && file[0] ==# '>' && efile[0] !=# '>' && get(b:, 'fugitive_type', '') isnot# 'tree' && &filetype !=# 'netrw'
                                let line = line('.')
                                if expand('%:p') !=# url
                                  let diffcmd = 'diff'
                                  let from = s:DirRev(@%)[1]
                                  let to = s:DirRev(url)[1]
                                  if empty(from) && empty(to)
                                    let diffcmd = 'diff-files'
                                    let args = ['--', expand('%:p'), url]
                                  elseif empty(to)
                                    let args = [from, '--', url]
                                  elseif empty(from)
                                    let args = [to, '--', expand('%:p')]
                                    let reverse = 1
                                  else
                                    let args = [from, to]
                                  endif
                                  let [res, exec_error] = s:LinesError([dir, diffcmd, '-U0'] + args)
                                  if !exec_error
                                    call filter(res, 'v:val =~# "^@@ "')
                                    call map(res, 'substitute(v:val, ''[-+]\d\+\zs '', ",1 ", "g")')
                                    call map(res, 'matchlist(v:val, ''^@@ -\(\d\+\),\(\d\+\) +\(\d\+\),\(\d\+\) @@'')[1:4]')
                                    if exists('reverse')
                                      call map(res, 'v:val[2:3] + v:val[0:1]')
                                    endif
                                    call filter(res, 'v:val[0] < '.line('.'))
                                    let hunk = get(res, -1, [0,0,0,0])
                                    if hunk[0] + hunk[1] > line('.')
                                      let line = hunk[2] + max([1 - hunk[3], 0])
                                    else
                                      let line = hunk[2] + max([hunk[3], 1]) + line('.') - hunk[0] - max([hunk[1], 1])
                                    endif
                                  endif
                                endif
                                call insert(cmds, line)
                              endif
                            
                              let pre = join(opts, '')
                              if len(cmds) > 1
                                let pre .= ' +' . escape(join(map(cmds, '"exe ".string(v:val)'), '|'), ' |"')
                              elseif len(cmds)
                                let pre .= ' +' . escape(cmds[0], ' |"')
                              endif
                              return [url, pre]
                            endfunction
                            
    1              0.000002 function! s:DiffClose() abort
                              let mywinnr = winnr()
                              for winnr in [winnr('#')] + range(winnr('$'),1,-1)
                                if winnr != mywinnr && getwinvar(winnr,'&diff')
                                  execute winnr.'wincmd w'
                                  close
                                  if winnr('$') > 1
                                    wincmd p
                                  endif
                                endif
                              endfor
                              diffoff!
                            endfunction
                            
    1              0.000002 function! s:BlurStatus() abort
                              if (&previewwindow || exists('w:fugitive_status')) && get(b:,'fugitive_type', '') ==# 'index'
                                let winnrs = filter([winnr('#')] + range(1, winnr('$')), 's:UsableWin(v:val)')
                                if len(winnrs)
                                  exe winnrs[0].'wincmd w'
                                else
                                  belowright new
                                endif
                                if &diff
                                  call s:DiffClose()
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! s:OpenExec(cmd, mods, env, args, ...) abort
                              let options = a:0 ? a:1 : {'dir': s:Dir()}
                              let temp = tempname()
                              let columns = get(g:, 'fugitive_columns', 80)
                              let env = s:BuildEnvPrefix(extend({'COLUMNS': columns}, a:env))
                              silent! execute '!' . escape(env . s:UserCommand(options, ['--no-pager'] + a:args), '!#%') .
                                    \ (&shell =~# 'csh' ? ' >& ' . temp : ' > ' . temp . ' 2>&1')
                              redraw!
                              let temp = s:Resolve(temp)
                              let first = join(readfile(temp, '', 2), "\n")
                              if first =~# '\<\([[:upper:][:digit:]_-]\+(\d\+)\).*\1'
                                let filetype = 'man'
                              else
                                let filetype = 'git'
                              endif
                              let s:temp_files[s:cpath(temp)] = { 'dir': options.dir, 'filetype': filetype }
                              if a:cmd ==# 'edit'
                                call s:BlurStatus()
                              endif
                              silent execute s:Mods(a:mods) . a:cmd temp
                              call fugitive#ReloadStatus(options.dir, 1)
                              return 'echo ' . string(':!' . s:UserCommand(options, a:args))
                            endfunction
                            
    1              0.000002 function! fugitive#Open(cmd, bang, mods, arg, args) abort
                              if a:bang
                                return s:OpenExec(a:cmd, a:mods, {}, s:SplitExpand(a:arg, s:Tree()))
                              endif
                            
                              let mods = s:Mods(a:mods)
                              try
                                let [file, pre] = s:OpenParse(a:args, 1)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if file !~# '^\a\a\+:'
                                let file = s:sub(file, '/$', '')
                              endif
                              if a:cmd ==# 'edit'
                                call s:BlurStatus()
                              endif
                              return mods . a:cmd . pre . ' ' . s:fnameescape(file)
                            endfunction
                            
    1              0.000002 function! s:ReadPrepare(line1, count, range, mods) abort
                              let mods = s:Mods(a:mods)
                              let after = a:count
                              if a:count < 0
                                let delete = 'silent 1,' . line('$') . 'delete_|'
                                let after = line('$')
                              elseif a:range == 2
                                let delete = 'silent ' . a:line1 . ',' . a:count . 'delete_|'
                              else
                                let delete = ''
                              endif
                              if foldlevel(after)
                                let pre = after . 'foldopen!|'
                              else
                                let pre = ''
                              endif
                              return [pre . mods . after . 'read', delete . '|diffupdate' . (a:count < 0 ? '|' . line('.') : '')]
                            endfunction
                            
    1              0.000003 function! s:ReadExec(line1, count, range, mods, env, args, options) abort
                              let [read, post] = s:ReadPrepare(a:line1, a:count, a:range, a:mods)
                              let env = s:BuildEnvPrefix(extend({'COLUMNS': &tw ? &tw : 80}, a:env))
                              silent execute read . '!' escape(env . s:UserCommand(a:options, ['--no-pager'] + a:args), '!#%')
                              execute post
                              call fugitive#ReloadStatus(a:options.dir, 1)
                              return 'redraw|echo '.string(':!'.s:UserCommand(a:options, a:args))
                            endfunction
                            
    1              0.000003 function! fugitive#ReadCommand(line1, count, range, bang, mods, arg, args) abort
                              if a:bang
                                let dir = s:Dir()
                                let args = s:SplitExpand(a:arg, s:Tree(dir))
                                return s:ReadExec(a:line1, a:count, a:range, a:mods, {}, args, {'dir': dir})
                              endif
                              let [read, post] = s:ReadPrepare(a:line1, a:count, a:range, a:mods)
                              try
                                let [file, pre] = s:OpenParse(a:args, 0)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if file =~# '^fugitive:' && a:count is# 0
                                return 'exe ' .string(s:Mods(a:mods) . fugitive#FileReadCmd(file, 0, pre)) . '|diffupdate'
                              endif
                              return read . ' ' . pre . ' ' . s:fnameescape(file) . '|' . post
                            endfunction
                            
    1              0.000002 function! fugitive#EditComplete(A, L, P) abort
                              if a:A =~# '^>'
                                return map(s:FilterEscape(s:CompleteHeads(s:Dir()), a:A[1:-1]), "'>' . v:val")
                              else
                                return fugitive#CompleteObject(a:A, a:L, a:P)
                              endif
                            endfunction
                            
    1              0.000002 function! fugitive#ReadComplete(A, L, P) abort
                              if a:L =~# '^\w\+!'
                                return fugitive#Complete(a:A, a:L, a:P)
                              else
                                return fugitive#EditComplete(a:A, a:L, a:P)
                              endif
                            endfunction
                            
                            " Section: :Gwrite, :Gwq
                            
    1              0.000002 function! fugitive#WriteCommand(line1, line2, range, bang, mods, arg, args) abort
                              if exists('b:fugitive_commit_arguments')
                                return 'write|bdelete'
                              elseif expand('%:t') == 'COMMIT_EDITMSG' && $GIT_INDEX_FILE != ''
                                return 'wq'
                              elseif get(b:, 'fugitive_type', '') ==# 'index'
                                return 'Git commit'
                              elseif &buftype ==# 'nowrite' && getline(4) =~# '^[+-]\{3\} '
                                return 'echoerr ' . string('fugitive: :Gwrite from :Git diff has been removed in favor of :Git add --edit')
                              endif
                              let mytab = tabpagenr()
                              let mybufnr = bufnr('')
                              try
                                let file = len(a:args) ? s:Generate(s:Expand(join(a:args, ' '))) : fugitive#Real(@%)
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if empty(file)
                                return 'echoerr '.string('fugitive: cannot determine file path')
                              endif
                              if file =~# '^fugitive:'
                                return 'write' . (a:bang ? '! ' : ' ') . s:fnameescape(file)
                              endif
                              exe s:DirCheck()
                              let always_permitted = s:cpath(fugitive#Real(@%), file) && empty(s:DirCommitFile(@%)[1])
                              if !always_permitted && !a:bang && (len(s:TreeChomp('diff', '--name-status', 'HEAD', '--', file)) || len(s:TreeChomp('ls-files', '--others', '--', file)))
                                let v:errmsg = 'fugitive: file has uncommitted changes (use ! to override)'
                                return 'echoerr v:errmsg'
                              endif
                              let treebufnr = 0
                              for nr in range(1,bufnr('$'))
                                if fnamemodify(bufname(nr),':p') ==# file
                                  let treebufnr = nr
                                endif
                              endfor
                            
                              if treebufnr > 0 && treebufnr != bufnr('')
                                let temp = tempname()
                                silent execute 'keepalt %write '.temp
                                for tab in [mytab] + range(1,tabpagenr('$'))
                                  for winnr in range(1,tabpagewinnr(tab,'$'))
                                    if tabpagebuflist(tab)[winnr-1] == treebufnr
                                      execute 'tabnext '.tab
                                      if winnr != winnr()
                                        execute winnr.'wincmd w'
                                        let restorewinnr = 1
                                      endif
                                      try
                                        let lnum = line('.')
                                        let last = line('$')
                                        silent execute '$read '.temp
                                        silent execute '1,'.last.'delete_'
                                        silent write!
                                        silent execute lnum
                                        diffupdate
                                        let did = 1
                                      finally
                                        if exists('restorewinnr')
                                          wincmd p
                                        endif
                                        execute 'tabnext '.mytab
                                      endtry
                                      break
                                    endif
                                  endfor
                                endfor
                                if !exists('did')
                                  call writefile(readfile(temp,'b'),file,'b')
                                endif
                              else
                                execute 'write! '.s:fnameescape(file)
                              endif
                            
                              if a:bang
                                let [error, exec_error] = s:ChompError(['add', '--force', '--', file])
                              else
                                let [error, exec_error] = s:ChompError(['add', '--', file])
                              endif
                              if exec_error
                                let v:errmsg = 'fugitive: '.error
                                return 'echoerr v:errmsg'
                              endif
                              if s:cpath(fugitive#Real(@%), file) && s:DirCommitFile(@%)[1] =~# '^\d$'
                                setlocal nomodified
                              endif
                            
                              let one = s:Generate(':1:'.file)
                              let two = s:Generate(':2:'.file)
                              let three = s:Generate(':3:'.file)
                              for nr in range(1,bufnr('$'))
                                let name = fnamemodify(bufname(nr), ':p')
                                if bufloaded(nr) && !getbufvar(nr,'&modified') && (name ==# one || name ==# two || name ==# three)
                                  execute nr.'bdelete'
                                endif
                              endfor
                            
                              unlet! restorewinnr
                              let zero = s:Generate(':0:'.file)
                              silent exe s:DoAutocmd('BufWritePost ' . s:fnameescape(zero))
                              for tab in range(1,tabpagenr('$'))
                                for winnr in range(1,tabpagewinnr(tab,'$'))
                                  let bufnr = tabpagebuflist(tab)[winnr-1]
                                  let bufname = fnamemodify(bufname(bufnr), ':p')
                                  if bufname ==# zero && bufnr != mybufnr
                                    execute 'tabnext '.tab
                                    if winnr != winnr()
                                      execute winnr.'wincmd w'
                                      let restorewinnr = 1
                                    endif
                                    try
                                      let lnum = line('.')
                                      let last = line('$')
                                      silent execute '$read '.s:fnameescape(file)
                                      silent execute '1,'.last.'delete_'
                                      silent execute lnum
                                      setlocal nomodified
                                      diffupdate
                                    finally
                                      if exists('restorewinnr')
                                        wincmd p
                                      endif
                                      execute 'tabnext '.mytab
                                    endtry
                                    break
                                  endif
                                endfor
                              endfor
                              call fugitive#ReloadStatus(-1, 1)
                              return 'checktime'
                            endfunction
                            
    1              0.000002 function! fugitive#WqCommand(...) abort
                              let bang = a:4 ? '!' : ''
                              if exists('b:fugitive_commit_arguments')
                                return 'wq'.bang
                              endif
                              let result = call('fugitive#WriteCommand', a:000)
                              if result =~# '^\%(write\|wq\|echoerr\)'
                                return s:sub(result,'^write','wq')
                              else
                                return result.'|quit'.bang
                              endif
                            endfunction
                            
                            " Section: :Git push, :Git fetch
                            
    1              0.000001 function! fugitive#PushComplete(A, L, P) abort
                              return s:CompleteSub('push', a:A, a:L, a:P, function('s:CompleteRemote'))
                            endfunction
                            
    1              0.000002 function! fugitive#FetchComplete(A, L, P) abort
                              return s:CompleteSub('fetch', a:A, a:L, a:P, function('s:CompleteRemote'))
                            endfunction
                            
    1              0.000001 function! s:AskPassArgs(dir) abort
                              if (len($DISPLAY) || len($TERM_PROGRAM) || has('gui_running')) && fugitive#GitVersion(1, 8) &&
                                    \ empty($GIT_ASKPASS) && empty($SSH_ASKPASS) && empty(get(fugitive#Config(a:dir), 'core.askpass', []))
                                if s:executable(s:ExecPath() . '/git-gui--askpass')
                                  return ['-c', 'core.askPass=' . s:ExecPath() . '/git-gui--askpass']
                                elseif s:executable('ssh-askpass')
                                  return ['-c', 'core.askPass=ssh-askpass']
                                endif
                              endif
                              return []
                            endfunction
                            
    1              0.000002 function! s:Dispatch(bang, options) abort
                              let dir = a:options.dir
                              exe s:DirCheck(dir)
                              let [mp, efm, cc] = [&l:mp, &l:efm, get(b:, 'current_compiler', '')]
                              try
                                let b:current_compiler = 'git'
                                let &l:errorformat = s:common_efm .
                                      \ ',%\&git_dir=' . escape(substitute(dir, '%', '%%', 'g'), '\,')
                                let &l:makeprg = s:UserCommand({'git': a:options.git, 'dir': dir}, s:AskPassArgs(dir) + a:options.flags + [a:options.command] + a:options.args)
                                if exists(':Make') == 2
                                  Make
                                  return ''
                                else
                                  if !has('patch-8.1.0334') && has('terminal') && &autowrite
                                    let autowrite_was_set = 1
                                    set noautowrite
                                    silent! wall
                                  endif
                                  silent noautocmd make!
                                  redraw!
                                  return 'call fugitive#Cwindow()|silent ' . s:DoAutocmd('ShellCmdPost')
                                endif
                              finally
                                let [&l:mp, &l:efm, b:current_compiler] = [mp, efm, cc]
                                if empty(cc) | unlet! b:current_compiler | endif
                                if exists('autowrite_was_set')
                                  set autowrite
                                endif
                              endtry
                            endfunction
                            
    1              0.000002 function! s:PushSubcommand(line1, line2, range, bang, mods, options) abort
                              return s:Dispatch(a:bang ? '!' : '', a:options)
                            endfunction
                            
    1              0.000002 function! s:FetchSubcommand(line1, line2, range, bang, mods, options) abort
                              return s:Dispatch(a:bang ? '!' : '', a:options)
                            endfunction
                            
                            " Section: :Gdiff
                            
    1              0.000002 augroup fugitive_diff
    1              0.000040   autocmd!
    1              0.000007   autocmd BufWinLeave *
                                    \ if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 2 |
                                    \   call s:diffoff_all(s:Dir(+expand('<abuf>'))) |
                                    \ endif
    1              0.000004   autocmd BufWinEnter *
                                    \ if s:can_diffoff(+expand('<abuf>')) && s:diff_window_count() == 1 |
                                    \   call s:diffoff() |
                                    \ endif
    1              0.000001 augroup END
                            
    1              0.000002 function! s:can_diffoff(buf) abort
                              return getwinvar(bufwinnr(a:buf), '&diff') &&
                                    \ !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))
                            endfunction
                            
    1              0.000002 function! fugitive#CanDiffoff(buf) abort
                              return s:can_diffoff(bufnr(a:buf))
                            endfunction
                            
    1              0.000001 function! s:diff_modifier(count) abort
                              let fdc = matchstr(&diffopt, 'foldcolumn:\zs\d\+')
                              if &diffopt =~# 'horizontal' && &diffopt !~# 'vertical'
                                return ''
                              elseif &diffopt =~# 'vertical'
                                return 'vertical '
                              elseif winwidth(0) <= a:count * ((&tw ? &tw : 80) + (empty(fdc) ? 2 : fdc))
                                return ''
                              else
                                return 'vertical '
                              endif
                            endfunction
                            
    1              0.000001 function! s:diff_window_count() abort
                              let c = 0
                              for nr in range(1,winnr('$'))
                                let c += getwinvar(nr,'&diff')
                              endfor
                              return c
                            endfunction
                            
    1              0.000001 function! s:diff_restore() abort
                              let restore = 'setlocal nodiff noscrollbind'
                                    \ . ' scrollopt=' . &l:scrollopt
                                    \ . (&l:wrap ? ' wrap' : ' nowrap')
                                    \ . ' foldlevel=999'
                                    \ . ' foldmethod=' . &l:foldmethod
                                    \ . ' foldcolumn=' . &l:foldcolumn
                                    \ . ' foldlevel=' . &l:foldlevel
                                    \ . (&l:foldenable ? ' foldenable' : ' nofoldenable')
                              if has('cursorbind')
                                let restore .= (&l:cursorbind ? ' ' : ' no') . 'cursorbind'
                              endif
                              return restore
                            endfunction
                            
    1              0.000002 function! s:diffthis() abort
                              if !&diff
                                let w:fugitive_diff_restore = s:diff_restore()
                                diffthis
                              endif
                            endfunction
                            
    1              0.000001 function! s:diffoff() abort
                              if exists('w:fugitive_diff_restore')
                                execute w:fugitive_diff_restore
                                unlet w:fugitive_diff_restore
                              else
                                diffoff
                              endif
                            endfunction
                            
    1              0.000001 function! s:diffoff_all(dir) abort
                              let curwin = winnr()
                              for nr in range(1,winnr('$'))
                                if getwinvar(nr, '&diff') && !empty(getwinvar(nr, 'fugitive_diff_restore'))
                                  if nr != winnr()
                                    execute nr.'wincmd w'
                                  endif
                                  call s:diffoff()
                                endif
                              endfor
                              execute curwin.'wincmd w'
                            endfunction
                            
    1              0.000002 function! s:CompareAge(mine, theirs) abort
                              let scores = {':0': 1, ':1': 2, ':2': 3, ':': 4, ':3': 5}
                              let mine = substitute(a:mine, '^:', '', '')
                              let theirs = substitute(a:theirs, '^:', '', '')
                              let my_score    = get(scores, ':'.mine, 0)
                              let their_score = get(scores, ':'.theirs, 0)
                              if my_score || their_score
                                return my_score < their_score ? -1 : my_score != their_score
                              elseif mine ==# theirs
                                return 0
                              endif
                              let base = s:TreeChomp('merge-base', mine, theirs)
                              if base ==# mine
                                return -1
                              elseif base ==# theirs
                                return 1
                              endif
                              let my_time    = +s:TreeChomp('log', '--max-count=1', '--pretty=format:%at', a:mine, '--')
                              let their_time = +s:TreeChomp('log', '--max-count=1', '--pretty=format:%at', a:theirs, '--')
                              return my_time < their_time ? -1 : my_time != their_time
                            endfunction
                            
    1              0.000002 function! s:IsConflicted() abort
                              return len(@%) && !empty(s:ChompDefault('', 'ls-files', '--unmerged', '--', expand('%:p')))
                            endfunction
                            
    1              0.000002 function! fugitive#Diffsplit(autodir, keepfocus, mods, arg, args) abort
                              let args = copy(a:args)
                              let post = ''
                              if get(args, 0) =~# '^+'
                                let post = remove(args, 0)[1:-1]
                              endif
                              if exists(':DiffGitCached') && empty(args)
                                return s:Mods(a:mods) . 'DiffGitCached' . (len(post) ? '|' . post : '')
                              endif
                              let commit = s:DirCommitFile(@%)[1]
                              if a:mods =~# '\<tab\>'
                                let mods = substitute(a:mods, '\<tab\>', '', 'g')
                                let pre = 'tab split'
                              else
                                let mods = 'keepalt ' . a:mods
                                let pre = ''
                              endif
                              let back = exists('*win_getid') ? 'call win_gotoid(' . win_getid() . ')' : 'wincmd p'
                              if (empty(args) || args[0] ==# ':') && a:keepfocus
                                exe s:DirCheck()
                                if empty(commit) && s:IsConflicted()
                                  let parents = [s:Relative(':2:'), s:Relative(':3:')]
                                elseif empty(commit)
                                  let parents = [s:Relative(':0:')]
                                elseif commit =~# '^\d\=$'
                                  let parents = [s:Relative('HEAD:')]
                                elseif commit =~# '^\x\x\+$'
                                  let parents = s:LinesError(['rev-parse', commit . '^@'])[0]
                                  call map(parents, 's:Relative(v:val . ":")')
                                endif
                              endif
                              try
                                if exists('parents') && len(parents) > 1
                                  exe pre
                                  let mods = (a:autodir ? s:diff_modifier(len(parents) + 1) : '') . s:Mods(mods, 'leftabove')
                                  let nr = bufnr('')
                                  execute mods 'split' s:fnameescape(s:Generate(parents[0]))
                                  call s:Map('n', 'dp', ':diffput '.nr.'<Bar>diffupdate<CR>', '<silent>')
                                  let nr2 = bufnr('')
                                  call s:diffthis()
                                  exe back
                                  call s:Map('n', 'd2o', ':diffget '.nr2.'<Bar>diffupdate<CR>', '<silent>')
                                  let mods = substitute(mods, '\Cleftabove\|rightbelow\|aboveleft\|belowright', '\=submatch(0) =~# "f" ? "rightbelow" : "leftabove"', '')
                                  for i in range(len(parents)-1, 1, -1)
                                    execute mods 'split' s:fnameescape(s:Generate(parents[i]))
                                    call s:Map('n', 'dp', ':diffput '.nr.'<Bar>diffupdate<CR>', '<silent>')
                                    let nrx = bufnr('')
                                    call s:diffthis()
                                    exe back
                                    call s:Map('n', 'd' . (i + 2) . 'o', ':diffget '.nrx.'<Bar>diffupdate<CR>', '<silent>')
                                  endfor
                                  call s:diffthis()
                                  if len(parents) > 1
                                    wincmd =
                                  endif
                                  return post
                                elseif len(args)
                                  let arg = join(args, ' ')
                                  if arg ==# ''
                                    return post
                                  elseif arg ==# ':/'
                                    exe s:DirCheck()
                                    let file = s:Relative()
                                  elseif arg ==# ':'
                                    exe s:DirCheck()
                                    let file = s:Relative(':0:')
                                  elseif arg =~# '^:\d$'
                                    exe s:DirCheck()
                                    let file = s:Relative(arg . ':')
                                  elseif arg =~# '^[~^]\d*$'
                                    return 'echoerr ' . string('fugitive: change ' . arg . ' to !' . arg . ' to diff against ancestor')
                                  else
                                    try
                                      let file = arg =~# '^:/.' ? fugitive#RevParse(arg) . s:Relative(':') : s:Expand(arg)
                                    catch /^fugitive:/
                                      return 'echoerr ' . string(v:exception)
                                    endtry
                                  endif
                                elseif exists('parents') && len(parents)
                                  let file = parents[-1]
                                elseif len(commit)
                                  let file = s:Relative()
                                elseif s:IsConflicted()
                                  let file = s:Relative(':1:')
                                  let post = 'echohl WarningMsg|echo "Use :Gdiffsplit! for 3 way diff"|echohl NONE|' . post
                                else
                                  exe s:DirCheck()
                                  let file = s:Relative(':0:')
                                endif
                                let spec = s:Generate(file)
                                if spec =~# '^fugitive:' && empty(s:DirCommitFile(spec)[2])
                                  let spec = FugitiveVimPath(spec . s:Relative('/'))
                                endif
                                exe pre
                                let restore = s:diff_restore()
                                let w:fugitive_diff_restore = restore
                                if len(spec) && s:CompareAge(commit, s:DirCommitFile(spec)[1]) < 0
                                  let mods = s:Mods(mods, 'rightbelow')
                                else
                                  let mods = s:Mods(mods, 'leftabove')
                                endif
                                let mods = (a:autodir ? s:diff_modifier(2) : '') . mods
                                if &diffopt =~# 'vertical'
                                  let diffopt = &diffopt
                                  set diffopt-=vertical
                                endif
                                execute mods 'diffsplit' s:fnameescape(spec)
                                let &l:readonly = &l:readonly
                                redraw
                                let w:fugitive_diff_restore = restore
                                let winnr = winnr()
                                if getwinvar('#', '&diff')
                                  if a:keepfocus
                                    exe back
                                  endif
                                endif
                                return post
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              finally
                                if exists('diffopt')
                                  let &diffopt = diffopt
                                endif
                              endtry
                            endfunction
                            
                            " Section: :Gmove, :Gremove
                            
    1              0.000002 function! s:Move(force, rename, destination) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              if s:DirCommitFile(@%)[1] !~# '^0\=$' || empty(@%)
                                return 'echoerr ' . string('fugitive: mv not supported for this buffer')
                              endif
                              if a:destination =~# '^\a\+:\|^/'
                                let destination = a:destination
                              elseif a:destination =~# '^:/:\='
                                let destination = s:Tree(dir) . substitute(a:destination, '^:/:\=', '', '')
                              elseif a:destination =~# '^:(\%(top\|top,literal\|literal,top\))'
                                let destination = s:Tree(dir) . matchstr(a:destination, ')\zs.*')
                              elseif a:destination =~# '^:(literal)'
                                let destination = simplify(getcwd() . '/' . matchstr(a:destination, ')\zs.*'))
                              elseif a:rename
                                let destination = simplify(expand('%:p:s?[\/]$??:h') . '/' . a:destination)
                              elseif a:destination =~# '^\.\.\=\%(/\|$\)'
                                let destination = simplify(getcwd() . '/' . a:destination)
                              else
                                let destination = s:Tree(dir) . '/' . a:destination
                              endif
                              let destination = s:Slash(destination)
                              if isdirectory(@%)
                                setlocal noswapfile
                              endif
                              let [message, exec_error] = s:ChompError(['mv'] + (a:force ? ['-f'] : []) + ['--', expand('%:p'), destination], dir)
                              if exec_error
                                let v:errmsg = 'fugitive: '.message
                                return 'echoerr v:errmsg'
                              endif
                              if isdirectory(destination)
                                let destination = fnamemodify(s:sub(destination,'/$','').'/'.expand('%:t'),':.')
                              endif
                              let reload = '|call fugitive#ReloadStatus(' . string(dir) . ', 1)'
                              if empty(s:DirCommitFile(@%)[1])
                                if isdirectory(destination)
                                  return 'keepalt edit '.s:fnameescape(destination) . reload
                                else
                                  return 'keepalt saveas! '.s:fnameescape(destination) . reload
                                endif
                              else
                                return 'file '.s:fnameescape(fugitive#Find(':0:'.destination, dir)) . reload
                              endif
                            endfunction
                            
    1              0.000002 function! fugitive#RenameComplete(A,L,P) abort
                              if a:A =~# '^[.:]\=/'
                                return fugitive#CompletePath(a:A)
                              else
                                let pre = s:Slash(fnamemodify(expand('%:p:s?[\/]$??'), ':h')) . '/'
                                return map(fugitive#CompletePath(pre.a:A), 'strpart(v:val, len(pre))')
                              endif
                            endfunction
                            
    1              0.000002 function! fugitive#MoveCommand(line1, line2, range, bang, mods, arg, args) abort
                              return s:Move(a:bang, 0, a:arg)
                            endfunction
                            
    1              0.000002 function! fugitive#RenameCommand(line1, line2, range, bang, mods, arg, args) abort
                              return s:Move(a:bang, 1, a:arg)
                            endfunction
                            
    1              0.000002 function! s:Remove(after, force) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              if len(@%) && s:DirCommitFile(@%)[1] ==# ''
                                let cmd = ['rm']
                              elseif s:DirCommitFile(@%)[1] ==# '0'
                                let cmd = ['rm','--cached']
                              else
                                return 'echoerr ' . string('fugitive: rm not supported for this buffer')
                              endif
                              if a:force
                                let cmd += ['--force']
                              endif
                              let [message, exec_error] = s:ChompError(cmd + ['--', expand('%:p')], dir)
                              if exec_error
                                let v:errmsg = 'fugitive: '.s:sub(message,'error:.*\zs\n\(.*-f.*',' (add ! to force)')
                                return 'echoerr '.string(v:errmsg)
                              else
                                return a:after . (a:force ? '!' : ''). '|call fugitive#ReloadStatus(' . string(dir) . ', 1)'
                              endif
                            endfunction
                            
    1              0.000003 function! fugitive#RemoveCommand(line1, line2, range, bang, mods, arg, args) abort
                              return s:Remove('edit', a:bang)
                            endfunction
                            
    1              0.000003 function! fugitive#DeleteCommand(line1, line2, range, bang, mods, arg, args) abort
                              return s:Remove('bdelete', a:bang)
                            endfunction
                            
                            " Section: :Git blame
                            
    1              0.000002 function! s:Keywordprg() abort
                              let args = ' --git-dir='.escape(s:Dir(),"\\\"' ")
                              if has('gui_running') && !has('win32')
                                return g:fugitive_git_executable . ' --no-pager' . args . ' log -1'
                              else
                                return g:fugitive_git_executable . args . ' show'
                              endif
                            endfunction
                            
    1              0.000002 function! s:linechars(pattern) abort
                              let chars = strlen(s:gsub(matchstr(getline('.'), a:pattern), '.', '.'))
                              if exists('*synconcealed') && &conceallevel > 1
                                for col in range(1, chars)
                                  let chars -= synconcealed(line('.'), col)[0]
                                endfor
                              endif
                              return chars
                            endfunction
                            
    1              0.000001 function! s:BlameBufnr(...) abort
                              let state = s:TempState(bufname(a:0 ? a:1 : ''))
                              if get(state, 'filetype', '') ==# 'fugitiveblame'
                                return get(state, 'bufnr', -1)
                              else
                                return -1
                              endif
                            endfunction
                            
    1              0.000002 function! s:BlameCommitFileLnum(...) abort
                              let line = a:0 ? a:1 : getline('.')
                              let state = a:0 ? a:2 : s:TempState()
                              let commit = matchstr(line, '^\^\=\zs\x\+')
                              if commit =~# '^0\+$'
                                let commit = ''
                              elseif has_key(state, 'blame_reverse_end')
                                let commit = get(s:LinesError(state.dir, 'rev-list', '--ancestry-path', '--reverse', commit . '..' . state.blame_reverse_end)[0], 0, '')
                              endif
                              let lnum = +matchstr(line, ' \zs\d\+\ze \%((\| *\d\+)\)')
                              let path = matchstr(line, '^\^\=[?*]*\x* \+\%(\d\+ \+\d\+ \+\)\=\zs.\{-\}\ze\s*\d\+ \%((\| *\d\+)\)')
                              if empty(path) && lnum
                                let path = get(state, 'blame_file', '')
                              endif
                              return [commit, path, lnum]
                            endfunction
                            
    1              0.000002 function! s:BlameLeave() abort
                              let bufwinnr = bufwinnr(s:BlameBufnr())
                              if bufwinnr > 0
                                let bufnr = bufnr('')
                                exe bufwinnr . 'wincmd w'
                                return bufnr . 'bdelete'
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! s:BlameQuit() abort
                              let cmd = s:BlameLeave()
                              if empty(cmd)
                                return 'bdelete'
                              elseif len(s:DirCommitFile(@%)[1])
                                return cmd . '|Gedit'
                              else
                                return cmd
                              endif
                            endfunction
                            
    1              0.000002 function! fugitive#BlameComplete(A, L, P) abort
                              return s:CompleteSub('blame', a:A, a:L, a:P)
                            endfunction
                            
    1              0.000002 function! s:BlameSubcommand(line1, count, range, bang, mods, options) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              let flags = copy(a:options.args)
                              let i = 0
                              let raw = 0
                              let commits = []
                              let files = []
                              let ranges = []
                              if a:line1 > 0 && a:count > 0 && a:range != 1
                                call extend(ranges, ['-L', a:line1 . ',' . a:count])
                              endif
                              while i < len(flags)
                                let match = matchlist(flags[i], '^\(-[a-zABDFH-KN-RT-Z]\)\ze\(.*\)')
                                if len(match) && len(match[2])
                                  call insert(flags, match[1])
                                  let flags[i+1] = '-' . match[2]
                                  continue
                                endif
                                let arg = flags[i]
                                if arg =~# '^-p$\|^--\%(help\|porcelain\|line-porcelain\|incremental\)$'
                                  let raw = 1
                                elseif arg ==# '--contents' && i + 1 < len(flags)
                                  call extend(commits, remove(flags, i, i+1))
                                  continue
                                elseif arg ==# '-L' && i + 1 < len(flags)
                                  call extend(ranges, remove(flags, i, i+1))
                                  continue
                                elseif arg =~# '^--contents='
                                  call add(commits, remove(flags, i))
                                  continue
                                elseif arg =~# '^-L.'
                                  call add(ranges, remove(flags, i))
                                  continue
                                elseif arg =~# '^-[GLS]$\|^--\%(date\|encoding\|contents\|ignore-rev\|ignore-revs-file\)$'
                                  let i += 1
                                  if i == len(flags)
                                    echohl ErrorMsg
                                    echo s:ChompError(['blame', arg])[0]
                                    echohl NONE
                                    return ''
                                  endif
                                elseif arg ==# '--'
                                  if i + 1 < len(flags)
                                    call extend(files, remove(flags, i + 1, -1))
                                  endif
                                  call remove(flags, i)
                                  break
                                elseif arg !~# '^-' && (s:HasOpt(flags, '--not') || arg !~# '^\^')
                                  if index(flags, '--') >= 0
                                    call add(commits, remove(flags, i))
                                    continue
                                  endif
                                  if arg =~# '\.\.' && arg !~# '^\.\.\=\%(/\|$\)' && empty(commits)
                                    call add(commits, remove(flags, i))
                                    continue
                                  endif
                                  try
                                    let dcf = s:DirCommitFile(fugitive#Find(arg, dir))
                                    if len(dcf[1]) && empty(dcf[2])
                                      call add(commits, remove(flags, i))
                                      continue
                                    endif
                                  catch /^fugitive:/
                                  endtry
                                  call add(files, remove(flags, i))
                                  continue
                                endif
                                let i += 1
                              endwhile
                              let file = substitute(get(files, 0, get(s:TempState(), 'blame_file', s:Relative('./', dir))), '^\.\%(/\|$\)', '', '')
                              if empty(commits) && len(files) > 1
                                call add(commits, remove(files, 1))
                              endif
                              exe s:BlameLeave()
                              try
                                let cmd = a:options.flags + ['--no-pager', '-c', 'blame.coloring=none', '-c', 'blame.blankBoundary=false', a:options.command, '--show-number']
                                call extend(cmd, filter(copy(flags), 'v:val !~# "\\v^%(-b|--%(no-)=color-.*|--progress)$"'))
                                if a:count > 0 && empty(ranges)
                                  let cmd += ['-L', (a:line1 ? a:line1 : line('.')) . ',' . (a:line1 ? a:line1 : line('.'))]
                                endif
                                call extend(cmd, ranges)
                                if len(commits)
                                  let cmd += commits
                                elseif empty(files) && len(matchstr(s:DirCommitFile(@%)[1], '^\x\x\+$'))
                                  let cmd += [matchstr(s:DirCommitFile(@%)[1], '^\x\x\+$')]
                                elseif empty(files) && !s:HasOpt(flags, '--reverse')
                                  let cmd += ['--contents', '-']
                                endif
                                let basecmd = escape(s:UserCommand({'git': a:options.git, 'dir': dir}, cmd + ['--'] + (len(files) ? files : [file])), '!#%')
                                let tempname = tempname()
                                let error = tempname . '.err'
                                let temp = tempname . (raw ? '' : '.fugitiveblame')
                                if &shell =~# 'csh'
                                  silent! execute '%write !('.basecmd.' > '.temp.') >& '.error
                                else
                                  silent! execute '%write !'.basecmd.' > '.temp.' 2> '.error
                                endif
                                let l:shell_error = v:shell_error
                                redraw
                                try
                                  if l:shell_error
                                    let lines = readfile(error)
                                    if empty(lines)
                                      let lines = readfile(temp)
                                    endif
                                    for i in range(len(lines))
                                      if lines[i] =~# '^error: \|^fatal: '
                                        echohl ErrorMsg
                                        echon lines[i]
                                        echohl NONE
                                        break
                                      else
                                        echon lines[i]
                                      endif
                                      if i != len(lines) - 1
                                        echon "\n"
                                      endif
                                    endfor
                                    return ''
                                  endif
                                  let temp_state = {'dir': dir, 'filetype': (raw ? '' : 'fugitiveblame'), 'options': a:options, 'blame_flags': flags, 'blame_file': file}
                                  if s:HasOpt(flags, '--reverse')
                                    let temp_state.blame_reverse_end = matchstr(get(commits, 0, ''), '\.\.\zs.*')
                                  endif
                                  if (a:line1 == 0 || a:range == 1) && a:count > 0
                                    let edit = s:Mods(a:mods) . get(['edit', 'split', 'pedit', 'vsplit', 'tabedit'], a:count - (a:line1 ? a:line1 : 1), 'split')
                                    return s:BlameCommit(edit, get(readfile(temp), 0, ''), temp_state)
                                  else
                                    let temp = s:Resolve(temp)
                                    let s:temp_files[s:cpath(temp)] = temp_state
                                    if len(ranges + commits + files) || raw
                                      let mods = s:Mods(a:mods)
                                      if a:count != 0
                                        exe 'silent keepalt' mods 'split' s:fnameescape(temp)
                                      elseif !&modified || a:bang || &bufhidden ==# 'hide' || (empty(&bufhidden) && &hidden)
                                        exe 'silent' mods 'edit' . (a:bang ? '! ' : ' ') . s:fnameescape(temp)
                                      else
                                        return mods . 'edit ' . s:fnameescape(temp)
                                      endif
                                      return ''
                                    endif
                                    if a:mods =~# '\<tab\>'
                                      silent tabedit %
                                    endif
                                    let bufnr = bufnr('')
                                    let temp_state.bufnr = bufnr
                                    let restore = []
                                    let mods = substitute(a:mods, '\<tab\>', '', 'g')
                                    for winnr in range(winnr('$'),1,-1)
                                      if getwinvar(winnr, '&scrollbind')
                                        if !&l:scrollbind
                                          call setwinvar(winnr, '&scrollbind', 0)
                                        elseif winnr != winnr() && getwinvar(winnr, '&foldenable')
                                          call setwinvar(winnr, '&foldenable', 0)
                                          call add(restore, 'call setwinvar(bufwinnr('.winbufnr(winnr).'),"&foldenable",1)')
                                        endif
                                      endif
                                      if exists('+cursorbind') && !&l:cursorbind && getwinvar(winnr, '&cursorbind')
                                        call setwinvar(winnr, '&cursorbind', 0)
                                      endif
                                      if s:BlameBufnr(winbufnr(winnr)) > 0
                                        execute winbufnr(winnr).'bdelete'
                                      endif
                                    endfor
                                    let restore_winnr = 'bufwinnr(' . bufnr . ')'
                                    if !&l:scrollbind
                                      call add(restore, 'call setwinvar(' . restore_winnr . ',"&scrollbind",0)')
                                    endif
                                    if exists('+cursorbind') && !&l:cursorbind
                                      call add(restore, 'call setwinvar(' . restore_winnr . ',"&cursorbind",0)')
                                    endif
                                    if &l:wrap
                                      call add(restore, 'call setwinvar(' . restore_winnr . ',"&wrap",1)')
                                    endif
                                    if &l:foldenable
                                      call add(restore, 'call setwinvar(' . restore_winnr . ',"&foldenable",1)')
                                    endif
                                    setlocal scrollbind nowrap nofoldenable
                                    if exists('+cursorbind')
                                      setlocal cursorbind
                                    endif
                                    let top = line('w0') + &scrolloff
                                    let current = line('.')
                                    exe 'silent keepalt' (a:bang ? s:Mods(mods) . 'split' : s:Mods(mods, 'leftabove') . 'vsplit') s:fnameescape(temp)
                                    let w:fugitive_leave = join(restore, '|')
                                    execute top
                                    normal! zt
                                    execute current
                                    if exists('+cursorbind')
                                      setlocal cursorbind
                                    endif
                                    setlocal nonumber scrollbind nowrap foldcolumn=0 nofoldenable winfixwidth
                                    if exists('+relativenumber')
                                      setlocal norelativenumber
                                    endif
                                    if exists('+signcolumn')
                                      setlocal signcolumn=no
                                    endif
                                    execute "vertical resize ".(s:linechars('.\{-\}\ze\s\+\d\+)')+1)
                                    call s:Map('n', 'A', ":<C-u>exe 'vertical resize '.(<SID>linechars('.\\{-\\}\\ze [0-9:/+-][0-9:/+ -]* \\d\\+)')+1+v:count)<CR>", '<silent>')
                                    call s:Map('n', 'C', ":<C-u>exe 'vertical resize '.(<SID>linechars('^\\S\\+')+1+v:count)<CR>", '<silent>')
                                    call s:Map('n', 'D', ":<C-u>exe 'vertical resize '.(<SID>linechars('.\\{-\\}\\ze\\d\\ze\\s\\+\\d\\+)')+1-v:count)<CR>", '<silent>')
                                    redraw
                                    syncbind
                                  endif
                                endtry
                                return ''
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction
                            
    1              0.000002 function! s:BlameCommit(cmd, ...) abort
                              let line = a:0 ? a:1 : getline('.')
                              let state = a:0 ? a:2 : s:TempState()
                              let sigil = has_key(state, 'blame_reverse_end') ? '-' : '+'
                              let mods = (s:BlameBufnr() < 0 ? '' : &splitbelow ? "botright " : "topleft ")
                              let [commit, path, lnum] = s:BlameCommitFileLnum(line, state)
                              if empty(commit) && len(path) && has_key(state, 'blame_reverse_end')
                                let path = (len(state.blame_reverse_end) ? state.blame_reverse_end . ':' : ':(top)') . path
                                return fugitive#Open(mods . a:cmd, 0, '', '+' . lnum . ' ' . s:fnameescape(path), ['+' . lnum, path])
                              endif
                              if commit =~# '^0*$'
                                return 'echoerr ' . string('fugitive: no commit')
                              endif
                              if line =~# '^\^' && !has_key(state, 'blame_reverse_end')
                                let path = commit . ':' . path
                                return fugitive#Open(mods . a:cmd, 0, '', '+' . lnum . ' ' . s:fnameescape(path), ['+' . lnum, path])
                              endif
                              let cmd = fugitive#Open(mods . a:cmd, 0, '', commit, [commit])
                              if cmd =~# '^echoerr'
                                return cmd
                              endif
                              execute cmd
                              if a:cmd ==# 'pedit' || empty(path)
                                return ''
                              endif
                              if search('^diff .* b/\M'.escape(path,'\').'$','W')
                                call search('^+++')
                                let head = line('.')
                                while search('^@@ \|^diff ') && getline('.') =~# '^@@ '
                                  let top = +matchstr(getline('.'),' ' . sigil .'\zs\d\+')
                                  let len = +matchstr(getline('.'),' ' . sigil . '\d\+,\zs\d\+')
                                  if lnum >= top && lnum <= top + len
                                    let offset = lnum - top
                                    if &scrolloff
                                      +
                                      normal! zt
                                    else
                                      normal! zt
                                      +
                                    endif
                                    while offset > 0 && line('.') < line('$')
                                      +
                                      if getline('.') =~# '^[ ' . sigil . ']'
                                        let offset -= 1
                                      endif
                                    endwhile
                                    return 'normal! zv'
                                  endif
                                endwhile
                                execute head
                                normal! zt
                              endif
                              return ''
                            endfunction
                            
    1              0.000001 function! s:BlameJump(suffix, ...) abort
                              let suffix = a:suffix
                              let [commit, path, lnum] = s:BlameCommitFileLnum()
                              if empty(path)
                                return 'echoerr ' . string('fugitive: could not determine filename for blame')
                              endif
                              if commit =~# '^0*$'
                                let commit = 'HEAD'
                                let suffix = ''
                              endif
                              let offset = line('.') - line('w0')
                              let state = s:TempState()
                              let flags = get(state, 'blame_flags', [])
                              if a:0 && a:1
                                if s:HasOpt(flags, '--reverse')
                                  call remove(flags, '--reverse')
                                else
                                  call add(flags, '--reverse')
                                endif
                              endif
                              let blame_bufnr = s:BlameBufnr()
                              if blame_bufnr > 0
                                let bufnr = bufnr('')
                                let winnr = bufwinnr(blame_bufnr)
                                if winnr > 0
                                  exe winnr.'wincmd w'
                                  exe bufnr.'bdelete'
                                endif
                                execute 'Gedit' s:fnameescape(commit . suffix . ':' . path)
                                execute lnum
                              endif
                              let my_bufnr = bufnr('')
                              if blame_bufnr < 0
                                let blame_args = flags + [commit . suffix, '--', path]
                                let result = s:BlameSubcommand(0, 0, 0, 0, '', extend({'args': blame_args}, state.options, 'keep'))
                              else
                                let blame_args = flags
                                let result = s:BlameSubcommand(-1, -1, 0, 0, '', extend({'args': blame_args}, state.options, 'keep'))
                              endif
                              if bufnr('') == my_bufnr
                                return result
                              endif
                              execute result
                              execute lnum
                              let delta = line('.') - line('w0') - offset
                              if delta > 0
                                execute 'normal! '.delta."\<C-E>"
                              elseif delta < 0
                                execute 'normal! '.(-delta)."\<C-Y>"
                              endif
                              keepjumps syncbind
                              redraw
                              echo ':Git blame' s:fnameescape(blame_args)
                              return ''
                            endfunction
                            
    1              0.000003 let s:hash_colors = {}
                            
    1              0.000002 function! fugitive#BlameSyntax() abort
                              let conceal = has('conceal') ? ' conceal' : ''
                              let config = fugitive#Config()
                              let flags = get(s:TempState(), 'blame_flags', [])
                              syn match FugitiveblameBlank                      "^\s\+\s\@=" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalFile,FugitiveblameOriginalLineNumber skipwhite
                              syn match FugitiveblameHash       "\%(^\^\=[?*]*\)\@<=\<\x\{7,\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalLineNumber,FugitiveblameOriginalFile skipwhite
                              syn match FugitiveblameUncommitted "\%(^\^\=\)\@<=\<0\{7,\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalLineNumber,FugitiveblameOriginalFile skipwhite
                              if get(get(config, 'blame.blankboundary', ['x']), 0, 'x') =~# '^$\|^true$' || s:HasOpt(flags, '-b')
                                syn match FugitiveblameBoundaryIgnore "^\^[*?]*\x\{7,\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameScoreDebug,FugitiveblameOriginalLineNumber,FugitiveblameOriginalFile skipwhite
                              else
                                syn match FugitiveblameBoundary "^\^"
                              endif
                              syn match FugitiveblameScoreDebug        " *\d\+\s\+\d\+\s\@=" nextgroup=FugitiveblameAnnotation,FugitiveblameOriginalLineNumber,fugitiveblameOriginalFile contained skipwhite
                              syn region FugitiveblameAnnotation matchgroup=FugitiveblameDelimiter start="(" end="\%(\s\d\+\)\@<=)" contained keepend oneline
                              syn match FugitiveblameTime "[0-9:/+-][0-9:/+ -]*[0-9:/+-]\%(\s\+\d\+)\)\@=" contained containedin=FugitiveblameAnnotation
                              exec 'syn match FugitiveblameLineNumber         "\s*\d\+)\@=" contained containedin=FugitiveblameAnnotation' conceal
                              exec 'syn match FugitiveblameOriginalFile       "\s\%(\f\+\D\@<=\|\D\@=\f\+\)\%(\%(\s\+\d\+\)\=\s\%((\|\s*\d\+)\)\)\@=" contained nextgroup=FugitiveblameOriginalLineNumber,FugitiveblameAnnotation skipwhite' (s:HasOpt(flags, '--show-name', '-f') ? '' : conceal)
                              exec 'syn match FugitiveblameOriginalLineNumber "\s*\d\+\%(\s(\)\@=" contained nextgroup=FugitiveblameAnnotation skipwhite' (s:HasOpt(flags, '--show-number', '-n') ? '' : conceal)
                              exec 'syn match FugitiveblameOriginalLineNumber "\s*\d\+\%(\s\+\d\+)\)\@=" contained nextgroup=FugitiveblameShort skipwhite' (s:HasOpt(flags, '--show-number', '-n') ? '' : conceal)
                              syn match FugitiveblameShort              " \d\+)" contained contains=FugitiveblameLineNumber
                              syn match FugitiveblameNotCommittedYet "(\@<=Not Committed Yet\>" contained containedin=FugitiveblameAnnotation
                              hi def link FugitiveblameBoundary           Keyword
                              hi def link FugitiveblameHash               Identifier
                              hi def link FugitiveblameBoundaryIgnore     Ignore
                              hi def link FugitiveblameUncommitted        Ignore
                              hi def link FugitiveblameScoreDebug         Debug
                              hi def link FugitiveblameTime               PreProc
                              hi def link FugitiveblameLineNumber         Number
                              hi def link FugitiveblameOriginalFile       String
                              hi def link FugitiveblameOriginalLineNumber Float
                              hi def link FugitiveblameShort              FugitiveblameDelimiter
                              hi def link FugitiveblameDelimiter          Delimiter
                              hi def link FugitiveblameNotCommittedYet    Comment
                              if !get(g:, 'fugitive_dynamic_colors', 1) && !s:HasOpt(flags, '--color-lines') || s:HasOpt(flags, '--no-color-lines')
                                return
                              endif
                              let seen = {}
                              for lnum in range(1, line('$'))
                                let hash = matchstr(getline(lnum), '^\^\=\zs\x\{6\}')
                                if hash ==# '' || hash ==# '000000' || has_key(seen, hash)
                                  continue
                                endif
                                let seen[hash] = 1
                                if &t_Co > 16 && get(g:, 'CSApprox_loaded') && !empty(findfile('autoload/csapprox/per_component.vim', escape(&rtp, ' ')))
                                      \ && empty(get(s:hash_colors, hash))
                                  let [s, r, g, b; __] = map(matchlist(hash, '\(\x\x\)\(\x\x\)\(\x\x\)'), 'str2nr(v:val,16)')
                                  let color = csapprox#per_component#Approximate(r, g, b)
                                  if color == 16 && &background ==# 'dark'
                                    let color = 8
                                  endif
                                  let s:hash_colors[hash] = ' ctermfg='.color
                                else
                                  let s:hash_colors[hash] = ''
                                endif
                                exe 'syn match FugitiveblameHash'.hash.'       "\%(^\^\=\)\@<='.hash.'\x\{1,34\}\>" nextgroup=FugitiveblameAnnotation,FugitiveblameOriginalLineNumber,fugitiveblameOriginalFile skipwhite'
                              endfor
                              call s:BlameRehighlight()
                            endfunction
                            
    1              0.000002 function! s:BlameRehighlight() abort
                              for [hash, cterm] in items(s:hash_colors)
                                if !empty(cterm) || has('gui_running') || has('termguicolors') && &termguicolors
                                  exe 'hi FugitiveblameHash'.hash.' guifg=#'.hash.get(s:hash_colors, hash, '')
                                else
                                  exe 'hi link FugitiveblameHash'.hash.' Identifier'
                                endif
                              endfor
                            endfunction
                            
    1              0.000002 function! s:BlameFileType() abort
                              setlocal nomodeline
                              setlocal foldmethod=manual
                              if len(s:Dir())
                                let &l:keywordprg = s:Keywordprg()
                              endif
                              let b:undo_ftplugin = 'setl keywordprg= foldmethod<'
                              if exists('+concealcursor')
                                setlocal concealcursor=nc conceallevel=2
                                let b:undo_ftplugin .= ' concealcursor< conceallevel<'
                              endif
                              if &modifiable
                                return ''
                              endif
                              call s:Map('n', '<F1>', ':help :Git_blame<CR>', '<silent>')
                              call s:Map('n', 'g?',   ':help :Git_blame<CR>', '<silent>')
                              if mapcheck('q', 'n') =~# '^$\|bdelete'
                                call s:Map('n', 'q',  ':exe <SID>BlameQuit()<Bar>echohl WarningMsg<Bar>echo ":Git blame q is deprecated in favor of gq"<Bar>echohl NONE<CR>', '<silent>')
                              endif
                              call s:Map('n', 'gq',   ':exe <SID>BlameQuit()<CR>', '<silent>')
                              call s:Map('n', '<2-LeftMouse>', ':<C-U>exe <SID>BlameCommit("exe <SID>BlameLeave()<Bar>edit")<CR>', '<silent>')
                              call s:Map('n', '<CR>', ':<C-U>exe <SID>BlameCommit("exe <SID>BlameLeave()<Bar>edit")<CR>', '<silent>')
                              call s:Map('n', '-',    ':<C-U>exe <SID>BlameJump("")<CR>', '<silent>')
                              call s:Map('n', 'P',    ':<C-U>exe <SID>BlameJump("^".v:count1)<CR>', '<silent>')
                              call s:Map('n', '~',    ':<C-U>exe <SID>BlameJump("~".v:count1)<CR>', '<silent>')
                              call s:Map('n', 'i',    ':<C-U>exe <SID>BlameCommit("exe <SID>BlameLeave()<Bar>edit")<CR>', '<silent>')
                              call s:Map('n', 'o',    ':<C-U>exe <SID>BlameCommit("split")<CR>', '<silent>')
                              call s:Map('n', 'O',    ':<C-U>exe <SID>BlameCommit("tabedit")<CR>', '<silent>')
                              call s:Map('n', 'p',    ':<C-U>exe <SID>BlameCommit("pedit")<CR>', '<silent>')
                            endfunction
                            
    1              0.000002 augroup fugitive_blame
    1              0.000043   autocmd!
    1              0.000007   autocmd FileType fugitiveblame call s:BlameFileType()
    1              0.000005   autocmd ColorScheme,GUIEnter * call s:BlameRehighlight()
    1              0.000005   autocmd BufWinLeave * execute getwinvar(+bufwinnr(+expand('<abuf>')), 'fugitive_leave')
    1              0.000001 augroup END
                            
                            " Section: :Gbrowse
                            
    1              0.000002 let s:redirects = {}
                            
    1              0.000003 function! fugitive#BrowseCommand(line1, count, range, bang, mods, arg, args) abort
                              let dir = s:Dir()
                              exe s:DirCheck(dir)
                              try
                                let validremote = '\.\|\.\=/.*\|[[:alnum:]_-]\+\%(://.\{-\}\)\='
                                if a:args ==# ['-']
                                  if a:count >= 0
                                    return 'echoerr ' . string('fugitive: ''-'' no longer required to get persistent URL if range given')
                                  else
                                    return 'echoerr ' . string('fugitive: use :0Gbrowse instead of :Gbrowse -')
                                  endif
                                elseif len(a:args)
                                  let remote = matchstr(join(a:args, ' '),'@\zs\%('.validremote.'\)$')
                                  let rev = substitute(join(a:args, ' '),'@\%('.validremote.'\)$','','')
                                else
                                  let remote = ''
                                  let rev = ''
                                endif
                                if rev ==# ''
                                  let rev = s:DirRev(@%)[1]
                                endif
                                if rev =~# '^:\=$'
                                  let expanded = s:Relative()
                                else
                                  let expanded = s:Expand(rev)
                                endif
                                let cdir = FugitiveVimPath(fugitive#CommonDir(dir))
                                for subdir in ['tags/', 'heads/', 'remotes/']
                                  if expanded !~# '^[./]' && filereadable(cdir . '/refs/' . subdir . expanded)
                                    let expanded = '.git/refs/' . subdir . expanded
                                  endif
                                endfor
                                let full = fugitive#Find(expanded, dir)
                                let commit = ''
                                if full =~? '^fugitive:'
                                  let [pathdir, commit, path] = s:DirCommitFile(full)
                                  if commit =~# '^:\=\d$'
                                    let commit = ''
                                  endif
                                  if commit =~ '..'
                                    let type = s:TreeChomp('cat-file','-t',commit.s:sub(path,'^/',':'))
                                    let branch = matchstr(expanded, '^[^:]*')
                                  else
                                    let type = 'blob'
                                  endif
                                  let path = path[1:-1]
                                elseif full =~? '^\a\a\+:[\/][\/]'
                                  let path = s:Slash(full)
                                  let type = 'url'
                                elseif empty(s:Tree(dir))
                                  let path = '.git/' . full[strlen(dir)+1:-1]
                                  let type = ''
                                else
                                  let path = fugitive#Path(full, '/')[1:-1]
                                  if path =~# '^\.git/'
                                    let type = ''
                                  elseif isdirectory(full) || empty(path)
                                    let type = 'tree'
                                  else
                                    let type = 'blob'
                                  endif
                                endif
                                if type ==# 'tree' && !empty(path)
                                  let path = s:sub(path, '/\=$', '/')
                                endif
                                if path =~# '^\.git/.*HEAD$' && filereadable(dir . '/' . path[5:-1])
                                  let body = readfile(dir . '/' . path[5:-1])[0]
                                  if body =~# '^\x\{40,\}$'
                                    let commit = body
                                    let type = 'commit'
                                    let path = ''
                                  elseif body =~# '^ref: refs/'
                                    let path = '.git/' . matchstr(body,'ref: \zs.*')
                                  endif
                                endif
                            
                                let merge = ''
                                if path =~# '^\.git/refs/remotes/.'
                                  if empty(remote)
                                    let remote = matchstr(path, '^\.git/refs/remotes/\zs[^/]\+')
                                    let branch = matchstr(path, '^\.git/refs/remotes/[^/]\+/\zs.\+')
                                  else
                                    let merge = matchstr(path, '^\.git/refs/remotes/[^/]\+/\zs.\+')
                                    let path = '.git/refs/heads/'.merge
                                  endif
                                elseif path =~# '^\.git/refs/heads/.'
                                  let branch = path[16:-1]
                                elseif !exists('branch')
                                  let branch = FugitiveHead()
                                endif
                                if !empty(branch)
                                  let r = fugitive#Config('branch.'.branch.'.remote')
                                  let m = fugitive#Config('branch.'.branch.'.merge')[11:-1]
                                  if r ==# '.' && !empty(m)
                                    let r2 = fugitive#Config('branch.'.m.'.remote')
                                    if r2 !~# '^\.\=$'
                                      let r = r2
                                      let m = fugitive#Config('branch.'.m.'.merge')[11:-1]
                                    endif
                                  endif
                                  if empty(remote)
                                    let remote = r
                                  endif
                                  if r ==# '.' || r ==# remote
                                    let merge = m
                                    if path =~# '^\.git/refs/heads/.'
                                      let path = '.git/refs/heads/'.merge
                                    endif
                                  endif
                                endif
                            
                                let line1 = a:count > 0 ? a:line1 : 0
                                let line2 = a:count > 0 ? a:count : 0
                                if empty(commit) && path !~# '^\.git/'
                                  if a:count < 0 && !empty(merge)
                                    let commit = merge
                                  else
                                    let commit = ''
                                    if len(merge)
                                      let owner = s:Owner(@%)
                                      let [commit, exec_error] = s:ChompError(['merge-base', 'refs/remotes/' . remote . '/' . merge, empty(owner) ? 'HEAD' : owner, '--'])
                                      if exec_error
                                        let commit = ''
                                      endif
                                      if a:count > 0 && empty(a:args) && commit =~# '^\x\{40,\}$'
                                        let blame_list = tempname()
                                        call writefile([commit, ''], blame_list, 'b')
                                        let blame_in = tempname()
                                        silent exe '%write' blame_in
                                        let [blame, exec_error] = s:LinesError(['-c', 'blame.coloring=none', 'blame', '--contents', blame_in, '-L', a:line1.','.a:count, '-S', blame_list, '-s', '--show-number', './' . path])
                                        if !exec_error
                                          let blame_regex = '^\^\x\+\s\+\zs\d\+\ze\s'
                                          if get(blame, 0) =~# blame_regex && get(blame, -1) =~# blame_regex
                                            let line1 = +matchstr(blame[0], blame_regex)
                                            let line2 = +matchstr(blame[-1], blame_regex)
                                          else
                                            call s:throw("Can't browse to uncommitted change")
                                          endif
                                        endif
                                      endif
                                    endif
                                  endif
                                  if empty(commit)
                                    let commit = readfile(fugitive#Find('.git/HEAD', dir), '', 1)[0]
                                  endif
                                  let i = 0
                                  while commit =~# '^ref: ' && i < 10
                                    let ref_file = cdir . '/' . commit[5:-1]
                                    if getfsize(ref_file) > 0
                                      let commit = readfile(ref_file, '', 1)[0]
                                    else
                                      let commit = fugitive#RevParse(commit[5:-1], dir)
                                    endif
                                    let i -= 1
                                  endwhile
                                endif
                            
                                if empty(remote)
                                  let remote = '.'
                                endif
                                let raw = fugitive#RemoteUrl(remote)
                                if empty(raw)
                                  let raw = remote
                                endif
                            
                                if raw =~# '^https\=://' && s:executable('curl')
                                  if !has_key(s:redirects, raw)
                                    let s:redirects[raw] = matchstr(system('curl -I ' .
                                          \ s:shellesc(raw . '/info/refs?service=git-upload-pack')),
                                          \ 'Location: \zs\S\+\ze/info/refs?')
                                  endif
                                  if len(s:redirects[raw])
                                    let raw = s:redirects[raw]
                                  endif
                                endif
                            
                                let opts = {
                                      \ 'dir': dir,
                                      \ 'repo': fugitive#repo(dir),
                                      \ 'remote': raw,
                                      \ 'revision': 'No longer provided',
                                      \ 'commit': commit,
                                      \ 'path': path,
                                      \ 'type': type,
                                      \ 'line1': line1,
                                      \ 'line2': line2}
                            
                                if type ==# 'url'
                                  let url = path
                                else
                                  let url = ''
                                  for Handler in get(g:, 'fugitive_browse_handlers', [])
                                    let url = call(Handler, [copy(opts)])
                                    if !empty(url)
                                      break
                                    endif
                                  endfor
                                endif
                            
                                if empty(url)
                                  call s:throw("No Gbrowse handler installed for '".raw."'")
                                endif
                            
                                let url = s:gsub(url, '[ <>]', '\="%".printf("%02X",char2nr(submatch(0)))')
                                if a:bang
                                  if has('clipboard')
                                    let @+ = url
                                  endif
                                  return 'echomsg '.string(url)
                                elseif exists(':Browse') == 2
                                  return 'echomsg '.string(url).'|Browse '.url
                                else
                                  if !exists('g:loaded_netrw')
                                    runtime! autoload/netrw.vim
                                  endif
                                  if exists('*netrw#BrowseX')
                                    return 'echomsg '.string(url).'|call netrw#BrowseX('.string(url).', 0)'
                                  else
                                    return 'echomsg '.string(url).'|call netrw#NetrwBrowseX('.string(url).', 0)'
                                  endif
                                endif
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                            endfunction
                            
                            " Section: Go to file
                            
    1              0.000002 let s:ref_header = '\%(Head\|Merge\|Rebase\|Upstream\|Pull\|Push\)'
                            
    1              0.000050 nnoremap <SID>: :<C-U><C-R>=v:count ? v:count : ''<CR>
    1              0.000002 function! fugitive#MapCfile(...) abort
                              exe 'cnoremap <buffer> <expr> <Plug><cfile>' (a:0 ? a:1 : 'fugitive#Cfile()')
                              let b:undo_ftplugin = get(b:, 'undo_ftplugin', 'exe') . '|sil! exe "cunmap <buffer> <Plug><cfile>"'
                              if !exists('g:fugitive_no_maps')
                                call s:Map('n', 'gf',          '<SID>:find <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('n', '<C-W>f',     '<SID>:sfind <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('n', '<C-W><C-F>', '<SID>:sfind <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('n', '<C-W>gf',  '<SID>:tabfind <Plug><cfile><CR>', '<silent><unique>', 1)
                                call s:Map('c', '<C-R><C-F>', '<Plug><cfile>', '<silent><unique>', 1)
                              endif
                            endfunction
                            
    1              0.000002 function! s:ContainingCommit() abort
                              let commit = s:Owner(@%)
                              return empty(commit) ? 'HEAD' : commit
                            endfunction
                            
    1              0.000001 function! s:SquashArgument(...) abort
                              if &filetype == 'fugitive'
                                let commit = matchstr(getline('.'), '^\%(\%(\x\x\x\)\@!\l\+\s\+\)\=\zs[0-9a-f]\{4,\}\ze \|^' . s:ref_header . ': \zs\S\+')
                              elseif has_key(s:temp_files, s:cpath(expand('%:p')))
                                let commit = matchstr(getline('.'), '\<\x\{4,\}\>')
                              else
                                let commit = s:Owner(@%)
                              endif
                              return len(commit) && a:0 ? printf(a:1, commit) : commit
                            endfunction
                            
    1              0.000001 function! s:RebaseArgument() abort
                              return s:SquashArgument(' %s^')
                            endfunction
                            
    1              0.000002 function! s:NavigateUp(count) abort
                              let rev = substitute(s:DirRev(@%)[1], '^$', ':', 'g')
                              let c = a:count
                              while c
                                if rev =~# ':.*/.'
                                  let rev = matchstr(rev, '.*\ze/.\+', '')
                                elseif rev =~# '.:.'
                                  let rev = matchstr(rev, '^.[^:]*:')
                                elseif rev =~# '^:'
                                  let rev = 'HEAD^{}'
                                elseif rev =~# ':$'
                                  let rev = rev[0:-2]
                                else
                                  return rev.'~'.c
                                endif
                                let c -= 1
                              endwhile
                              return rev
                            endfunction
                            
    1              0.000002 function! s:MapMotion(lhs, rhs) abort
                              call s:Map('n', a:lhs, ":<C-U>" . a:rhs . "<CR>", "<silent>")
                              call s:Map('o', a:lhs, ":<C-U>" . a:rhs . "<CR>", "<silent>")
                              call s:Map('x', a:lhs, ":<C-U>exe 'normal! gv'<Bar>" . a:rhs . "<CR>", "<silent>")
                            endfunction
                            
    1              0.000001 function! fugitive#MapJumps(...) abort
                              if !&modifiable
                                if get(b:, 'fugitive_type', '') ==# 'blob'
                                  let blame_map = 'Git blame<C-R>=v:count ? " --reverse" : ""<CR><CR>'
                                  call s:Map('n', '<2-LeftMouse>', ':<C-U>0,1' . blame_map, '<silent>')
                                  call s:Map('n', '<CR>', ':<C-U>0,1' . blame_map, '<silent>')
                                  call s:Map('n', 'o',    ':<C-U>0,2' . blame_map, '<silent>')
                                  call s:Map('n', 'p',    ':<C-U>0,3' . blame_map, '<silent>')
                                  call s:Map('n', 'gO',   ':<C-U>0,4' . blame_map, '<silent>')
                                  call s:Map('n', 'O',    ':<C-U>0,5' . blame_map, '<silent>')
                            
                                  call s:Map('n', 'D',  ":<C-U>call <SID>DiffClose()<Bar>Gdiffsplit!<Bar>redraw<Bar>echohl WarningMsg<Bar> echo ':Gstatus D is deprecated in favor of dd'<Bar>echohl NONE<CR>", '<silent>')
                                  call s:Map('n', 'dd', ":<C-U>call <SID>DiffClose()<Bar>Gdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'dh', ":<C-U>call <SID>DiffClose()<Bar>Ghdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'ds', ":<C-U>call <SID>DiffClose()<Bar>Ghdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'dv', ":<C-U>call <SID>DiffClose()<Bar>Gvdiffsplit!<CR>", '<silent>')
                                  call s:Map('n', 'd?', ":<C-U>help fugitive_d<CR>", '<silent>')
                            
                                else
                                  call s:Map('n', '<2-LeftMouse>', ':<C-U>exe <SID>GF("edit")<CR>', '<silent>')
                                  call s:Map('n', '<CR>', ':<C-U>exe <SID>GF("edit")<CR>', '<silent>')
                                  call s:Map('n', 'o',    ':<C-U>exe <SID>GF("split")<CR>', '<silent>')
                                  call s:Map('n', 'gO',   ':<C-U>exe <SID>GF("vsplit")<CR>', '<silent>')
                                  call s:Map('n', 'O',    ':<C-U>exe <SID>GF("tabedit")<CR>', '<silent>')
                                  call s:Map('n', 'p',    ':<C-U>exe <SID>GF("pedit")<CR>', '<silent>')
                            
                                  if !exists('g:fugitive_no_maps')
                                    if exists(':CtrlP') && get(g:, 'ctrl_p_map') =~? '^<c-p>$'
                                      nnoremap <buffer> <silent> <C-P> :<C-U>execute line('.') == 1 ? 'CtrlP ' . fnameescape(<SID>Tree()) : <SID>PreviousItem(v:count1)<CR>
                                    else
                                      nnoremap <buffer> <silent> <C-P> :<C-U>execute <SID>PreviousItem(v:count1)<CR>
                                    endif
                                    nnoremap <buffer> <silent> <C-N> :<C-U>execute <SID>NextItem(v:count1)<CR>
                                  endif
                                  call s:MapMotion('(', 'exe <SID>PreviousItem(v:count1)')
                                  call s:MapMotion(')', 'exe <SID>NextItem(v:count1)')
                                  call s:MapMotion('K', 'exe <SID>PreviousHunk(v:count1)')
                                  call s:MapMotion('J', 'exe <SID>NextHunk(v:count1)')
                                  call s:MapMotion('[c', 'exe <SID>PreviousHunk(v:count1)')
                                  call s:MapMotion(']c', 'exe <SID>NextHunk(v:count1)')
                                  call s:MapMotion('[/', 'exe <SID>PreviousFile(v:count1)')
                                  call s:MapMotion(']/', 'exe <SID>NextFile(v:count1)')
                                  call s:MapMotion('[m', 'exe <SID>PreviousFile(v:count1)')
                                  call s:MapMotion(']m', 'exe <SID>NextFile(v:count1)')
                                  call s:MapMotion('[[', 'exe <SID>PreviousSection(v:count1)')
                                  call s:MapMotion(']]', 'exe <SID>NextSection(v:count1)')
                                  call s:MapMotion('[]', 'exe <SID>PreviousSectionEnd(v:count1)')
                                  call s:MapMotion('][', 'exe <SID>NextSectionEnd(v:count1)')
                                  call s:Map('nxo', '*', '<SID>PatchSearchExpr(0)', '<expr>')
                                  call s:Map('nxo', '#', '<SID>PatchSearchExpr(1)', '<expr>')
                                endif
                                call s:Map('n', 'S',    ':<C-U>echoerr "Use gO"<CR>', '<silent>')
                                call s:Map('n', 'dq', ":<C-U>call <SID>DiffClose()<CR>", '<silent>')
                                call s:Map('n', '-', ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>NavigateUp(v:count1))<Bar> if getline(1) =~# '^tree \x\{40,\}$' && empty(getline(2))<Bar>call search('^'.escape(expand('#:t'),'.*[]~\').'/\=$','wc')<Bar>endif<CR>", '<silent>')
                                call s:Map('n', 'P',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit().'^'.v:count1.<SID>Relative(':'))<CR>", '<silent>')
                                call s:Map('n', '~',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit().'~'.v:count1.<SID>Relative(':'))<CR>", '<silent>')
                                call s:Map('n', 'C',     ":<C-U>exe 'Gedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
                                call s:Map('n', 'cp',    ":<C-U>echoerr 'Use gC'<CR>", '<silent>')
                                call s:Map('n', 'gC',    ":<C-U>exe 'Gpedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
                                call s:Map('n', 'gc',    ":<C-U>exe 'Gpedit ' . <SID>fnameescape(<SID>ContainingCommit())<CR>", '<silent>')
                                call s:Map('n', 'gi',    ":<C-U>exe 'Gsplit' (v:count ? '.gitignore' : '.git/info/exclude')<CR>", '<silent>')
                                call s:Map('x', 'gi',    ":<C-U>exe 'Gsplit' (v:count ? '.gitignore' : '.git/info/exclude')<CR>", '<silent>')
                            
                                nnoremap <buffer>       c<Space> :Git commit<Space>
                                nnoremap <buffer>          c<CR> :Git commit<CR>
                                nnoremap <buffer>      cv<Space> :tab Git commit -v<Space>
                                nnoremap <buffer>         cv<CR> :tab Git commit -v<CR>
                                nnoremap <buffer> <silent> ca    :<C-U>Git commit --amend<CR>
                                nnoremap <buffer> <silent> cc    :<C-U>Git commit<CR>
                                nnoremap <buffer> <silent> ce    :<C-U>Git commit --amend --no-edit<CR>
                                nnoremap <buffer> <silent> cw    :<C-U>Git commit --amend --only<CR>
                                nnoremap <buffer> <silent> cva   :<C-U>tab Git commit -v --amend<CR>
                                nnoremap <buffer> <silent> cvc   :<C-U>tab Git commit -v<CR>
                                nnoremap <buffer> <silent> cRa   :<C-U>Git commit --reset-author --amend<CR>
                                nnoremap <buffer> <silent> cRe   :<C-U>Git commit --reset-author --amend --no-edit<CR>
                                nnoremap <buffer> <silent> cRw   :<C-U>Git commit --reset-author --amend --only<CR>
                                nnoremap <buffer>          cf    :<C-U>Git commit --fixup=<C-R>=<SID>SquashArgument()<CR>
                                nnoremap <buffer>          cF    :<C-U><Bar>Git -c sequence.editor=true rebase --interactive --autosquash<C-R>=<SID>RebaseArgument()<CR><Home>Git commit --fixup=<C-R>=<SID>SquashArgument()<CR>
                                nnoremap <buffer>          cs    :<C-U>Git commit --no-edit --squash=<C-R>=<SID>SquashArgument()<CR>
                                nnoremap <buffer>          cS    :<C-U><Bar>Git -c sequence.editor=true rebase --interactive --autosquash<C-R>=<SID>RebaseArgument()<CR><Home>Git commit --no-edit --squash=<C-R>=<SID>SquashArgument()<CR>
                                nnoremap <buffer>          cA    :<C-U>Git commit --edit --squash=<C-R>=<SID>SquashArgument()<CR>
                                nnoremap <buffer> <silent> c?    :<C-U>help fugitive_c<CR>
                            
                                nnoremap <buffer>      cr<Space> :Git revert<Space>
                                nnoremap <buffer>         cr<CR> :Git revert<CR>
                                nnoremap <buffer> <silent> crc   :<C-U>Git revert <C-R>=<SID>SquashArgument()<CR><CR>
                                nnoremap <buffer> <silent> crn   :<C-U>Git revert --no-commit <C-R>=<SID>SquashArgument()<CR><CR>
                                nnoremap <buffer> <silent> cr?   :help fugitive_cr<CR>
                            
                                nnoremap <buffer>      cm<Space> :Git merge<Space>
                                nnoremap <buffer>         cm<CR> :Git merge<CR>
                                nnoremap <buffer>          cmt   :Git mergetool
                                nnoremap <buffer> <silent> cm?   :help fugitive_cm<CR>
                            
                                nnoremap <buffer>      cz<Space> :Git stash<Space>
                                nnoremap <buffer>         cz<CR> :Git stash<CR>
                                nnoremap <buffer>          cza   :<C-U>Git stash apply --quiet --index stash@{<C-R>=v:count<CR>}<CR>
                                nnoremap <buffer>          czA   :<C-U>Git stash apply --quiet stash@{<C-R>=v:count<CR>}<CR>
                                nnoremap <buffer>          czp   :<C-U>Git stash pop --quiet --index stash@{<C-R>=v:count<CR>}<CR>
                                nnoremap <buffer>          czP   :<C-U>Git stash pop --quiet stash@{<C-R>=v:count<CR>}<CR>
                                nnoremap <buffer> <silent> czv   :<C-U>exe 'Gedit' fugitive#RevParse('stash@{' . v:count . '}')<CR>
                                nnoremap <buffer>          czw   :<C-U>Git stash --keep-index<C-R>=v:count > 1 ? ' --all' : v:count ? ' --include-untracked' : ''<CR><CR>
                                nnoremap <buffer>          czz   :<C-U>Git stash <C-R>=v:count > 1 ? ' --all' : v:count ? ' --include-untracked' : ''<CR>
                                nnoremap <buffer> <silent> cz?   :<C-U>help fugitive_cz<CR>
                            
                                nnoremap <buffer>      co<Space> :Git checkout<Space>
                                nnoremap <buffer>         co<CR> :Git checkout<CR>
                                nnoremap <buffer>          coo   :<C-U>Git checkout <C-R>=<SID>SquashArgument()<CR> --<CR>
                                nnoremap <buffer>          co?   :<C-U>help fugitive_co<CR>
                            
                                nnoremap <buffer>      cb<Space> :Git branch<Space>
                                nnoremap <buffer>         cb<CR> :Git branch<CR>
                                nnoremap <buffer>         cb?    :<C-U>help fugitive_cb<CR>
                            
                                nnoremap <buffer>       r<Space> :Git rebase<Space>
                                nnoremap <buffer>          r<CR> :Git rebase<CR>
                                nnoremap <buffer> <silent> ri    :<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><CR>
                                nnoremap <buffer> <silent> rf    :<C-U>Git -c sequence.editor=true rebase --interactive --autosquash<C-R>=<SID>RebaseArgument()<CR><CR>
                                nnoremap <buffer> <silent> ru    :<C-U>Git rebase --interactive @{upstream}<CR>
                                nnoremap <buffer> <silent> rp    :<C-U>Git rebase --interactive @{push}<CR>
                                nnoremap <buffer> <silent> rw    :<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/reword/e<CR>
                                nnoremap <buffer> <silent> rm    :<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/edit/e<CR>
                                nnoremap <buffer> <silent> rd    :<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>
                                nnoremap <buffer> <silent> rk    :<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>
                                nnoremap <buffer> <silent> rx    :<C-U>Git rebase --interactive<C-R>=<SID>RebaseArgument()<CR><Bar>s/^pick/drop/e<CR>
                                nnoremap <buffer> <silent> rr    :<C-U>Git rebase --continue<CR>
                                nnoremap <buffer> <silent> rs    :<C-U>Git rebase --skip<CR>
                                nnoremap <buffer> <silent> re    :<C-U>Git rebase --edit-todo<CR>
                                nnoremap <buffer> <silent> ra    :<C-U>Git rebase --abort<CR>
                                nnoremap <buffer> <silent> r?    :<C-U>help fugitive_r<CR>
                            
                                call s:Map('n', '.',     ":<C-U> <C-R>=<SID>fnameescape(fugitive#Real(@%))<CR><Home>")
                                call s:Map('x', '.',     ":<C-U> <C-R>=<SID>fnameescape(fugitive#Real(@%))<CR><Home>")
                                call s:Map('n', 'g?',    ":<C-U>help fugitive-map<CR>", '<silent>')
                                call s:Map('n', '<F1>',  ":<C-U>help fugitive-map<CR>", '<silent>')
                              endif
                            endfunction
                            
    1              0.000002 function! s:StatusCfile(...) abort
                              let tree = s:Tree()
                              let lead = s:cpath(tree, getcwd()) ? './' : tree . '/'
                              let info = s:StageInfo()
                              let line = getline('.')
                              if len(info.sigil) && len(info.section) && len(info.paths)
                                if info.section ==# 'Unstaged' && info.sigil !=# '-'
                                  return [lead . info.relative[0], info.offset, 'normal!zv']
                                elseif info.section ==# 'Staged' && info.sigil ==# '-'
                                  return ['@:' . info.relative[0], info.offset, 'normal!zv']
                                else
                                  return [':0:' . info.relative[0], info.offset, 'normal!zv']
                                endif
                              elseif len(info.paths)
                                return [lead . info.relative[0]]
                              elseif len(info.commit)
                                return [info.commit]
                              elseif line =~# '^' . s:ref_header . ': '
                                return [matchstr(line, ' \zs.*')]
                              else
                                return ['']
                              endif
                            endfunction
                            
    1              0.000002 function! fugitive#StatusCfile() abort
                              let file = s:Generate(s:StatusCfile()[0])
                              return empty(file) ? fugitive#Cfile() : s:fnameescape(file)
                            endfunction
                            
    1              0.000001 function! s:MessageCfile(...) abort
                              let tree = s:Tree()
                              let lead = s:cpath(tree, getcwd()) ? './' : tree . '/'
                              if getline('.') =~# '^.\=\trenamed:.* -> '
                                return lead . matchstr(getline('.'),' -> \zs.*')
                              elseif getline('.') =~# '^.\=\t\(\k\| \)\+\p\?: *.'
                                return lead . matchstr(getline('.'),': *\zs.\{-\}\ze\%( ([^()[:digit:]]\+)\)\=$')
                              elseif getline('.') =~# '^.\=\t.'
                                return lead . matchstr(getline('.'),'\t\zs.*')
                              elseif getline('.') =~# ': needs merge$'
                                return lead . matchstr(getline('.'),'.*\ze: needs merge$')
                              elseif getline('.') =~# '^\%(. \)\=Not currently on any branch.$'
                                return 'HEAD'
                              elseif getline('.') =~# '^\%(. \)\=On branch '
                                return 'refs/heads/'.getline('.')[12:]
                              elseif getline('.') =~# "^\\%(. \\)\=Your branch .*'"
                                return matchstr(getline('.'),"'\\zs\\S\\+\\ze'")
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000002 function! fugitive#MessageCfile() abort
                              let file = s:Generate(s:MessageCfile())
                              return empty(file) ? fugitive#Cfile() : s:fnameescape(file)
                            endfunction
                            
    1              0.000001 function! s:cfile() abort
                              try
                                let myhash = s:DirRev(@%)[1]
                                if len(myhash)
                                  try
                                    let myhash = fugitive#RevParse(myhash)
                                  catch /^fugitive:/
                                    let myhash = ''
                                  endtry
                                endif
                                if empty(myhash) && getline(1) =~# '^\%(commit\|tag\) \w'
                                  let myhash = matchstr(getline(1),'^\w\+ \zs\S\+')
                                endif
                            
                                let showtree = (getline(1) =~# '^tree ' && getline(2) == "")
                            
                                let treebase = substitute(s:DirCommitFile(@%)[1], '^\d$', ':&', '') . ':' .
                                      \ s:Relative('') . (s:Relative('') =~# '^$\|/$' ? '' : '/')
                            
                                if getline('.') =~# '^\d\{6\} \l\{3,8\} \x\{40,\}\t'
                                  return [treebase . s:sub(matchstr(getline('.'),'\t\zs.*'),'/$','')]
                                elseif showtree
                                  return [treebase . s:sub(getline('.'),'/$','')]
                            
                                else
                            
                                  let dcmds = []
                            
                                  " Index
                                  if getline('.') =~# '^\d\{6\} \x\{40,\} \d\t'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    let file = ':'.s:sub(matchstr(getline('.'),'\d\t.*'),'\t',':')
                                    return [file]
                                  endif
                            
                                  if getline('.') =~# '^ref: '
                                    let ref = strpart(getline('.'),5)
                            
                                  elseif getline('.') =~# '^commit \x\{40,\}\>'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    return [ref]
                            
                                  elseif getline('.') =~# '^parent \x\{40,\}\>'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    let line = line('.')
                                    let parent = 0
                                    while getline(line) =~# '^parent '
                                      let parent += 1
                                      let line -= 1
                                    endwhile
                                    return [ref]
                            
                                  elseif getline('.') =~# '^tree \x\{40,\}$'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    if len(myhash) && fugitive#RevParse(myhash.':') ==# ref
                                      let ref = myhash.':'
                                    endif
                                    return [ref]
                            
                                  elseif getline('.') =~# '^object \x\{40,\}$' && getline(line('.')+1) =~ '^type \%(commit\|tree\|blob\)$'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    let type = matchstr(getline(line('.')+1),'type \zs.*')
                            
                                  elseif getline('.') =~# '^\l\{3,8\} '.myhash.'$'
                                    let ref = s:DirRev(@%)[1]
                            
                                  elseif getline('.') =~# '^\l\{3,8\} \x\{40,\}\>'
                                    let ref = matchstr(getline('.'),'\x\{40,\}')
                                    echoerr "warning: unknown context ".matchstr(getline('.'),'^\l*')
                            
                                  elseif getline('.') =~# '^[+-]\{3\} [abciow12]\=/'
                                    let ref = getline('.')[4:]
                            
                                  elseif getline('.') =~# '^[+-]' && search('^@@ -\d\+\%(,\d\+\)\= +\d\+','bnW')
                                    let type = getline('.')[0]
                                    let lnum = line('.') - 1
                                    let offset = 0
                                    while getline(lnum) !~# '^@@ -\d\+\%(,\d\+\)\= +\d\+'
                                      if getline(lnum) =~# '^[ '.type.']'
                                        let offset += 1
                                      endif
                                      let lnum -= 1
                                    endwhile
                                    let offset += matchstr(getline(lnum), type.'\zs\d\+')
                                    let ref = getline(search('^'.type.'\{3\} [abciow12]/','bnW'))[4:-1]
                                    let dcmds = [offset, 'normal!zv']
                            
                                  elseif getline('.') =~# '^rename from '
                                    let ref = 'a/'.getline('.')[12:]
                                  elseif getline('.') =~# '^rename to '
                                    let ref = 'b/'.getline('.')[10:]
                            
                                  elseif getline('.') =~# '^@@ -\d\+\%(,\d\+\)\= +\d\+'
                                    let diff = getline(search('^diff --git \%([abciow12]/.*\|/dev/null\) \%([abciow12]/.*\|/dev/null\)', 'bcnW'))
                                    let offset = matchstr(getline('.'), '+\zs\d\+')
                            
                                    let dref = matchstr(diff, '\Cdiff --git \zs\%([abciow12]/.*\|/dev/null\)\ze \%([abciow12]/.*\|/dev/null\)')
                                    let ref = matchstr(diff, '\Cdiff --git \%([abciow12]/.*\|/dev/null\) \zs\%([abciow12]/.*\|/dev/null\)')
                                    let dcmd = 'Gdiffsplit! +'.offset
                            
                                  elseif getline('.') =~# '^diff --git \%([abciow12]/.*\|/dev/null\) \%([abciow12]/.*\|/dev/null\)'
                                    let dref = matchstr(getline('.'),'\Cdiff --git \zs\%([abciow12]/.*\|/dev/null\)\ze \%([abciow12]/.*\|/dev/null\)')
                                    let ref = matchstr(getline('.'),'\Cdiff --git \%([abciow12]/.*\|/dev/null\) \zs\%([abciow12]/.*\|/dev/null\)')
                                    let dcmd = 'Gdiffsplit!'
                            
                                  elseif getline('.') =~# '^index ' && getline(line('.')-1) =~# '^diff --git \%([abciow12]/.*\|/dev/null\) \%([abciow12]/.*\|/dev/null\)'
                                    let line = getline(line('.')-1)
                                    let dref = matchstr(line,'\Cdiff --git \zs\%([abciow12]/.*\|/dev/null\)\ze \%([abciow12]/.*\|/dev/null\)')
                                    let ref = matchstr(line,'\Cdiff --git \%([abciow12]/.*\|/dev/null\) \zs\%([abciow12]/.*\|/dev/null\)')
                                    let dcmd = 'Gdiffsplit!'
                            
                                  elseif line('$') == 1 && getline('.') =~ '^\x\{40,\}$'
                                    let ref = getline('.')
                            
                                  elseif expand('<cword>') =~# '^\x\{7,\}\>'
                                    return [expand('<cword>')]
                            
                                  else
                                    let ref = ''
                                  endif
                            
                                  let prefixes = {
                                        \ '1': '',
                                        \ '2': '',
                                        \ 'b': ':0:',
                                        \ 'i': ':0:',
                                        \ 'o': '',
                                        \ 'w': ''}
                            
                                  if len(myhash)
                                    let prefixes.a = myhash.'^:'
                                    let prefixes.b = myhash.':'
                                  endif
                                  let ref = substitute(ref, '^\(\w\)/', '\=get(prefixes, submatch(1), "HEAD:")', '')
                                  if exists('dref')
                                    let dref = substitute(dref, '^\(\w\)/', '\=get(prefixes, submatch(1), "HEAD:")', '')
                                  endif
                            
                                  if ref ==# '/dev/null'
                                    " Empty blob
                                    let ref = 'e69de29bb2d1d6434b8b29ae775ad8c2e48c5391'
                                  endif
                            
                                  if exists('dref')
                                    return [ref, dcmd . ' ' . s:fnameescape(dref)] + dcmds
                                  elseif ref != ""
                                    return [ref] + dcmds
                                  endif
                            
                                endif
                                return []
                              endtry
                            endfunction
                            
    1              0.000001 function! s:GF(mode) abort
                              try
                                let results = &filetype ==# 'fugitive' ? s:StatusCfile() : &filetype ==# 'gitcommit' ? [s:MessageCfile()] : s:cfile()
                              catch /^fugitive:/
                                return 'echoerr ' . string(v:exception)
                              endtry
                              if len(results) > 1
                                return 'G' . a:mode .
                                      \ ' +' . escape(results[1], ' ') . ' ' .
                                      \ s:fnameescape(results[0]) . join(map(results[2:-1], '"|" . v:val'), '')
                              elseif len(results) && len(results[0])
                                return 'G' . a:mode . ' ' . s:fnameescape(results[0])
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000001 function! fugitive#Cfile() abort
                              let pre = ''
                              let results = s:cfile()
                              if empty(results)
                                let cfile = expand('<cfile>')
                                if &includeexpr =~# '\<v:fname\>'
                                  sandbox let cfile = eval(substitute(&includeexpr, '\C\<v:fname\>', '\=string(cfile)', 'g'))
                                endif
                                return cfile
                              elseif len(results) > 1
                                let pre = '+' . join(map(results[1:-1], 'escape(v:val, " ")'), '\|') . ' '
                              endif
                              return pre . s:fnameescape(s:Generate(results[0]))
                            endfunction
                            
                            " Section: Statusline
                            
    1              0.000001 function! fugitive#Statusline(...) abort
                              let dir = s:Dir(bufnr(''))
                              if empty(dir)
                                return ''
                              endif
                              let status = ''
                              let commit = s:DirCommitFile(@%)[1]
                              if len(commit)
                                let status .= ':' . commit[0:6]
                              endif
                              let status .= '('.FugitiveHead(7, dir).')'
                              return '[Git'.status.']'
                            endfunction
                            
    1              0.000002 function! fugitive#statusline(...) abort
                              return fugitive#Statusline()
                            endfunction
                            
    1              0.000001 function! fugitive#head(...) abort
                              if empty(s:Dir())
                                return ''
                              endif
                            
                              return fugitive#Head(a:0 ? a:1 : 0)
                            endfunction
                            
                            " Section: Folding
                            
    1              0.000002 function! fugitive#Foldtext() abort
                              if &foldmethod !=# 'syntax'
                                return foldtext()
                              endif
                            
                              let line_foldstart = getline(v:foldstart)
                              if line_foldstart =~# '^diff '
                                let [add, remove] = [-1, -1]
                                let filename = ''
                                for lnum in range(v:foldstart, v:foldend)
                                  let line = getline(lnum)
                                  if filename ==# '' && line =~# '^[+-]\{3\} [abciow12]/'
                                    let filename = line[6:-1]
                                  endif
                                  if line =~# '^+'
                                    let add += 1
                                  elseif line =~# '^-'
                                    let remove += 1
                                  elseif line =~# '^Binary '
                                    let binary = 1
                                  endif
                                endfor
                                if filename ==# ''
                                  let filename = matchstr(line_foldstart, '^diff .\{-\} [abciow12]/\zs.*\ze [abciow12]/')
                                endif
                                if filename ==# ''
                                  let filename = line_foldstart[5:-1]
                                endif
                                if exists('binary')
                                  return 'Binary: '.filename
                                else
                                  return (add<10&&remove<100?' ':'') . add . '+ ' . (remove<10&&add<100?' ':'') . remove . '- ' . filename
                                endif
                              elseif line_foldstart =~# '^# .*:$'
                                let lines = getline(v:foldstart, v:foldend)
                                call filter(lines, 'v:val =~# "^#\t"')
                                cal map(lines, "s:sub(v:val, '^#\t%(modified: +|renamed: +)=', '')")
                                cal map(lines, "s:sub(v:val, '^([[:alpha:] ]+): +(.*)', '\\2 (\\1)')")
                                return line_foldstart.' '.join(lines, ', ')
                              endif
                              return foldtext()
                            endfunction
                            
    1              0.000001 function! fugitive#foldtext() abort
                              return fugitive#Foldtext()
                            endfunction
                            
                            " Section: Initialization
                            
    1              0.000001 function! fugitive#Init() abort
                              throw 'Third party code is using fugitive#Init() which has been removed. Contact the author if you have a reason to still use it'
                            endfunction
                            
    1              0.000002 function! fugitive#is_git_dir(path) abort
                              throw 'Third party code is using fugitive#is_git_dir() which has been removed. Change it to FugitiveIsGitDir()'
                            endfunction
                            
    1              0.000002 function! fugitive#extract_git_dir(path) abort
                              throw 'Third party code is using fugitive#extract_git_dir() which has been removed. Change it to FugitiveExtractGitDir()'
                            endfunction
                            
    1              0.000002 function! fugitive#detect(path) abort
                              throw 'Third party code is using fugitive#detect() which has been removed. Contact the author if you have a reason to still use it'
                            endfunction
                            
                            " Section: End

SCRIPT  /home/carlos/.vim/plugged/vim-misc/autoload/xolox/misc/msg.vim
Sourced 1 time
Total time:   0.000588
 Self time:   0.000588

count  total (s)   self (s)
                            " Functions to interact with the user.
                            "
                            " Author: Peter Odding <peter@peterodding.com>
                            " Last Change: March 15, 2015
                            " URL: http://peterodding.com/code/vim/misc/
                            
    1              0.000014 if !exists('g:xolox_message_buffer')
                              " For when I lose my :messages history :-\
    1              0.000039   let g:xolox_message_buffer = 100
    1              0.000003 endif
                            
    1              0.000006 if !exists('g:xolox_messages')
    1              0.000030   let g:xolox_messages = []
    1              0.000002 endif
                            
    1              0.000005 function! xolox#misc#msg#info(...) " {{{1
                              " Show a formatted informational message to the user.
                              "
                              " This function has the same argument handling as Vim's [printf()] []
                              " function with one notable difference: Any arguments which are not numbers
                              " or strings are coerced to strings using Vim's [string()] [] function.
                              "
                              " In the case of `xolox#misc#msg#info()`, automatic string coercion simply
                              " makes the function a bit easier to use.
                              "
                              " The messages emitted by this function have no highlighting. Previously
                              " these messages were highlighted using the [Title group] [hl-title], but it
                              " was pointed out in [pull request 16] [pr-16] that this group shouldn't be
                              " used for informational messages because it is meant for titles and because
                              " of this some color schemes use colors that stand out quite a bit, causing
                              " the informational messages to look like errors.
                              "
                              " [hl-title]: http://vimdoc.sourceforge.net/htmldoc/syntax.html#hl-Title
                              " [pr-16]: https://github.com/xolox/vim-misc/pull/16
                              " [printf()]: http://vimdoc.sourceforge.net/htmldoc/eval.html#printf()
                              " [string()]: http://vimdoc.sourceforge.net/htmldoc/eval.html#string()
                              call s:show_message('None', a:000)
                            endfunction
                            
    1              0.000004 function! xolox#misc#msg#warn(...) " {{{1
                              " Show a formatted warning message to the user.
                              "
                              " This function has the same argument handling as the
                              " `xolox#misc#msg#info()` function.
                              call s:show_message('WarningMsg', a:000)
                            endfunction
                            
    1              0.000003 function! xolox#misc#msg#debug(...) " {{{1
                              " Show a formatted debugging message to the user, *if the user has enabled
                              " increased verbosity by setting Vim's ['verbose'] [] option to one
                              " (1) or higher*.
                              "
                              " This function has the same argument handling as the
                              " `xolox#misc#msg#info()` function.
                              "
                              " In the case of `xolox#misc#msg#debug()`, automatic string coercion
                              " provides lazy evaluation in the sense that complex data structures are
                              " only converted to strings when the user has enabled increased verbosity.
                              "
                              " ['verbose']: http://vimdoc.sourceforge.net/htmldoc/options.html#'verbose'
                              if &vbs >= 1
                                call s:show_message('Question', a:000)
                              endif
                            endfunction
                            
    1              0.000008 function! s:show_message(hlgroup, args) " {{{1
                              " The implementation of info() and warn().
                              let nargs = len(a:args)
                              if nargs == 1
                                let message = a:args[0]
                              elseif nargs >= 2
                                let args = map(copy(a:args), 's:coerce_argument(v:val)')
                                let message = call('printf', args)
                              endif
                              if exists('message')
                                try
                                  " Temporarily disable Vim's |hit-enter| prompt and mode display.
                                  if !exists('s:more_save')
                                    let s:more_save = &more
                                    let s:ruler_save = &ruler
                                    let s:smd_save = &showmode
                                  endif
                                  set nomore noshowmode
                                  if winnr('$') == 1 | set noruler | endif
                                  augroup PluginXoloxHideMode
                                    autocmd! CursorHold,CursorHoldI * call s:clear_message()
                                  augroup END
                                  execute 'echohl' a:hlgroup
                                  " Redraw to avoid the |hit-enter| prompt. We use :silent to avoid issues
                                  " like this one: https://github.com/xolox/vim-easytags/issues/69.
                                  silent! redraw
                                  for line in split(message, "\n")
                                    echomsg line
                                  endfor
                                  if g:xolox_message_buffer > 0
                                    call add(g:xolox_messages, message)
                                    if len(g:xolox_messages) > g:xolox_message_buffer
                                      call remove(g:xolox_messages, 0)
                                    endif
                                  endif
                                finally
                                  " Always clear message highlighting, even when interrupted by Ctrl-C.
                                  echohl none
                                endtry
                              endif
                            endfunction
                            
    1              0.000006 function! s:coerce_argument(value) " {{{1
                              " Callback to coerce printf() arguments into strings.
                              let value_type = type(a:value)
                              if value_type != type(0) && value_type != type('')
                                return string(a:value)
                              else
                                return a:value
                              endif
                            endfunction
                            
    1              0.000004 function! s:clear_message() " {{{1
                              " Callback to clear message after some time has passed.
                              echo ''
                              let &more = s:more_save
                              let &showmode = s:smd_save
                              let &ruler = s:ruler_save
                              unlet s:more_save s:ruler_save s:smd_save
                              autocmd! PluginXoloxHideMode
                              augroup! PluginXoloxHideMode
                            endfunction
                            
                            " vim: ts=2 sw=2 et

SCRIPT  /home/carlos/.vim/plugged/vim-misc/autoload/xolox/misc/path.vim
Sourced 1 time
Total time:   0.000264
 Self time:   0.000244

count  total (s)   self (s)
                            " Pathname manipulation functions.
                            "
                            " Author: Peter Odding <peter@peterodding.com>
                            " Last Change: July 7, 2014
                            " URL: http://peterodding.com/code/vim/misc/
                            
    1   0.000051   0.000031 let s:windows_compatible = xolox#misc#os#is_win()
                            
    1              0.000004 function! xolox#misc#path#which(...) " {{{1
                              " Scan the executable search path (`$PATH`) for one or more external
                              " programs. Expects one or more string arguments with program names. Returns
                              " a list with the absolute pathnames of all found programs. Here's an
                              " example:
                              "
                              "     :echo xolox#misc#path#which('gvim', 'vim')
                              "     ['/usr/local/bin/gvim',
                              "      '/usr/bin/gvim',
                              "      '/usr/local/bin/vim',
                              "      '/usr/bin/vim']
                              let extensions = s:windows_compatible ? split($PATHEXT, ';') : ['']
                              let matches = []
                              let checked = {}
                              for program in a:000
                                for directory in split($PATH, s:windows_compatible ? ';' : ':')
                                  let directory = xolox#misc#path#absolute(directory)
                                  if isdirectory(directory)
                                    let found = 0
                                    for extension in extensions
                                      let path = xolox#misc#path#merge(directory, program . extension)
                                      if executable(path)
                                        call add(matches, path)
                                        let found = 1
                                      endif
                                    endfor
                                    if s:windows_compatible && ! found
                                      " Maybe the extension is already contained in program; try without
                                      " $PATHEXT.
                                      let path = xolox#misc#path#merge(directory, program)
                                      if executable(path)
                                        call add(matches, path)
                                      endif
                                    endif
                                  endif
                                endfor
                              endfor
                              return xolox#misc#list#unique(matches)
                            endfunction
                            
    1              0.000002 function! xolox#misc#path#split(path) " {{{1
                              " Split a pathname (the first and only argument) into a list of pathname
                              " components.
                              "
                              " On Windows, pathnames starting with two slashes or backslashes are UNC
                              " paths where the leading slashes are significant... In this case we split
                              " like this:
                              "
                              " - Input: `'//server/share/directory'`
                              " - Result: `['//server', 'share', 'directory']`
                              "
                              " Everything except Windows is treated like UNIX until someone has a better
                              " suggestion :-). In this case we split like this:
                              "
                              " - Input: `'/foo/bar/baz'`
                              " - Result: `['/', 'foo', 'bar', 'baz']`
                              "
                              " To join a list of pathname components back into a single pathname string,
                              " use the `xolox#misc#path#join()` function.
                              if type(a:path) == type('')
                                if s:windows_compatible
                                  if a:path =~ '^[\/][\/]'
                                    " UNC pathname.
                                    return split(a:path, '\%>2c[\/]\+')
                                  else
                                    " If it's not a UNC pathname we can simply split on slashes and
                                    " backslashes, although we should preserve a leading slash (which
                                    " denotes a pathname that is 'absolute to the current drive').
                                    let absolute = (a:path =~ '^[\/]')
                                    let segments = split(a:path, '[\/]\+')
                                    return absolute ? insert(segments, a:path[0]) : segments
                                  endif
                                else
                                  " Everything else is treated as UNIX.
                                  let absolute = (a:path =~ '^/')
                                  let segments = split(a:path, '/\+')
                                  return absolute ? insert(segments, '/') : segments
                                endif
                              endif
                              return []
                            endfunction
                            
    1              0.000002 function! xolox#misc#path#join(parts) " {{{1
                              " Join a list of pathname components (the first and only argument) into a
                              " single pathname string. This is the counterpart to the
                              " `xolox#misc#path#split()` function and it expects a list of pathname
                              " components as returned by `xolox#misc#path#split()`.
                              if type(a:parts) == type([])
                                if s:windows_compatible
                                  return join(a:parts, xolox#misc#path#directory_separator())
                                elseif get(a:parts, 0) == '/'
                                  " Absolute path on UNIX (non-Windows).
                                  return '/' . join(a:parts[1:], '/')
                                else
                                  " Relative path on UNIX (non-Windows).
                                  return join(a:parts, '/')
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 function! xolox#misc#path#directory_separator() " {{{1
                              " Find the preferred directory separator for the platform and settings.
                              return exists('+shellslash') && &shellslash ? '/' : '\'
                            endfunction
                            
    1              0.000003 function! xolox#misc#path#absolute(path) " {{{1
                              " Canonicalize and resolve a pathname, *regardless of whether it exists*.
                              " This is intended to support string comparison to determine whether two
                              " pathnames point to the same directory or file.
                              if type(a:path) == type('')
                                let path = a:path
                                " Make the pathname absolute.
                                if path =~ '^\~'
                                  " Expand ~ to $HOME.
                                  let path = $HOME . '/' . path[1:]
                                elseif xolox#misc#path#is_relative(path)
                                  " Make relative pathnames absolute.
                                  let path = getcwd() . '/' . path
                                endif
                                " Resolve symbolic links to find the canonical pathname. In my tests this
                                " also removes all symbolic pathname segments (`.' and `..'), even when
                                " the pathname does not exist. Also there used to be a bug in resolve()
                                " where it wouldn't resolve pathnames ending in a directory separator.
                                " Since it's not much trouble to work around, that's what we do.
                                let path = resolve(substitute(path, s:windows_compatible ? '[\/]\+$' : '/\+$', '', ''))
                                " Normalize directory separators (especially relevant on Windows).
                                let parts = xolox#misc#path#split(path)
                                if s:windows_compatible && parts[0] =~ '^[\/][\/]'
                                  " Also normalize the two leading "directory separators" (I'm not
                                  " sure what else to call them :-) in Windows UNC pathnames.
                                  let parts[0] = repeat(xolox#misc#path#directory_separator(), 2) . parts[0][2:]
                                elseif s:windows_compatible && parts[0] =~ '^[\/]$'
                                  " If a pathname is relative to the current drive we should add
                                  " the drive letter in order to make the pathname absolute.
                                  let parts[0] = matchstr(getcwd(), '^\a:')
                                endif
                                return xolox#misc#path#join(parts)
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 function! xolox#misc#path#relative(path, base) " {{{1
                              " Make an absolute pathname (the first argument) relative to a directory
                              " (the second argument).
                              let path = xolox#misc#path#split(a:path)
                              let base = xolox#misc#path#split(a:base)
                              while path != [] && base != [] && path[0] == base[0]
                                call remove(path, 0)
                                call remove(base, 0)
                              endwhile
                              let distance = repeat(['..'], len(base))
                              return xolox#misc#path#join(distance + path)
                            endfunction
                            
    1              0.000002 function! xolox#misc#path#merge(parent, child, ...) " {{{1
                              " Join a directory pathname and filename into a single pathname.
                              if type(a:parent) == type('') && type(a:child) == type('')
                                " TODO Use xolox#misc#path#is_relative()?
                                if s:windows_compatible
                                  let parent = substitute(a:parent, '[\\/]\+$', '', '')
                                  let child = substitute(a:child, '^[\\/]\+', '', '')
                                  return parent . '\' . child
                                else
                                  let parent = substitute(a:parent, '/\+$', '', '')
                                  let child = substitute(a:child, '^/\+', '', '')
                                  return parent . '/' . child
                                endif
                              endif
                              return ''
                            endfunction
                            
    1              0.000002 function! xolox#misc#path#commonprefix(paths) " {{{1
                              " Find the common prefix of path components in a list of pathnames.
                              let common = xolox#misc#path#split(a:paths[0])
                              for path in a:paths
                                let index = 0
                                for segment in xolox#misc#path#split(path)
                                  if len(common) <= index
                                    break
                                  elseif common[index] != segment
                                    call remove(common, index, -1)
                                    break
                                  endif
                                  let index += 1
                                endfor
                              endfor
                              return xolox#misc#path#join(common)
                            endfunction
                            
    1              0.000002 function! xolox#misc#path#starts_with(a, b) " {{{1
                              " Check whether the first pathname starts with the second pathname (expected
                              " to be a directory). This does not perform a regular string comparison;
                              " first it normalizes both pathnames, then it splits them into their
                              " pathname segments and then it compares the segments.
                              let a = xolox#misc#path#split(xolox#misc#path#absolute(a:a))
                              let b = xolox#misc#path#split(xolox#misc#path#absolute(a:b))
                              return a[0 : len(b) - 1] == b
                            endfunction
                            
    1              0.000002 function! xolox#misc#path#encode(path) " {{{1
                              " Encode a pathname so it can be used as a filename. This uses URL encoding
                              " to encode special characters.
                              if s:windows_compatible
                                let mask = '[*|\\/:"<>?%]'
                              elseif xolox#misc#os#is_mac()
                                let mask = '[\\/%:]'
                              else
                                let mask = '[\\/%]'
                              endif
                              return substitute(a:path, mask, '\=printf("%%%x", char2nr(submatch(0)))', 'g')
                            endfunction
                            
    1              0.000002 function! xolox#misc#path#decode(encoded_path) " {{{1
                              " Decode a pathname previously encoded with `xolox#misc#path#encode()`.
                              return substitute(a:encoded_path, '%\(\x\x\?\)', '\=nr2char("0x" . submatch(1))', 'g')
                            endfunction
                            
                            " xolox#misc#path#equals(a, b) - Check whether two pathnames point to the same file. {{{1
                            
    1              0.000002 if s:windows_compatible
                              function! xolox#misc#path#equals(a, b)
                                return a:a ==? a:b || xolox#misc#path#absolute(a:a) ==? xolox#misc#path#absolute(a:b)
                              endfunction
    1              0.000002 else
    1              0.000002   function! xolox#misc#path#equals(a, b)
                                return a:a ==# a:b || xolox#misc#path#absolute(a:a) ==# xolox#misc#path#absolute(a:b)
                              endfunction
    1              0.000001 endif
                            
    1              0.000004 function! xolox#misc#path#is_relative(path) " {{{1
                              " Returns true (1) when the pathname given as the first argument is
                              " relative, false (0) otherwise.
                              if a:path =~ '^\w\+://'
                                return 0
                              elseif s:windows_compatible
                                return a:path !~ '^\(\w:\|[\\/]\)'
                              else
                                return a:path !~ '^/'
                              endif
                            endfunction
                            
    1              0.000002 function! xolox#misc#path#tempdir() " {{{1
                              " Create a temporary directory and return the pathname of the directory.
                              if !exists('s:tempdir_counter')
                                let s:tempdir_counter = 1
                              endif
                              if exists('*mkdir')
                                if s:windows_compatible
                                  let template = $TMP . '\vim_tempdir_'
                                elseif filewritable('/tmp') == 2
                                  let template = '/tmp/vim_tempdir_'
                                endif
                              endif
                              if !exists('template')
                                throw "xolox#misc#path#tempdir() hasn't been implemented on your platform!"
                              endif
                              while 1
                                let directory = template . s:tempdir_counter
                                try
                                  call mkdir(directory, '', 0700)
                                  return directory
                                catch /^Vim\%((\a\+)\)\=:E739/
                                  " Keep looking for a non-existing directory.
                                endtry
                                let s:tempdir_counter += 1
                              endwhile
                            endfunction
                            
                            " vim: ts=2 sw=2 et

FUNCTION  deoplete#custom#_get()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/custom.vim:60
Called 2 times
Total time:   0.000719
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000006   if !exists('s:custom')
    1   0.000704   0.000007     call deoplete#custom#_init()
    2              0.000002   endif
                            
    2              0.000003   return s:custom

FUNCTION  airline#extensions#undotree#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/undotree.vim:10
Called 4 times
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    4              0.000009   if exists('t:undotree')
                                if &ft == 'undotree'
                                  if exists('*t:undotree.GetStatusLine')
                                    call airline#extensions#apply_left_override('undo', '%{exists("t:undotree") ? t:undotree.GetStatusLine() : ""}')
                                  else
                                    call airline#extensions#apply_left_override('undotree', '%f')
                                  endif
                                endif
                            
                                if &ft == 'diff' && exists('*t:diffpanel.GetStatusLine')
                                  call airline#extensions#apply_left_override('diff', '%{exists("t:diffpanel") ? t:diffpanel.GetStatusLine() : ""}')
                                endif
    4              0.000001   endif

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:81
Called 10 times
Total time:   0.010369
 Self time:   0.000845

count  total (s)   self (s)
   64              0.000075     for Fn in a:list
   62   0.010073   0.000549       let code = call(Fn, a:000)
   62              0.000068       if code != 0
    8              0.000008         return code
   54              0.000025       endif
   56              0.000035     endfor
    2              0.000002     return 0

FUNCTION  xolox#session#find_current_session()
    Defined: ~/.vim/plugged/vim-session/autoload/xolox/session.vim:942
Called 1 time
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
                              " Find the name of the current tab scoped or global session. Returns a
                              " string. If no session is active an empty string is returned.
    3              0.000006   for variable in ['t:this_session', 'v:this_session']
    2              0.000005     if exists(variable)
    1              0.000003       let filename = eval(variable)
    1              0.000002       if !empty(filename)
                                    let directory = fnamemodify(filename, ':p:h')
                                    if xolox#misc#path#equals(directory, g:session_directory)
                                      return xolox#session#path_to_name(filename)
                                    endif
    1              0.000001       endif
    2              0.000000     endif
    3              0.000003   endfor
    1              0.000001   return ''

FUNCTION  airline#extensions#quickfix#inactive_qf_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:28
Called 4 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    4              0.000023   if getbufvar(a:2.bufnr, '&filetype') is# 'qf' && !empty(airline#util#getwinvar(a:2.winnr, 'quickfix_title', ''))
                                call setwinvar(a:2.winnr, 'airline_section_c', '[%{get(w:, "quickfix_title", "")}] %f %m')
    4              0.000003   endif

FUNCTION  <SNR>166_check_custom_var()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/init.vim:216
Called 3 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    3              0.000006   if !exists(a:old_var)
    3              0.000003     return
                              endif
                            
                              call deoplete#util#print_error( printf('%s is deprecated variable.  '. 'Please use deoplete#custom#var() instead.', a:old_var))
                              call deoplete#custom#var(a:source_name, a:new_var, eval(a:old_var))

FUNCTION  yarp#core#jobstart()
    Defined: ~/.vim/plugged/nvim-yarp/autoload/yarp/core.vim:146
Called 2 times
Total time:   0.002552
 Self time:   0.000071

count  total (s)   self (s)
    2              0.000006     if ! has_key(self, 'cmd')
    1   0.000804   0.000513         call self.init()
    1              0.000002         if ! has_key(self, 'cmd')
                                        call self.error("cmd of the job is not set")
                                        return
    1              0.000001         endif
    2              0.000002     endif
    2              0.000004     if has_key(self, 'job')
    1              0.000001         return
    1              0.000000     endif
    1              0.000008     let opts = {'on_stderr': function('yarp#core#on_stderr'), 'on_exit': function('yarp#core#on_exit'), 'detach': self.job_detach, 'self': self}
    1              0.000001     try
    1   0.000816   0.000030         let self.job = call(s:jobstart, [self.cmd, opts])
    1              0.000002         if self.job == -1
                                        call self.error('Failed starting job: ' . string(self.cmd))
    1              0.000001         endif
                                catch
                                    let self.job = -1
                                    call self.error(['Failed starting job: ' . string(self.cmd), v:exception])
    1              0.000001     endtry

FUNCTION  <SNR>125_is_excluded_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:111
Called 8 times
Total time:   0.000331
 Self time:   0.000331

count  total (s)   self (s)
    8              0.000017   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
    8              0.000007   endfor
                            
   32              0.000035   for matchw in g:airline_exclude_filenames
   24              0.000123     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
   24              0.000014     endif
   32              0.000021   endfor
                            
    8              0.000010   if g:airline_exclude_preview && &previewwindow
                                return 1
    8              0.000003   endif
                            
    8              0.000007   return 0

FUNCTION  deoplete#init#_custom_variables()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/init.vim:147
Called 1 time
Total time:   0.000193
 Self time:   0.000128

count  total (s)   self (s)
    1              0.000003   if get(g:, 'deoplete#disable_auto_complete', v:false)
                                call deoplete#custom#option('auto_complete', v:false)
    1              0.000000   endif
                            
    1   0.000011   0.000007   call s:check_custom_option( 'g:deoplete#auto_complete_delay', 'auto_complete_delay')
    1   0.000009   0.000005   call s:check_custom_option( 'g:deoplete#auto_refresh_delay', 'auto_refresh_delay')
    1   0.000009   0.000006   call s:check_custom_option( 'g:deoplete#camel_case', 'camel_case')
    1   0.000009   0.000005   call s:check_custom_option( 'g:deoplete#ignore_case', 'ignore_case')
    1   0.000009   0.000006   call s:check_custom_option( 'g:deoplete#ignore_sources', 'ignore_sources')
    1   0.000009   0.000006   call s:check_custom_option( 'g:deoplete#keyword_patterns', 'keyword_patterns')
    1   0.000009   0.000006   call s:check_custom_option( 'g:deoplete#max_list', 'max_list')
    1   0.000009   0.000006   call s:check_custom_option( 'g:deoplete#num_processes', 'num_processes')
    1   0.000009   0.000006   call s:check_custom_option( 'g:deoplete#auto_complete_start_length', 'min_pattern_length')
    1   0.000013   0.000009   call s:check_custom_option( 'g:deoplete#enable_on_insert_enter', 'on_insert_enter')
    1   0.000009   0.000006   call s:check_custom_option( 'g:deoplete#enable_profile', 'profile')
    1   0.000009   0.000005   call s:check_custom_option( 'g:deoplete#enable_refresh_always', 'refresh_always')
    1   0.000009   0.000006   call s:check_custom_option( 'g:deoplete#skip_chars', 'skip_chars')
    1   0.000008   0.000005   call s:check_custom_option( 'g:deoplete#sources', 'sources')
    1   0.000009   0.000006   call s:check_custom_option( 'g:deoplete#enable_smart_case', 'smart_case')
    1   0.000009   0.000006   call s:check_custom_option( 'g:deoplete#enable_complete_suffix', 'complete_suffix')
    1   0.000008   0.000005   call s:check_custom_option( 'g:deoplete#enable_yarp', 'yarp')
                            
                              " Source variables
    1   0.000010   0.000007   call s:check_custom_var('file', 'g:deoplete#file#enable_buffer_path', 'enable_buffer_path')
    1   0.000008   0.000005   call s:check_custom_var('omni', 'g:deoplete#omni#input_patterns', 'input_patterns')
    1   0.000008   0.000005   call s:check_custom_var('omni', 'g:deoplete#omni#functions', 'functions')

FUNCTION  <SNR>163_FixList()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:54
Called 1 time
Total time:   0.000073
 Self time:   0.000055

count  total (s)   self (s)
    1   0.000030   0.000012     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
    1              0.000021     let l:new_list = []
                            
    1              0.000003     for l:item in a:list
                                    let l:fixed_item = copy(l:item)
                            
                                    let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
                                    if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
                                    call add(l:new_list, l:fixed_item)
    1              0.000001     endfor
                            
    1              0.000002     return l:new_list

FUNCTION  <SNR>176_clamp_pos()
    Defined: ~/.vim/plugged/vim-anzu/autoload/anzu.vim:71
Called 65 times
Total time:   0.002584
 Self time:   0.001496

count  total (s)   self (s)
   65   0.002527   0.001439 	return s:pos_less_equal(a:min, a:pos) && s:pos_less_equal(a:pos, a:max)

FUNCTION  airline#statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:190
Called 231 times
Total time:   0.003934
 Self time:   0.003934

count  total (s)   self (s)
  231              0.001763   if has_key(s:contexts, a:winnr)
  231              0.001815     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>171_py()
    Defined: ~/.vim/plugged/vim-hug-neovim-rpc/autoload/neovim_rpc.vim:13
Called 2 times
Total time:   0.092102
 Self time:   0.092102

count  total (s)   self (s)
    2              0.092100     execute g:neovim_rpc#py a:cmd

FUNCTION  airline#check_mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:199
Called 231 times
Total time:   0.115040
 Self time:   0.033970

count  total (s)   self (s)
  231              0.001106   if !has_key(s:contexts, a:winnr)
                                return ''
  231              0.000263   endif
  231              0.001011   let context = s:contexts[a:winnr]
                            
  231              0.000851   if get(w:, 'airline_active', 1)
  128              0.000411     let l:m = mode(1)
  128              0.000260     if l:m ==# "i"
                                  let l:mode = ['insert']
  128              0.000371     elseif l:m[0] ==# "i"
                                  let l:mode = ['insert']
  128              0.000225     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
  128              0.000310     elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
  128              0.001266     elseif l:m[0] =~# '\v(v|V||s|S|)'
   10              0.000033       let l:mode = ['visual']
  118              0.000190     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
  118              0.000269     elseif l:m[0] ==# "c"
                                  let l:mode = ['commandline']
  118              0.000199     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
  118              0.000352     elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
  118              0.000109     else
  118              0.000289       let l:mode = ['normal']
  128              0.000111     endif
  128              0.000627     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
  128              0.000102     endif
  128              0.000763     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
  128              0.000373       let l:m = l:m[0]
  128              0.000114     endif
  128              0.000635     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
  103              0.000123   else
  103              0.000276     let l:mode = ['inactive']
  103              0.000536     let w:airline_current_mode = get(g:airline_mode_map, '__')
  231              0.000213   endif
                            
  231              0.000808   if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
  231              0.000205   endif
                            
  231              0.000495   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
  231              0.000199   endif
                            
  231              0.001157   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
  231              0.000229   endif
                            
  231              0.000580   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
  231              0.000186   endif
                            
  231              0.000450   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
  231              0.000197   endif
                            
  231              0.001107   let mode_string = join(l:mode)
  231              0.001030   if get(w:, 'airline_lastmode', '') != mode_string
    6   0.001716   0.000074     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    6   0.079197   0.000083     call airline#highlighter#highlight(l:mode, context.bufnr)
    6   0.000374   0.000060     call airline#util#doautocmd('AirlineModeChanged')
    6              0.000012     let w:airline_lastmode = mode_string
  231              0.000202   endif
                            
  231              0.000308   return ''

FUNCTION  <SNR>91_airline_refresh()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:206
Called 2 times
Total time:   0.103412
 Self time:   0.000269

count  total (s)   self (s)
                              " a:1, fast refresh, do not reload the theme
    2              0.000037   let fast=!empty(get(a:000, 0, 0))
    2              0.000018   if !exists("#airline")
                                " disabled
                                return
    2              0.000004   endif
    2   0.000174   0.000042   call airline#util#doautocmd('AirlineBeforeRefresh')
    2   0.000179   0.000031   call airline#highlighter#reset_hlcache()
    2              0.000005   if !fast
    2   0.085336   0.000083     call airline#load_theme()
    2              0.000001   endif
    2   0.017617   0.000017   call airline#update_statusline()
    2   0.000025   0.000015   call airline#update_tabline()

FUNCTION  <SNR>100_mergelists()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/mrufiles.vim:31
Called 1 time
Total time:   0.000748
 Self time:   0.000441

count  total (s)   self (s)
    1   0.000335   0.000044 	let diskmrufs = ctrlp#utils#readfile(ctrlp#mrufiles#cachefile())
    1              0.000336 	cal filter(diskmrufs, 'index(s:mrufs, v:val) < 0')
    1              0.000037 	let mrufs = s:mrufs + diskmrufs
    1   0.000037   0.000021 	retu s:chop(mrufs)

FUNCTION  airline#util#append()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:48
Called 896 times
Total time:   0.011919
 Self time:   0.011919

count  total (s)   self (s)
  896              0.002613   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  896              0.000741   endif
  896              0.003585   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  896              0.003328   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  gutentags#default_stdout_cb()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim:588
Called 7 times
Total time:   0.000265
 Self time:   0.000171

count  total (s)   self (s)
    7   0.000259   0.000165     call gutentags#trace('[job stdout]: '.string(a:msg))

FUNCTION  gutentags#find_job_index_by_tags_file()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim:373
Called 102 times
Total time:   0.001822
 Self time:   0.001822

count  total (s)   self (s)
  102              0.000267     let l:idx = -1
  102              0.000464     for upd_info in s:update_in_progress[a:module]
                                    let l:idx += 1
                                    if upd_info[0] == a:tags_file
                                        return l:idx
                                    endif
  102              0.000142     endfor
  102              0.000147     return -1

FUNCTION  ctrlp#utils#writecache()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/utils.vim:63
Called 1 time
Total time:   0.001653
 Self time:   0.001634

count  total (s)   self (s)
    1   0.000043   0.000024 	if isdirectory(ctrlp#utils#mkdir(a:0 ? a:1 : s:cache_dir))
    1              0.001599 		sil! cal writefile(a:lines, a:0 >= 2 ? a:2 : ctrlp#utils#cachefile())
    1              0.000009 	en

FUNCTION  airline#mode_changed()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:279
Called 6 times
Total time:   0.000122
 Self time:   0.000090

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    6              0.000049   let g:airline#visual_active = (mode() =~? '[vs]')
    6   0.000064   0.000032   call airline#update_tabline()

FUNCTION  <SNR>165_set_value()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/custom.vim:168
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000004   if type(a:value) == v:t_dict && !empty(a:value)
    1              0.000003     if !has_key(a:dest, a:name)
                                  let a:dest[a:name] = {}
    1              0.000001     endif
    1              0.000004     call extend(a:dest[a:name], a:value)
                              else
                                let a:dest[a:name] = a:value
    1              0.000001   endif

FUNCTION  airline#extensions#fugitiveline#bufname()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:14
Called 231 times
Total time:   0.020403
 Self time:   0.014287

count  total (s)   self (s)
  231              0.000956   if !exists('b:fugitive_name')
    4              0.000007     let b:fugitive_name = ''
    4              0.000003     try
    4              0.000023       if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
    4              0.000016       elseif exists('b:git_dir') && exists('*fugitive#repo')
    3              0.000007         if get(b:, 'fugitive_type', '') is# 'blob'
                                      let b:fugitive_name = fugitive#repo().translate(FugitivePath(@%, ''))
    3              0.000002         endif
    1              0.000004       elseif exists('b:git_dir') && !exists('*fugitive#repo')
    1   0.005054   0.000146         let buffer = fugitive#buffer()
    1   0.000008   0.000007         if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
    1              0.000001         endif
    4              0.000003       endif
                                catch
    4              0.000003     endtry
  231              0.000197   endif
                            
  231   0.003342   0.002135   let fmod = s:ModifierFlags()
  231              0.000672   if empty(b:fugitive_name)
  231              0.002515     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  deoplete#custom#_update_cache()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/custom.vim:27
Called 1 time
Total time:   0.000079
 Self time:   0.000062

count  total (s)   self (s)
    1              0.000002   if !exists('s:custom')
                                call deoplete#custom#_init()
    1              0.000001   endif
                            
    1   0.000023   0.000006   let custom_buffer = deoplete#custom#_get_buffer()
                            
    1              0.000007   let s:cached.option = copy(s:custom.option)
    1              0.000003   let s:cached.buffer_option = copy(custom_buffer.option)
    1              0.000002   call extend(s:cached.option, s:cached.buffer_option)
                            
    1              0.000002   let s:cached.source_vars = {}
    2              0.000005   for [name, source] in items(s:custom.source)
    1              0.000004     let s:cached.source_vars[name] = get(source, 'vars', {})
    2              0.000002   endfor
    1              0.000003   for [name, vars] in items(custom_buffer.source_vars)
                                if !has_key(s:cached.source_vars, name)
                                  let s:cached.source_vars[name] = {}
                                endif
                                call extend(s:cached.source_vars[name], vars)
    1              0.000001   endfor
    1              0.000002   let s:cached.filter = {}
    1              0.000002   for [name, vars] in items(s:custom.filter)
                                let s:cached.filter[name] = vars
    1              0.000001   endfor
    1              0.000002   for [name, vars] in items(custom_buffer.filter)
                                if !has_key(s:cached.filter, name)
                                  let s:cached.filter[name] = {}
                                endif
                                call extend(s:cached.filter[name], vars)
    1              0.000001   endfor

FUNCTION  <SNR>87_CursorHoldUpdate()
    Defined: ~/.vim/plugged/nerdtree-git-plugin/nerdtree_plugin/git_status.vim:263
Called 3 times
Total time:   0.000376
 Self time:   0.000055

count  total (s)   self (s)
    3              0.000010     if g:NERDTreeUpdateOnCursorHold != 1
                                    return
    3              0.000004     endif
                            
    3   0.000347   0.000026     if !g:NERDTree.IsOpen()
    3              0.000004         return
                                endif
                            
                                " Do not update when a special buffer is selected
                                if !empty(&l:buftype)
                                    return
                                endif
                            
                                let l:winnr = winnr()
                                let l:altwinnr = winnr('#')
                            
                                call g:NERDTree.CursorToTreeWin()
                                call b:NERDTree.root.refreshFlags()
                                call NERDTreeRender()
                            
                                exec l:altwinnr . 'wincmd w'
                                exec l:winnr . 'wincmd w'

FUNCTION  <SNR>169_unescape()
    Defined: ~/.vim/plugged/vim-misc/autoload/xolox/misc/option.vim:43
Called 4 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    4              0.000015   return substitute(a:s, '\\\([\\,]\)', '\1', 'g')

FUNCTION  airline#extensions#vista#currenttag()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/vista.vim:6
Called 102 times
Total time:   0.000801
 Self time:   0.000801

count  total (s)   self (s)
  102              0.000373   if get(w:, 'airline_active', 0)
                                return get(b:, 'vista_nearest_method_or_function', '')
  102              0.000095   endif

FUNCTION  gutentags#find_job_index_by_data()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim:384
Called 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000007     let l:idx = -1
    1              0.000009     for upd_info in s:update_in_progress[a:module]
    1              0.000005         let l:idx += 1
    1              0.000011         if upd_info[1] == a:data
    1              0.000004             return l:idx
                                    endif
                                endfor
                                return -1

FUNCTION  fugitive#buffer()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:1463
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000006   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
    1              0.000004   call extend(buffer, s:buffer_prototype, 'keep')
    1              0.000001   return buffer

FUNCTION  <SNR>91_FocusGainedHandler()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:222
Called 1 time
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000021   if exists("s:timer") && a:timer == s:timer
    1              0.000007     augroup airline
    1              0.000020       au FocusGained * unlet! w:airline_lastmode | :call <sid>airline_refresh()
    1              0.000002     augroup END
    1              0.000002   endif

FUNCTION  xolox#misc#path#decode()
    Defined: ~/.vim/plugged/vim-misc/autoload/xolox/misc/path.vim:222
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
                              " Decode a pathname previously encoded with `xolox#misc#path#encode()`.
    1              0.000012   return substitute(a:encoded_path, '%\(\x\x\?\)', '\=nr2char("0x" . submatch(1))', 'g')

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:102
Called 102 times
Total time:   0.002859
 Self time:   0.001346

count  total (s)   self (s)
  102   0.002790   0.001277   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/netrw.vim:10
Called 4 times
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
    4              0.000015   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
    4              0.000002   endif

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim:10
Called 4 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
    4              0.000017   if &buftype == 'terminal' || bufname('%')[0] == '!'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.s:section_a.spc)
                                call a:1.add_section('airline_b', '')
                                call a:1.add_section('airline_term', spc.s:termname())
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section('airline_z', spc.airline#section#create_right(['linenr', 'maxlinenr']))
                                return 1
    4              0.000003   endif

FUNCTION  deoplete#custom#_init()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/custom.vim:7
Called 1 time
Total time:   0.000697
 Self time:   0.000179

count  total (s)   self (s)
    1              0.000003   let s:custom = {}
    1              0.000002   let s:custom.source = {}
    1              0.000003   let s:custom.source._ = {}
    1   0.000676   0.000158   let s:custom.option = deoplete#init#_option()
    1              0.000002   let s:custom.filter = {}
                            
    1              0.000002   let s:cached = {}
    1              0.000002   let s:cached.option = {}
    1              0.000002   let s:cached.filter = {}
    1              0.000002   let s:cached.buffer_option = {}
    1              0.000002   let s:cached.source_vars = {}

FUNCTION  sy#verbose()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy.vim:126
Called 3 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    3              0.000006   if &verbose
                                if type(a:msg) == type([])
                                  for msg in a:msg
                                    echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), msg)
                                  endfor
                                else
                                  echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), a:msg)
                                endif
    3              0.000003   endif

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:273
Called 75 times
Total time:   0.000708
 Self time:   0.000708

count  total (s)   self (s)
   75              0.000347   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
   75              0.000082   endif

FUNCTION  xolox#misc#path#join()
    Defined: ~/.vim/plugged/vim-misc/autoload/xolox/misc/path.vim:91
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
                              " Join a list of pathname components (the first and only argument) into a
                              " single pathname string. This is the counterpart to the
                              " `xolox#misc#path#split()` function and it expects a list of pathname
                              " components as returned by `xolox#misc#path#split()`.
    1              0.000003   if type(a:parts) == type([])
    1              0.000001     if s:windows_compatible
                                  return join(a:parts, xolox#misc#path#directory_separator())
    1              0.000004     elseif get(a:parts, 0) == '/'
                                  " Absolute path on UNIX (non-Windows).
    1              0.000008       return '/' . join(a:parts[1:], '/')
                                else
                                  " Relative path on UNIX (non-Windows).
                                  return join(a:parts, '/')
                                endif
                              endif
                              return ''

FUNCTION  <SNR>166_check_custom_option()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/init.vim:226
Called 17 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
   17              0.000038   if !exists(a:old_var)
   17              0.000009     return
                              endif
                            
                              call deoplete#util#print_error( printf('%s is deprecated variable.  '. 'Please use deoplete#custom#option() instead.', a:old_var))
                              call deoplete#custom#option(a:new_var, eval(a:old_var))

FUNCTION  deoplete#custom#_init_buffer()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/custom.vim:20
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000002   let b:custom = {}
    1              0.000002   let b:custom.option = {}
    1              0.000002   let b:custom.source_vars = {}
    1              0.000001   let b:custom.filter = {}

FUNCTION  <SNR>174_py3exe()
    Defined: ~/.vim/plugged/nvim-yarp/autoload/yarp/pyx.vim:42
Called 1 time
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    1              0.000003     if get(g:, '_yarp_py3', '')
                                    return g:_yarp_py3
    1              0.000000     endif
    1              0.000021     let g:_yarp_py3 = expand(get(g:, 'python3_host_prog', ''), 1)
    1              0.000006     if g:_yarp_py3 == '' && has('nvim') && has('python3')
                                    " heavy weight
                                    " but better support for python detection
                                    python3 import sys
                                    let g:_yarp_py3 = py3eval('sys.executable')
    1              0.000001     endif
    1              0.000002     if g:_yarp_py3 == ''
    1              0.000002         let g:_yarp_py3 = 'python3'
    1              0.000000     endif
    1              0.000009     if exepath(g:_yarp_py3) == ''
                                    call self.error( "Python3 executable [" . g:_yarp_py3 . "] not found.")
                                    if has('vim_starting')
                                        call self.error("")
                                    endif
                                    call self.error("###### Please configure g:python3_host_prog properly ######")
                                    if has('vim_starting')
                                        call self.error("")
                                    endif
    1              0.000000     endif
    1              0.000002     return g:_yarp_py3

FUNCTION  <SNR>131_get_array()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:56
Called 692 times
Total time:   0.005281
 Self time:   0.005281

count  total (s)   self (s)
  692              0.002278   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  692              0.002709   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  deoplete#util#string()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/util.vim:23
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000019   return type(a:expr) ==# v:t_string ? a:expr : string(a:expr)

FUNCTION  yarp#core#error()
    Defined: ~/.vim/plugged/nvim-yarp/autoload/yarp/core.vim:176
Called 2 times
Total time:   0.000256
 Self time:   0.000256

count  total (s)   self (s)
    2              0.000011     if mode() == 'i'
                                    " NOTE: side effect, sorry, but this is necessary
                                    set nosmd
    2              0.000003     endif
    2              0.000012     if type(a:msg) == type("")
    1              0.000011         let lines = split(a:msg, "\n", 1)
    1              0.000001     else
    1              0.000004         let lines = a:msg
    2              0.000004     endif
    2              0.000042     echoh ErrorMsg
   12              0.000028     for line in lines
   10              0.000079         echom '[' . a:mod . '@yarp] ' . line
   12              0.000020     endfor
    2              0.000011     echoh None

FUNCTION  <SNR>148_get_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:158
Called 24 times
Total time:   0.017565
 Self time:   0.000402

count  total (s)   self (s)
   24   0.005786   0.000184   if airline#builder#should_change_group(a:prev_group, a:group)
   24   0.011766   0.000205     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  airline#extensions#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:71
Called 8 times
Total time:   0.000739
 Self time:   0.000408

count  total (s)   self (s)
    8              0.000026   let filetype_overrides = get(s:, 'filetype_overrides', {})
    8              0.000033   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
    8   0.000374   0.000043   if s:is_excluded_window()
                                return -1
    8              0.000005   endif
                            
    8              0.000012   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
    8              0.000003   endif
                            
    8              0.000007   if &previewwindow
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
    8              0.000003   endif
                            
    8              0.000051   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
                                let args = filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
    8              0.000004   endif
                            
    8              0.000010   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
    8              0.000003   endif
                            
    8              0.000022   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
    8              0.000006   endfor

FUNCTION  ctrlp#utils#readfile()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/utils.vim:44
Called 1 time
Total time:   0.000268
 Self time:   0.000268

count  total (s)   self (s)
    1              0.000036 	if filereadable(a:file)
    1              0.000212 		let data = readfile(a:file)
    1              0.000008 		if empty(data) || type(data) != 3
                            			unl data
                            			let data = []
    1              0.000002 		en
    1              0.000003 		retu data
                            	en
                            	retu []

FUNCTION  <SNR>131_exec_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:189
Called 102 times
Total time:   0.049626
 Self time:   0.004212

count  total (s)   self (s)
  102              0.000181   if pumvisible()
                                return
  102              0.000055   endif
  102              0.000293   let group = a:from.'_to_'.a:to.a:suffix
  102   0.013223   0.000770   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  102   0.012459   0.000777   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  102              0.000125   if a:inverse
   28              0.000137     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   74              0.000045   else
   74              0.000353     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  102              0.000064   endif
  102              0.000231   let a:dict[group] = colors
  102   0.022035   0.000756   call airline#highlighter#exec(group, colors)

FUNCTION  ale#ShouldDoNothing()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:32
Called 65 times
Total time:   0.002584
 Self time:   0.002584

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
   65              0.000458     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
   65              0.000058     endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
   65              0.000351     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
   65              0.000061     endif
                            
   65              0.000378     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
   65              0.000148     if l:filetype is# ''
                                    return 1
   65              0.000061     endif
                            
                                " Do nothing for diff buffers.
   65              0.000248     if getbufvar(a:buffer, '&diff')
   65              0.000089         return 1
                                endif
                            
                                " Do nothing for blacklisted files.
                                if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
                                endif
                            
                                " Do nothing if running from command mode.
                                if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
                                let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
                                if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Don't start linting and so on when an operator is pending.
                                if ale#util#Mode(1) is# 'no'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox.
                                if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
                                if ale#FileTooLarge(a:buffer)
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
                                if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
                                return 0

FUNCTION  xolox#session#get_names()
    Defined: ~/.vim/plugged/vim-session/autoload/xolox/session.vim:902
Called 1 time
Total time:   0.002815
 Self time:   0.002202

count  total (s)   self (s)
                              " Get the names of all available sessions. This scans the directory
                              " configured with `g:session_directory` for files that end with the suffix
                              " configured with `g:session_extension`, takes the base name of each file
                              " and decodes any URL encoded characters. Returns a list of strings.
                              "
                              " If the first argument is true (1) then the user defined function
                              " configured with `g:session_name_suggestion_function` is called to find
                              " suggested session names, which are prefixed to the list of available
                              " sessions, otherwise the argument should be false (0).
    1   0.002608   0.002075   let directory = xolox#misc#path#absolute(g:session_directory)
    1   0.000126   0.000080   let filenames = split(glob(xolox#misc#path#merge(directory, '*' . g:session_extension)), "\n")
    1   0.000062   0.000028   call map(filenames, 'xolox#session#path_to_name(v:val)')
    1              0.000004   if a:include_suggestions && !empty(g:session_name_suggestion_function)
                                let suggested_names = call(g:session_name_suggestion_function, [])
                                let filenames = suggested_names + filenames
    1              0.000001   endif
    1              0.000001   return filenames

FUNCTION  airline#extensions#po#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/po.vim:51
Called 4 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    4              0.000018   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
    4              0.000003   endif

FUNCTION  <SNR>140_ws_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim:178
Called 3 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    3              0.000017   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    2              0.000003     return
    1              0.000002   endif
    1              0.000004   unlet! b:airline_whitespace_check
    1              0.000005   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
    1              0.000001   endif
    1              0.000006   let b:airline_ws_changedtick = b:changedtick

FUNCTION  xolox#session#is_empty()
    Defined: ~/.vim/plugged/vim-session/autoload/xolox/session.vim:426
Called 1 time
Total time:   0.000592
 Self time:   0.000219

count  total (s)   self (s)
                              " Check that the user has started Vim without editing any files. Used by
                              " `xolox#session#auto_load()` to determine whether automatic session loading
                              " should be performed. Currently checks the following conditions:
                              "
                              " 1. That the current buffer is either empty (contains no lines and is not
                              "    modified) or showing [vim-startify] [].
                              " 2. That the buffer list either empty or persistent.
                              "
                              " [vim-startify]: https://github.com/mhinz/vim-startify/
    1              0.000064   let current_buffer_is_empty = (&modified == 0 && getline(1, '$') == [''])
    1              0.000002   let current_buffer_is_startify = (&filetype == 'startify')
    1              0.000007   let buffer_list_is_empty = (bufname('%') == '' && empty(filter(range(1, bufnr('$')), 'buflisted(v:val) && v:val != ' . bufnr(''))))
    1   0.000511   0.000138   let buffer_list_is_persistent = (index(xolox#misc#option#split(&viminfo), '%') >= 0)
    1              0.000003   return (current_buffer_is_empty || current_buffer_is_startify) && (buffer_list_is_empty || buffer_list_is_persistent)

FUNCTION  anzu#search_status()
    Defined: ~/.vim/plugged/vim-anzu/autoload/anzu.vim:7
Called 102 times
Total time:   0.001430
 Self time:   0.001430

count  total (s)   self (s)
  102              0.001329 	return substitute(s:status_cache, '<anzustatushighlight>.\{-}<\/anzustatushighlight>', "", "g")

FUNCTION  gutentags#remove_job()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim:403
Called 1 time
Total time:   0.000162
 Self time:   0.000143

count  total (s)   self (s)
    1              0.000011     let l:tags_file = s:update_in_progress[a:module][a:job_idx][0]
    1              0.000012     call remove(s:update_in_progress[a:module], a:job_idx)
                            
                                " Run the user callback for finished jobs.
    1   0.000039   0.000033     silent doautocmd User GutentagsUpdated
                            
                                " See if we had any more updates queued up for this.
    1              0.000004     let l:qu_idx = -1
    1              0.000007     for qu_info in s:update_queue[a:module]
                                    let l:qu_idx += 1
                                    if qu_info[0] == l:tags_file
                                        break
                                    endif
    1              0.000002     endfor
    1              0.000003     if l:qu_idx >= 0
                                    let l:qu_info = s:update_queue[a:module][l:qu_idx]
                                    call remove(s:update_queue[a:module], l:qu_idx)
                            
                                    if bufexists(l:qu_info[1])
                                        call gutentags#trace("Finished ".a:module." job, "."running queued update for '".l:tags_file."'.")
                                        call s:update_tags(l:qu_info[1], a:module, l:qu_info[2], 2)
                                    else
                                        call gutentags#trace("Finished ".a:module." job, "."but skipping queued update for '".l:tags_file."' "."because originating buffer doesn't exist anymore.")
                                    endif
    1              0.000001     else
    1   0.000029   0.000016         call gutentags#trace("Finished ".a:module." job.")
    1              0.000001     endif

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:18
Called 266 times
Total time:   0.003452
 Self time:   0.003452

count  total (s)   self (s)
  266              0.001058   let nr = get(a:000, 0, 0)
  266              0.000815   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
  266              0.000254   else
  266              0.000736     return winwidth(nr)
                              endif

FUNCTION  deoplete#util#rpcnotify()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/util.vim:155
Called 1 time
Total time:   0.000035
 Self time:   0.000030

count  total (s)   self (s)
    1   0.000032   0.000027   if !deoplete#init#_channel_initialized()
    1              0.000001     return ''
                              endif
                            
                              let a:context['rpc'] = a:method
                            
                              if deoplete#util#has_yarp()
                                if g:deoplete#_yarp.job_is_dead
                                  return ''
                                endif
                                call g:deoplete#_yarp.notify(a:method, a:context)
                              else
                                call rpcnotify(g:deoplete#_channel_id, a:method, a:context)
                              endif
                            
                              return ''

FUNCTION  xolox#session#path_to_name()
    Defined: ~/.vim/plugged/vim-session/autoload/xolox/session.vim:892
Called 1 time
Total time:   0.000034
 Self time:   0.000022

count  total (s)   self (s)
                              " Convert the absolute pathname of a session script (the first argument,
                              " expected to be a string) to a session name. This function assumes the
                              " absolute pathname refers to the configured session directory, but it does
                              " not check for it nor does it require it (it simple takes the base name
                              " of the absolute pathname of the session script and decodes it). Returns a
                              " string.
    1   0.000031   0.000019   return xolox#misc#path#decode(fnamemodify(a:path, ':t:r'))

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:156
Called 8 times
Total time:   0.000446
 Self time:   0.000157

count  total (s)   self (s)
    8   0.000440   0.000151   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  xolox#misc#msg#debug()
    Defined: ~/.vim/plugged/vim-misc/autoload/xolox/misc/msg.vim:48
Called 6 times
Total time:   0.000112
 Self time:   0.000112

count  total (s)   self (s)
                              " Show a formatted debugging message to the user, *if the user has enabled
                              " increased verbosity by setting Vim's ['verbose'] [] option to one
                              " (1) or higher*.
                              "
                              " This function has the same argument handling as the
                              " `xolox#misc#msg#info()` function.
                              "
                              " In the case of `xolox#misc#msg#debug()`, automatic string coercion
                              " provides lazy evaluation in the sense that complex data structures are
                              " only converted to strings when the user has enabled increased verbosity.
                              "
                              " ['verbose']: http://vimdoc.sourceforge.net/htmldoc/options.html#'verbose'
    6              0.000032   if &vbs >= 1
                                call s:show_message('Question', a:000)
    6              0.000009   endif

FUNCTION  nerdtree#checkForBrowse()
    Defined: ~/.vim/plugged/nerdtree/autoload/nerdtree.vim:71
Called 1 time
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    1              0.000017     if !isdirectory(a:dir)
    1              0.000002         return
                                endif
                            
                                if s:reuseWin(a:dir)
                                    return
                                endif
                            
                                call g:NERDTreeCreator.CreateWindowTree(a:dir)

FUNCTION  airline#load_theme()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:39
Called 2 times
Total time:   0.085253
 Self time:   0.000200

count  total (s)   self (s)
    2              0.000018   let g:airline_theme = get(g:, 'airline_theme', 'dark')
    2              0.000022   if exists('*airline#themes#{g:airline_theme}#refresh')
                                call airline#themes#{g:airline_theme}#refresh()
    2              0.000003   endif
                            
    2              0.000014   let palette = g:airline#themes#{g:airline_theme}#palette
    2   0.001291   0.000027   call airline#themes#patch(palette)
                            
    2              0.000012   if exists('g:airline_theme_patch_func')
                                let Fn = function(g:airline_theme_patch_func)
                                call Fn(palette)
    2              0.000002   endif
                            
    2   0.061761   0.000033   call airline#highlighter#load_theme()
    2   0.004240   0.000020   call airline#extensions#load_theme()
    2   0.017855   0.000014   call airline#update_statusline()

FUNCTION  airline#extensions#anzu#apply()
    Defined: ~/.vim/plugged/vim-anzu/autoload/airline/extensions/anzu.vim:11
Called 4 times
Total time:   0.000107
 Self time:   0.000031

count  total (s)   self (s)
    4   0.000105   0.000029 	call airline#extensions#append_to_section("y", " %{anzu#search_status()}")

FUNCTION  deoplete#init#_option()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/init.vim:237
Called 1 time
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
                              " Note: HTML omni func use search().
    1              0.000025   return { 'auto_complete': v:true, 'auto_complete_delay': 0, 'auto_complete_popup': 'auto', 'auto_refresh_delay': 100, 'camel_case': v:false, 'candidate_marks': [], 'check_stderr': v:true, 'complete_suffix': v:true, 'ignore_case': &ignorecase, 'ignore_sources': {}, 'keyword_patterns': {'_': '[a-zA-Z_]\k*'}, 'max_list': 500, 'min_pattern_length': 2, 'num_processes': 4, 'omni_patterns': {}, 'on_insert_enter': v:true, 'on_text_changed_i': v:true, 'prev_completion_mode': '', 'profile': v:false, 'refresh_always': v:true, 'skip_chars': ['(', ')'], 'skip_multibyte': v:false, 'smart_case': &smartcase, 'sources': {}, 'trigger_key': v:char, 'yarp': v:false, }

FUNCTION  anzu#get_on_pattern_pos()
    Defined: ~/.vim/plugged/vim-anzu/autoload/anzu.vim:76
Called 65 times
Total time:   0.014524
 Self time:   0.011197

count  total (s)   self (s)
   65              0.000176 	if a:pat == ""
                            		return getpos(".")
   65              0.000071 	endif
   65              0.000315 	let pos = getpos(".")
   65              0.004091 	let first = searchpos(a:pat, 'nWbc')
   65              0.003356 	let last  = searchpos(a:pat, 'nWeb')
   65   0.001681   0.000938 	if s:pos_less_equal(last, first)
    1              0.000228 		let last  = searchpos(a:pat, 'nWec')
   65              0.000082 	endif
   65   0.003510   0.000926 	if s:clamp_pos(pos[1:2], first, last)
    1              0.000006 		return [0, first[0], first[1], 0]
   64              0.000075 	endif
   64              0.000120 	return pos

FUNCTION  deoplete#util#print_error()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/util.vim:7
Called 2 times
Total time:   0.000194
 Self time:   0.000173

count  total (s)   self (s)
    2              0.000011   let name = a:0 ? a:1 : 'deoplete'
    2   0.000181   0.000160   echohl Error | echomsg printf('[%s] %s', name, deoplete#util#string(a:string)) | echohl None

FUNCTION  deoplete#handler#_init()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/handler.vim:7
Called 1 time
Total time:   0.000964
 Self time:   0.000695

count  total (s)   self (s)
    1              0.000007   augroup deoplete
    1              0.000366     autocmd!
    1              0.000020     autocmd InsertLeave * call s:on_insert_leave()
    1              0.000010     autocmd CompleteDone * call s:on_complete_done()
    1              0.000002   augroup END
                            
    5              0.000020   for event in [ 'InsertEnter', 'BufReadPost', 'BufWritePost', 'VimLeavePre', ]
    4   0.000228   0.000084     call s:define_on_event(event)
    5              0.000009   endfor
                            
    1   0.000024   0.000015   if deoplete#custom#_get_option('on_text_changed_i')
    1   0.000053   0.000017     call s:define_completion_via_timer('TextChangedI')
    1              0.000002   endif
    1   0.000019   0.000013   if deoplete#custom#_get_option('on_insert_enter')
    1   0.000044   0.000016     call s:define_completion_via_timer('InsertEnter')
    1              0.000002   endif
    1   0.000018   0.000013   if deoplete#custom#_get_option('refresh_always')
    1              0.000007     if exists('##TextChangedP')
    1   0.000047   0.000016       call s:define_completion_via_timer('TextChangedP')
                                else
                                  call s:define_completion_via_timer('InsertCharPre')
    1              0.000001     endif
    1              0.000002   endif
                            
                              " Note: Vim 8 GUI(MacVim and Win32) is broken
                              " dummy timer call is needed before complete()
    1              0.000016   if !has('nvim') && has('gui_running') && (has('gui_macvim') || has('win32'))
                                let s:dummy_timer = timer_start(200, {timer -> 0}, {'repeat': -1})
    1              0.000001   endif
                            
    1   0.000022   0.000012   if deoplete#util#has_yarp()
                                " To fix "RuntimeError: Event loop is closed" issue
                                " Note: Workaround
    1              0.000008     autocmd deoplete VimLeavePre * call s:kill_yarp()
    1              0.000001   endif

FUNCTION  xolox#misc#path#merge()
    Defined: ~/.vim/plugged/vim-misc/autoload/xolox/misc/path.vim:164
Called 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
                              " Join a directory pathname and filename into a single pathname.
    1              0.000006   if type(a:parent) == type('') && type(a:child) == type('')
                                " TODO Use xolox#misc#path#is_relative()?
    1              0.000002     if s:windows_compatible
                                  let parent = substitute(a:parent, '[\\/]\+$', '', '')
                                  let child = substitute(a:child, '^[\\/]\+', '', '')
                                  return parent . '\' . child
    1              0.000000     else
    1              0.000017       let parent = substitute(a:parent, '/\+$', '', '')
    1              0.000007       let child = substitute(a:child, '^/\+', '', '')
    1              0.000003       return parent . '/' . child
                                endif
                              endif
                              return ''

FUNCTION  <SNR>108_Highlight_Matching_Pair()
    Defined: /usr/share/vim/vim81/plugin/matchparen.vim:39
Called 67 times
Total time:   0.011581
 Self time:   0.011581

count  total (s)   self (s)
                              " Remove any previous match.
   67              0.000365   if exists('w:paren_hl_on') && w:paren_hl_on
    1              0.000003     silent! call matchdelete(3)
    1              0.000002     let w:paren_hl_on = 0
   67              0.000073   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   67              0.000430   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   67              0.000068   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   67              0.000282   let c_lnum = line('.')
   67              0.000251   let c_col = col('.')
   67              0.000150   let before = 0
                            
   67              0.000314   let text = getline(c_lnum)
   67              0.001379   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   67              0.000212   if empty(matches)
                                let [c_before, c] = ['', '']
   67              0.000085   else
   67              0.000472     let [c_before, c] = matches[1:2]
   67              0.000080   endif
   67              0.001284   let plist = split(&matchpairs, '.\zs[:,]')
   67              0.000339   let i = index(plist, c)
   67              0.000143   if i < 0
                                " not found, in Insert mode try character before the cursor
   66              0.000298     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
   66              0.000074     endif
   66              0.000116     if i < 0
                                  " not found, nothing to do
   66              0.000103       return
                                endif
    1              0.000002   endif
                            
                              " Figure out the arguments for searchpairpos().
    1              0.000005   if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
    1              0.000004   else
    1              0.000009     let s_flags = 'nbW'
    1              0.000011     let c2 = c
    1              0.000016     let c = plist[i - 1]
    1              0.000003   endif
    1              0.000004   if c == '['
                                let c = '\['
                                let c2 = '\]'
    1              0.000002   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    1              0.000004   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
    1              0.000003   endif
                            
    1              0.000019   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    1              0.000002   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
    1              0.000014     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    1              0.000003     try
    1              0.001496       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
    1              0.000002     endtry
    1              0.000002   endif
                            
                              " Limit the search to lines visible in the window.
    1              0.000008   let stoplinebottom = line('w$')
    1              0.000006   let stoplinetop = line('w0')
    1              0.000004   if i % 2 == 0
                                let stopline = stoplinebottom
    1              0.000001   else
    1              0.000005     let stopline = stoplinetop
    1              0.000002   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    1              0.000007   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    1              0.000002   else
    1              0.000010     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    1              0.000001   endif
    1              0.000002   try
    1              0.001278     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    1              0.000002   endtry
                            
    1              0.000003   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
    1              0.000001   endif
                            
                              " If a match is found setup match highlighting.
    1              0.000006   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    1              0.000006     if exists('*matchaddpos')
    1              0.000044       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
    1              0.000001     endif
    1              0.000005     let w:paren_hl_on = 1
    1              0.000001   endif

FUNCTION  deoplete#custom#option()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/custom.vim:152
Called 2 times
Total time:   0.000810
 Self time:   0.000048

count  total (s)   self (s)
    2   0.000739   0.000020   let custom = deoplete#custom#_get().option
    2   0.000070   0.000027   call s:set_custom(custom, a:name_or_dict, get(a:000, 0, ''))

FUNCTION  xolox#misc#path#split()
    Defined: ~/.vim/plugged/vim-misc/autoload/xolox/misc/path.vim:49
Called 1 time
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
                              " Split a pathname (the first and only argument) into a list of pathname
                              " components.
                              "
                              " On Windows, pathnames starting with two slashes or backslashes are UNC
                              " paths where the leading slashes are significant... In this case we split
                              " like this:
                              "
                              " - Input: `'//server/share/directory'`
                              " - Result: `['//server', 'share', 'directory']`
                              "
                              " Everything except Windows is treated like UNIX until someone has a better
                              " suggestion :-). In this case we split like this:
                              "
                              " - Input: `'/foo/bar/baz'`
                              " - Result: `['/', 'foo', 'bar', 'baz']`
                              "
                              " To join a list of pathname components back into a single pathname string,
                              " use the `xolox#misc#path#join()` function.
    1              0.000003   if type(a:path) == type('')
    1              0.000001     if s:windows_compatible
                                  if a:path =~ '^[\/][\/]'
                                    " UNC pathname.
                                    return split(a:path, '\%>2c[\/]\+')
                                  else
                                    " If it's not a UNC pathname we can simply split on slashes and
                                    " backslashes, although we should preserve a leading slash (which
                                    " denotes a pathname that is 'absolute to the current drive').
                                    let absolute = (a:path =~ '^[\/]')
                                    let segments = split(a:path, '[\/]\+')
                                    return absolute ? insert(segments, a:path[0]) : segments
                                  endif
    1              0.000001     else
                                  " Everything else is treated as UNIX.
    1              0.000011       let absolute = (a:path =~ '^/')
    1              0.000027       let segments = split(a:path, '/\+')
    1              0.000004       return absolute ? insert(segments, '/') : segments
                                endif
                              endif
                              return []

FUNCTION  deoplete#init#_channel_initialized()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/init.vim:97
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004   return get(g:, 'deoplete#_initialized', v:false)

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:79
Called 8 times
Total time:   0.003998
 Self time:   0.000456

count  total (s)   self (s)
    8              0.000016   let winnr = a:context.winnr
    8              0.000012   let active = a:context.active
                            
    8   0.000082   0.000057   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    4   0.000864   0.000029     call s:build_sections(a:builder, a:context, s:layout[0])
    4              0.000003   else
    4   0.000168   0.000024     let text = s:get_section(winnr, 'c')
    4              0.000007     if empty(text)
                                  let text = ' %f%m '
    4              0.000002     endif
    4   0.000039   0.000024     call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    8              0.000004   endif
                            
    8   0.000397   0.000084   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    8   0.000064   0.000043   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    8   0.002261   0.000072     call s:build_sections(a:builder, a:context, s:layout[1])
    8              0.000007   endif
                            
    8              0.000007   return 1

FUNCTION  276()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:17
Called 40 times
Total time:   0.000132
 Self time:   0.000132

count  total (s)   self (s)
   40              0.000124   call add(self._sections, [a:group, a:contents])

FUNCTION  <SNR>175_define_on_event()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/handler.vim:292
Called 4 times
Total time:   0.000144
 Self time:   0.000144

count  total (s)   self (s)
    4              0.000033   if !exists('##' . a:event)
                                return
    4              0.000004   endif
                            
    4              0.000094   execute 'autocmd deoplete' a:event '* if !&l:previewwindow | call deoplete#send_event(' .string(a:event).') | endif'

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/.vim/plugged/ale/autoload/ale/engine.vim:100
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000004     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    1              0.000006     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:220
Called 32 times
Total time:   0.014720
 Self time:   0.000379

count  total (s)   self (s)
   32              0.000122   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   32   0.014583   0.000242   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:41
Called 563 times
Total time:   0.004284
 Self time:   0.004284

count  total (s)   self (s)
  563              0.001832   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  563              0.000481   endif
  563              0.000902   return a:text

FUNCTION  xolox#misc#path#absolute()
    Defined: ~/.vim/plugged/vim-misc/autoload/xolox/misc/path.vim:115
Called 1 time
Total time:   0.000209
 Self time:   0.000109

count  total (s)   self (s)
                              " Canonicalize and resolve a pathname, *regardless of whether it exists*.
                              " This is intended to support string comparison to determine whether two
                              " pathnames point to the same directory or file.
    1              0.000007   if type(a:path) == type('')
    1              0.000002     let path = a:path
                                " Make the pathname absolute.
    1              0.000012     if path =~ '^\~'
                                  " Expand ~ to $HOME.
    1              0.000010       let path = $HOME . '/' . path[1:]
                                elseif xolox#misc#path#is_relative(path)
                                  " Make relative pathnames absolute.
                                  let path = getcwd() . '/' . path
    1              0.000001     endif
                                " Resolve symbolic links to find the canonical pathname. In my tests this
                                " also removes all symbolic pathname segments (`.' and `..'), even when
                                " the pathname does not exist. Also there used to be a bug in resolve()
                                " where it wouldn't resolve pathnames ending in a directory separator.
                                " Since it's not much trouble to work around, that's what we do.
    1              0.000033     let path = resolve(substitute(path, s:windows_compatible ? '[\/]\+$' : '/\+$', '', ''))
                                " Normalize directory separators (especially relevant on Windows).
    1   0.000094   0.000014     let parts = xolox#misc#path#split(path)
    1              0.000002     if s:windows_compatible && parts[0] =~ '^[\/][\/]'
                                  " Also normalize the two leading "directory separators" (I'm not
                                  " sure what else to call them :-) in Windows UNC pathnames.
                                  let parts[0] = repeat(xolox#misc#path#directory_separator(), 2) . parts[0][2:]
    1              0.000002     elseif s:windows_compatible && parts[0] =~ '^[\/]$'
                                  " If a pathname is relative to the current drive we should add
                                  " the drive letter in order to make the pathname absolute.
                                  let parts[0] = matchstr(getcwd(), '^\a:')
    1              0.000000     endif
    1   0.000031   0.000011     return xolox#misc#path#join(parts)
                              endif
                              return ''

FUNCTION  airline#extensions#tagbar#inactive_apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tagbar.vim:23
Called 4 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    4              0.000013   if getwinvar(a:2.winnr, '&filetype') == 'tagbar'
                                return -1
    4              0.000001   endif

FUNCTION  <SNR>97_update_search_status()
    Defined: ~/.vim/plugged/vim-anzu/plugin/anzu.vim:22
Called 67 times
Total time:   0.029237
 Self time:   0.005753

count  total (s)   self (s)
   67              0.000230 	if mode() !=# 'n'
    2              0.000004 		return
   65              0.000072 	endif
                            
   65              0.000409 	let curs_hold = get(g:, 'anzu_enable_CursorHold_AnzuUpdateSearchStatus', 0)
   65              0.000364 	let curs_mov	= get(g:, 'anzu_enable_CursorMoved_AnzuUpdateSearchStatus', 0)
                            
   65              0.000293 	let anzu_echo_output = (curs_hold == 1 || curs_mov == 1)
                            
   65              0.000102 	try
   65              0.000160 		if curs_hold || curs_mov
   65   0.026078   0.002594 			if anzu#update(@/,	anzu#get_on_pattern_pos(@/), s:wrapscan_mes()) != -1	 && anzu_echo_output
                            				call feedkeys("\<Plug>(anzu-echohl_search_status)")
   65              0.000071 			endif
   65              0.000058 		endif
                            	catch /^Vim\%((\a\+)\)\=:E/
                            		echohl ErrorMsg | echo matchstr(v:exception, '^Vim(\a\+):\zs.*\ze$') | echohl None
                            		return
   65              0.000102 	endtry

FUNCTION  yarp#core#serveraddr()
    Defined: ~/.vim/plugged/nvim-yarp/autoload/yarp/core.vim:172
Called 1 time
Total time:   0.000015
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000014   0.000008     return call (s:serveraddr, [])

FUNCTION  deoplete#init#_channel()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/init.vim:36
Called 1 time
Total time:   0.046294
 Self time:   0.000517

count  total (s)   self (s)
    1              0.000004   if !exists('g:deoplete#_serveraddr')
                                return 1
    1              0.000001   endif
                            
    1              0.000006   let python3 = get(g:, 'python3_host_prog', 'python3')
    1              0.000012   if !executable(python3)
                                call deoplete#util#print_error( string(python3) . ' is not executable.')
                                call deoplete#util#print_error( 'You need to set g:python3_host_prog.')
    1              0.000001   endif
    1              0.000006   if has('nvim') && !has('nvim-0.3.0')
                                call deoplete#util#print_error('deoplete requires nvim 0.3.0+.')
                                return 1
    1              0.000001   endif
    1              0.000005   if !has('nvim') && v:version < 800
                                call deoplete#util#print_error('deoplete requires Vim 8.0+.')
                                return 1
    1              0.000000   endif
                            
    1              0.000001   try
    1   0.000013   0.000007     if deoplete#util#has_yarp()
    1   0.001509   0.000228       let g:deoplete#_yarp = yarp#py3('deoplete')
    1   0.044005   0.000020       call g:deoplete#_yarp.notify('deoplete_init')
                                else
                                  " rplugin.vim may not be loaded on VimEnter
                                  if !exists('g:loaded_remote_plugins')
                                    runtime! plugin/rplugin.vim
                                  endif
                            
                                  call _deoplete_init()
                                endif
    1              0.000067   catch
    1   0.000136   0.000020     call deoplete#util#print_error(v:exception)
    1   0.000095   0.000017     call deoplete#util#print_error(v:throwpoint)
                            
    1              0.000007     if !has('python3')
                                  call deoplete#util#print_error( 'deoplete requires Python3 support("+python3").')
    1              0.000001     endif
                            
    1   0.000316   0.000018     if deoplete#init#_python_version_check()
                                  call deoplete#util#print_error('deoplete requires Python 3.6.1+.')
    1              0.000002     endif
                            
    1   0.000028   0.000015     if deoplete#util#has_yarp()
    1              0.000006       if !exists('*yarp#py3')
                                    call deoplete#util#print_error( 'deoplete requires nvim-yarp plugin.')
    1              0.000001       endif
                                else
                                  call deoplete#util#print_error( 'deoplete failed to load. ' .'Try the :UpdateRemotePlugins command and restart Neovim. ' .'See also :checkhealth.')
    1              0.000001     endif
                            
    1              0.000003     return 1
    1              0.000005   endtry

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim:14
Called 4 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    4              0.000008   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
    4              0.000002   endif

FUNCTION  sy#start()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy.vim:7
Called 3 times
Total time:   0.000526
 Self time:   0.000203

count  total (s)   self (s)
    3              0.000009   if g:signify_locked
                                call sy#verbose('Locked.')
                                return
    3              0.000004   endif
                            
    3              0.000021   let bufnr = a:0 && has_key(a:1, 'bufnr') ? a:1.bufnr : bufnr('')
    3              0.000018   let sy = getbufvar(bufnr, 'sy')
                            
    3              0.000010   if empty(sy)
    3   0.000260   0.000035     let path = s:get_path(bufnr)
    3   0.000081   0.000050     if s:skip(bufnr, path)
    3   0.000095   0.000028       call sy#verbose('Skip file: '. path)
    3              0.000004       return
                                endif
                                call sy#verbose('Register new file: '. path)
                                let new_sy = { 'path':       path, 'buffer':     bufnr, 'active':     0, 'detecting':  0, 'vcs':        [], 'hunks':      [], 'signid':     0x100, 'updated_by': '', 'stats':      [-1, -1, -1], 'info':       {    'dir':  fnamemodify(path, ':p:h'),    'path': sy#util#escape(path),    'file': sy#util#escape(fnamemodify(path, ':t')) }}
                                call setbufvar(bufnr, 'sy', new_sy)
                                if get(g:, 'signify_disable_by_default')
                                  call sy#verbose('Disabled by default.')
                                  return
                                endif
                                let new_sy.active = 1
                                call setbufvar(bufnr, 'sy', new_sy)
                                call sy#repo#detect(bufnr)
                              elseif has('vim_starting')
                                call sy#verbose("Don't run Sy more than once during startup.")
                                return
                              elseif !sy.active
                                call sy#verbose('Inactive buffer.')
                                return
                              elseif empty(sy.vcs)
                                if get(sy, 'retry')
                                  let sy.retry = 0
                                  call sy#verbose('Redetecting VCS.')
                                  call sy#repo#detect(sy.buffer)
                                else
                                  if get(sy, 'detecting')
                                    call sy#verbose('Detection is already in progress.')
                                  else
                                    call sy#verbose('No VCS found. Disabling.')
                                    call sy#disable(sy.buffer)
                                  endif
                                endif
                              else
                                for vcs in sy.vcs
                                  let job_id = getbufvar(sy.buffer, 'sy_job_id_'. vcs, 0)
                                  if type(job_id) != type(0) || job_id > 0
                                    call sy#verbose('Update is already in progress.', vcs)
                                  else
                                    call sy#verbose('Updating signs.', vcs)
                                    call sy#repo#get_diff(sy.buffer, vcs, function('sy#sign#set_signs'))
                                  endif
                                endfor
                              endif

FUNCTION  yarp#core#on_stderr()
    Defined: ~/.vim/plugged/nvim-yarp/autoload/yarp/core.vim:63
Called 1 time
Total time:   0.000257
 Self time:   0.000057

count  total (s)   self (s)
    1              0.000006     let mod = self.self
    1   0.000251   0.000051     call mod.error(filter(a:data, 'len(v:val)'))

FUNCTION  xolox#misc#cursorhold#autocmd()
    Defined: ~/.vim/plugged/vim-misc/autoload/xolox/misc/cursorhold.vim:48
Called 3 times
Total time:   0.001616
 Self time:   0.000792

count  total (s)   self (s)
                              " The 'top level event handler' that's called by Vim whenever the
                              " [CursorHold][] or [CursorHoldI][] event fires. It iterates through the
                              " event handlers registered using `xolox#misc#cursorhold#register()` and
                              " calls each event handler at the appropriate interval, keeping track of
                              " the time when each event handler was last run.
    6              0.000040   for handler in g:xolox#misc#cursorhold#handlers
    3              0.000025     let function = handler['function']
    3              0.000025     let last_run = get(handler, 'last_run', 0)
    3              0.000016     let interval = get(handler, 'interval', 4)
    3   0.001056   0.000368     call xolox#misc#msg#debug("vim-misc %s: Checking handler %s with interval %i and last run %i ..", g:xolox#misc#version, function, interval, last_run)
                                " Rate limit in case &updatetime is set (very) low.
    3              0.000030     let time_until_next_run = (last_run + interval) - localtime()
    3              0.000008     if time_until_next_run > 0
    1   0.000037   0.000019       call xolox#misc#msg#debug("vim-misc %s: Rate limiting handler %s (time until next run: %i seconds).", g:xolox#misc#version, function, time_until_next_run)
    2              0.000002     else
    2   0.000054   0.000027       call xolox#misc#msg#debug("vim-misc %s: Running handler %s ..", g:xolox#misc#version, function)
    2   0.000127   0.000036       call call(function, get(handler, 'arguments', []))
    2              0.000011       let handler['last_run'] = localtime()
    3              0.000003     endif
    6              0.000010   endfor

FUNCTION  <SNR>154_get_path()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy.vim:139
Called 3 times
Total time:   0.000225
 Self time:   0.000225

count  total (s)   self (s)
    3              0.000173   let path = resolve(fnamemodify(bufname(a:bufnr), ':p'))
    3              0.000025   if has('win32')
                                let path = substitute(path, '\v^(\w):\\\\', '\1:\\', '')
    3              0.000003   endif
    3              0.000008   return path

FUNCTION  gutentags#statusline()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim:676
Called 102 times
Total time:   0.009125
 Self time:   0.001601

count  total (s)   self (s)
  102   0.008546   0.001022     let l:modules_in_progress = gutentags#inprogress()
  102              0.000318     if empty(l:modules_in_progress)
  102              0.000138        return ''
                                endif
                            
                                let l:prefix = ''
                                let l:suffix = ''
                                if a:0 > 0
                                   let l:prefix = a:1
                                endif
                                if a:0 > 1
                                   let l:suffix = a:2
                                endif
                            
                                if a:0 > 2
                                   let l:genmsg = a:3
                                else
                                   let l:genmsg = join(l:modules_in_progress, ',')
                                endif
                            
                                return l:prefix.l:genmsg.l:suffix

FUNCTION  neovim_rpc#jobstart()
    Defined: ~/.vim/plugged/vim-hug-neovim-rpc/autoload/neovim_rpc.vim:68
Called 1 time
Total time:   0.000786
 Self time:   0.000786

count  total (s)   self (s)
                            
    1              0.000002     let l:opts = {}
    1              0.000003     if len(a:000)
    1              0.000002         let l:opts = a:1
    1              0.000001     endif
                            
    1              0.000003     let l:opts['_close'] = 0
    1              0.000002     let l:opts['_exit'] = 0
                            
    1              0.000003     let l:real_opts = {'mode': 'raw'}
    1              0.000004     if has_key(l:opts,'detach') && l:opts['detach']
                                    let l:real_opts['stoponexit'] = ''
    1              0.000001     endif
                            
    1              0.000003     if has_key(l:opts,'on_stdout')
                                    let l:real_opts['out_cb'] = function('neovim_rpc#_on_stdout')
    1              0.000001     endif
    1              0.000002     if has_key(l:opts,'on_stderr')
    1              0.000004         let l:real_opts['err_cb'] = function('neovim_rpc#_on_stderr')
    1              0.000000     endif
    1              0.000003     let l:real_opts['exit_cb'] = function('neovim_rpc#_on_exit')
    1              0.000004     let l:real_opts['close_cb'] = function('neovim_rpc#_on_close')
                            
    1              0.000709     let l:job   = job_start(a:cmd, l:real_opts)
    1              0.000013     let l:jobid = ch_info(l:job)['id']
                            
    1              0.000009     let g:_neovim_rpc_jobs[l:jobid] = {'cmd':a:cmd, 'opts': l:opts, 'job': l:job}
                            
    1              0.000003     return l:jobid

FUNCTION  188()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/creator.vim:35
Called 6 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    6              0.000014     return 'NERD_tree_'

FUNCTION  airline#util#getwinvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:70
Called 60 times
Total time:   0.000182
 Self time:   0.000182

count  total (s)   self (s)
   60              0.000165     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  deoplete#is_enabled()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete.vim:10
Called 1 time
Total time:   0.000038
 Self time:   0.000033

count  total (s)   self (s)
    1   0.000038   0.000033   return deoplete#init#_is_handler_enabled()

FUNCTION  <SNR>163_ShouldOpen()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:34
Called 2 times
Total time:   0.000058
 Self time:   0.000028

count  total (s)   self (s)
    2   0.000043   0.000013     let l:val = ale#Var(a:buffer, 'open_list')
    2              0.000008     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    2              0.000006     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  <SNR>177_function()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:17
Called 16 times
Total time:   0.000299
 Self time:   0.000299

count  total (s)   self (s)
   16              0.000295   return function(substitute(a:name,'^s:',matchstr(expand('<sfile>'), '.*\zs<SNR>\d\+_'),''))

FUNCTION  airline#themes#patch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/themes.vim:39
Called 2 times
Total time:   0.001264
 Self time:   0.001264

count  total (s)   self (s)
   30              0.000078   for mode in keys(a:palette)
   28              0.000078     if mode == 'accents'
    2              0.000004       continue
   26              0.000031     endif
   26              0.000143     if !has_key(a:palette[mode], 'airline_warning')
                                  let a:palette[mode]['airline_warning'] = [ '#000000', '#df5f00', 232, 166 ]
   26              0.000031     endif
   26              0.000133     if !has_key(a:palette[mode], 'airline_error')
                                  let a:palette[mode]['airline_error'] = [ '#000000', '#990000', 232, 160 ]
   26              0.000027     endif
   26              0.000130     if !has_key(a:palette[mode], 'airline_term')
                                  let a:palette[mode]['airline_term'] = [ '#9cffd3', '#202020', 85, 232]
   26              0.000029     endif
   28              0.000042   endfor
                            
    2              0.000017   let a:palette.accents = get(a:palette, 'accents', {})
    2              0.000012   let a:palette.accents.none = [ '', '', '', '', '' ]
    2              0.000011   let a:palette.accents.bold = [ '', '', '', '', 'bold' ]
    2              0.000010   let a:palette.accents.italic = [ '', '', '', '', 'italic' ]
                            
    2              0.000010   if !has_key(a:palette.accents, 'red')
                                let a:palette.accents.red = [ '#ff0000' , '' , 160 , '' ]
    2              0.000002   endif
    2              0.000009   if !has_key(a:palette.accents, 'green')
                                let a:palette.accents.green = [ '#008700' , '' , 22  , '' ]
    2              0.000002   endif
    2              0.000009   if !has_key(a:palette.accents, 'blue')
                                let a:palette.accents.blue = [ '#005fff' , '' , 27  , '' ]
    2              0.000003   endif
    2              0.000008   if !has_key(a:palette.accents, 'yellow')
                                let a:palette.accents.yellow = [ '#dfff00' , '' , 190 , '' ]
    2              0.000002   endif
    2              0.000009   if !has_key(a:palette.accents, 'orange')
                                let a:palette.accents.orange = [ '#df5f00' , '' , 166 , '' ]
    2              0.000002   endif
    2              0.000008   if !has_key(a:palette.accents, 'purple')
                                let a:palette.accents.purple = [ '#af00df' , '' , 128 , '' ]
    2              0.000003   endif

FUNCTION  xolox#session#auto_save()
    Defined: ~/.vim/plugged/vim-session/autoload/xolox/session.vim:443
Called 1 time
Total time:   0.003032
 Self time:   0.000135

count  total (s)   self (s)
                              " Automatically save the current editing session when Vim is closed.
                              " Normally called by the [VimLeavePre] [] automatic command event.
                              "
                              " [VimLeavePre]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimLeavePre
    1              0.000004   if v:dying
                                " We won't save the session if Vim is not terminating normally.
                                return
    1              0.000001   endif
    1              0.000004   if g:session_autosave == 'no'
                                " We won't save the session if auto-save is explicitly disabled.
                                return
    1              0.000002   endif
                              " Get the name of the session for automatic saving.
    1   0.000055   0.000023   let name = xolox#misc#option#get('session_autosave_to')
    1              0.000002   if empty(name)
                                " Get the name of the active session (if any).
    1   0.000070   0.000020     let name = xolox#session#find_current_session()
                                " If no session is active and the user doesn't have any sessions yet,
                                " help them get started by suggesting to create the default session.
    1   0.002834   0.000019     if empty(name) && (empty(xolox#session#get_names(0)) || g:session_default_overwrite)
                                  let name = g:session_default_name
    1              0.000001     endif
    1              0.000001   endif
                              " Prompt the user to save the active/first/default session?
    1              0.000003   if !empty(name)
                                let is_tab_scoped = xolox#session#is_tab_scoped()
                                let msg = "Do you want to save your %s before quitting Vim?"
                                if s:prompt(printf(msg, xolox#session#get_label(name, is_tab_scoped)), ["&Save", "&Don't Save"], 'g:session_autosave') == 1
                                  if g:session_default_overwrite && (name == g:session_default_name)
                                    let bang = '!'
                                  else
                                    let bang = ''
                                  endif
                                  if is_tab_scoped
                                    call xolox#session#save_tab_cmd(name, bang, 'SaveTabSession')
                                  else
                                    call xolox#session#save_cmd(name, bang, 'SaveSession')
                                  endif
                                endif
    1              0.000001   endif

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:229
Called 8 times
Total time:   0.002735
 Self time:   0.000304

count  total (s)   self (s)
    8              0.000042   if getbufvar(a:bufnr, '&modified')
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
    8              0.000009   else
    8              0.000081     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    8              0.000006   endif
                            
    8              0.000019   if !empty(colors)
    8   0.002526   0.000095     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    8              0.000005   endif

FUNCTION  <SNR>91_on_window_changed()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:48
Called 1 time
Total time:   0.000089
 Self time:   0.000089

count  total (s)   self (s)
    1              0.000008   let s:active_winnr = winnr()
                            
    1              0.000007   if pumvisible() && (!&previewwindow || g:airline_exclude_preview)
                                return
    1              0.000001   endif
                              " work around a neovim bug: do not trigger on floating windows
                              " Disabled, Bug is fixed in Neovim, TODO: should be removed soon
                              " if exists("*nvim_win_get_config") && !empty(nvim_win_get_config(0).relative)
                              "  return
                              " endif
                              " Handle each window only once, since we might come here several times for
                              " different autocommands.
    1              0.000024   let l:key = [bufnr('%'), s:active_winnr, winnr('$'), tabpagenr(), &ft]
    1              0.000035   if get(g:, 'airline_last_window_changed', []) == l:key && &stl is# '%!airline#statusline('.s:active_winnr.')' && &ft !~? 'gitcommit'
                                " fugitive is special, it changes names and filetypes several times,
                                " make sure the caching does not get into its way
    1              0.000002     return
                              endif
                              let g:airline_last_window_changed = l:key
                              call s:init()
                              call airline#update_statusline()

FUNCTION  deoplete#enable()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete.vim:13
Called 1 time
Total time:   0.143979
 Self time:   0.000061

count  total (s)   self (s)
    1              0.000003   if has('vim_starting')
                                augroup deoplete
                                  autocmd!
                                  autocmd VimEnter * call deoplete#enable()
                                augroup END
                                return 1
    1              0.000001   endif
                            
    1   0.141513   0.000028   if deoplete#initialize() && deoplete#is_enabled()
                                return 1
    1              0.000002   endif
    1   0.002450   0.000017   return deoplete#init#_enable_handler()

FUNCTION  <SNR>177_buffer_type()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:1473
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
    1              0.000001   return 'see b:fugitive_type'

FUNCTION  xolox#session#auto_save_periodic()
    Defined: ~/.vim/plugged/vim-session/autoload/xolox/session.vim:486
Called 2 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
                              " Automatically saves the current editing session every few minutes.
                              " Normally called by the [CursorHold] [] and [CursorHoldI] [] automatic
                              " command events.
                              "
                              " [CursorHold]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHold
                              " [CursorHoldI]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#CursorHoldI
    2              0.000005   if g:session_autosave_periodic > 0
                                let interval = g:session_autosave_periodic * 60
                                let next_save = s:session_last_flushed + interval
                                if localtime() > next_save
                                  let name = xolox#session#find_current_session()
                                  if !empty(name)
                                    if xolox#session#is_tab_scoped()
                                      let function = 'xolox#session#save_tab_cmd'
                                      let arguments = [name, '', 'SaveTabSession']
                                    else
                                      let function = 'xolox#session#save_cmd'
                                      let arguments = [name, '', 'SaveSession']
                                    endif
                                    if xolox#misc#option#get('session_autosave_silent', 0)
                                      " Silence informational messages perceived as noisy.
                                      " https://github.com/xolox/vim-session/issues/120
                                      silent call call(function, arguments)
                                    else
                                      call call(function, arguments)
                                    endif
                                  endif
                                endif
    2              0.000001   endif

FUNCTION  airline#highlighter#load_theme()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:205
Called 2 times
Total time:   0.061728
 Self time:   0.000230

count  total (s)   self (s)
    2              0.000009   if pumvisible()
                                return
    2              0.000002   endif
    4              0.000043   for winnr in filter(range(1, winnr('$')), 'v:val != winnr()')
    2   0.001136   0.000043     call airline#highlighter#highlight_modified_inactive(winbufnr(winnr))
    4              0.000009   endfor
    2   0.036714   0.000039   call airline#highlighter#highlight(['inactive'])
    2              0.000011   if getbufvar( bufnr('%'), '&modified'  )
                                call airline#highlighter#highlight(['normal', 'modified'])
    2              0.000002   else
    2   0.023777   0.000047     call airline#highlighter#highlight(['normal'])
    2              0.000000   endif

FUNCTION  yarp#py3()
    Defined: ~/.vim/plugged/nvim-yarp/autoload/yarp.vim:2
Called 1 time
Total time:   0.000998
 Self time:   0.000198

count  total (s)   self (s)
    1              0.000006     if type(a:module) == v:t_string
    1              0.000003         let rp = {}
    1              0.000002         let rp.module = a:module
                                else
                                    let rp = a:module
    1              0.000001     endif
    1              0.000004     let rp.init = function('yarp#pyx#init')
    1              0.000002     let rp.type = 'py3'
    1   0.000976   0.000176     return yarp#core#new(rp)

FUNCTION  gutentags#ctags#on_job_exit()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags/ctags.vim:217
Called 1 time
Total time:   0.000295
 Self time:   0.000038

count  total (s)   self (s)
    1   0.000279   0.000022     call gutentags#remove_job_by_data('ctags', a:job)
                            
    1              0.000005     if a:exit_val != 0 && !g:__gutentags_vim_is_leaving
                                    call gutentags#warning("ctags job failed, returned: ".string(a:exit_val))
    1              0.000001     endif

FUNCTION  yarp#core#wait_channel()
    Defined: ~/.vim/plugged/nvim-yarp/autoload/yarp/core.vim:121
Called 1 time
Total time:   0.043971
 Self time:   0.040841

count  total (s)   self (s)
    1              0.000003     if has_key(self, 'channel')
                                    return
    1              0.000001     endif
    1              0.000003     if ! has_key(self, 'job')
    1   0.001708   0.000013         call self.jobstart()
    1              0.000001     endif
    1              0.000003     if get(self, 'job', -1) == -1
                                    throw '[yarp] [' . self.module . '] job is not running'
    1              0.000000     endif
    1              0.000002     let cnt = 5000 / 20
    3              0.000020     while ! has_key(self, 'channel')
    3              0.000007         if self.job_is_dead
                                        throw '[yarp] [' . self.module . '] job is dead. failed establishing channel for ' . string(self.cmd)
    2              0.000001         endif
    2              0.000005         if cnt <= 0
                                        throw '[yarp] [' . self.module . '] timeout establishing channel for ' . string(self.cmd)
    2              0.000003         endif
    2              0.000010         let cnt = cnt - 1
    2   0.042149   0.040714         silent sleep 20m
    2              0.000005     endwhile

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:156
Called 4 times
Total time:   0.013962
 Self time:   0.000224

count  total (s)   self (s)
    4   0.000035   0.000026   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
    4              0.000001   endif
    8              0.000010   for nr in a:range
    4   0.000033   0.000019     if airline#util#getwinvar(nr, 'airline_disabled', 0)
                                  continue
    4              0.000003     endif
    4              0.000012     call setwinvar(nr, 'airline_active', 0)
    4              0.000016     let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
    4              0.000008     if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
    4              0.000002     endif
    4   0.013751   0.000036     call s:invoke_funcrefs(context, s:inactive_funcrefs)
    8              0.000007   endfor

FUNCTION  <SNR>175_kill_yarp()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/handler.vim:366
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000004   if !exists('g:deoplete#_yarp')
                                return
    1              0.000001   endif
                            
    1              0.000002   if g:deoplete#_yarp.job_is_dead
    1              0.000001     return
                              endif
                            
                              let job = g:deoplete#_yarp.job
                              if !has('nvim') && !exists('g:yarp_jobstart')
                                " Get job object from vim-hug-neovim-rpc
                                let job = g:_neovim_rpc_jobs[job].job
                              endif
                            
                              if has('nvim')
                                call jobstop(job)
                              else
                                call job_stop(job, 'kill')
                              endif
                            
                              let g:deoplete#_yarp.job_is_dead = 1

FUNCTION  ale#list#GetCombinedList()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:41
Called 1 time
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    1              0.000002     let l:list = []
                            
    2              0.000013     for l:info in values(g:ale_buffer_info)
    1              0.000006         call extend(l:list, l:info.loclist)
    2              0.000002     endfor
                            
    1              0.000005     call sort(l:list, function('ale#util#LocItemCompareWithText'))
    1              0.000003     call uniq(l:list, function('ale#util#LocItemCompareWithText'))
                            
    1              0.000001     return l:list

FUNCTION  <SNR>149_build_sections()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:35
Called 12 times
Total time:   0.003024
 Self time:   0.000638

count  total (s)   self (s)
   64              0.000069   for key in a:keys
   52              0.000116     if (key == 'warning' || key == 'error') && !a:context.active
    8              0.000008       continue
   44              0.000023     endif
   44   0.002665   0.000279     call s:add_section(a:builder, a:context, key)
   56              0.000038   endfor

FUNCTION  <SNR>131_GetHiCmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:164
Called 140 times
Total time:   0.015817
 Self time:   0.015817

count  total (s)   self (s)
                              " a:list needs to have 5 items!
  140              0.000183   let res = ''
  140              0.000180   let i = -1
  840              0.000875   while i < 4
  700              0.000878     let i += 1
  700              0.001746     let item = get(a:list, i, '')
  700              0.000834     if item is ''
  180              0.000167       continue
  520              0.000288     endif
  520              0.000491     if i == 0
  104              0.000250       let res .= ' guifg='.item
  416              0.000411     elseif i == 1
  100              0.000191       let res .= ' guibg='.item
  316              0.000319     elseif i == 2
  140              0.000368       let res .= ' ctermfg='.item
  176              0.000174     elseif i == 3
  140              0.000324       let res .= ' ctermbg='.item
   36              0.000034     elseif i == 4
   36              0.000152       let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
  520              0.000308     endif
  660              0.000500   endwhile
  140              0.000166   return res

FUNCTION  <SNR>148_get_transitioned_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:143
Called 32 times
Total time:   0.015678
 Self time:   0.000958

count  total (s)   self (s)
   32              0.000038   let line = ''
   32              0.000121   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
   32              0.000016   else
   32   0.014967   0.000247     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   32              0.000107     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   32              0.000104     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   32              0.000066     let line .= '%#'.a:group.'#'
   32              0.000019   endif
   32              0.000031   return line

FUNCTION  airline#extensions#term#inactive_apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim:24
Called 4 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    4              0.000015   if getbufvar(a:2.bufnr, '&buftype') == 'terminal'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'TERMINAL'.spc)
                                call a:1.add_section('airline_b', spc.'%f')
                                let neoterm_id = getbufvar(a:2.bufnr, 'neoterm_id')
                                if neoterm_id != ''
                                  call a:1.add_section('airline_c', spc.'neoterm_'.neoterm_id.spc)
                                endif
                                return 1
    4              0.000002   endif

FUNCTION  <SNR>148_get_accented_line()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:166
Called 40 times
Total time:   0.001339
 Self time:   0.001339

count  total (s)   self (s)
   40              0.000049   if a:self._context.active
                                " active window
   24              0.000034     let contents = []
   24              0.000121     let content_parts = split(a:contents, '__accent')
   40              0.000057     for cpart in content_parts
   16              0.000078       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   16              0.000040       call add(contents, cpart)
   40              0.000027     endfor
   24              0.000065     let line = join(contents, a:group)
   24              0.000121     let line = substitute(line, '__restore__', a:group, 'g')
   16              0.000011   else
                                " inactive window
   16              0.000169     let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
   16              0.000088     let line = substitute(line, '%#__restore__#', '', 'g')
   40              0.000027   endif
   40              0.000041   return line

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:243
Called 10 times
Total time:   0.139519
 Self time:   0.022226

count  total (s)   self (s)
   10              0.000028   let bufnr = a:0 ? a:1 : ''
   10              0.000039   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   10              0.000092   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   10              0.000036   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   10              0.000019   let airline_grouplist = []
   10              0.000060   let buffers_in_tabpage = sort(tabpagebuflist())
   10              0.000031   if exists("*uniq")
   10              0.000042     let buffers_in_tabpage = uniq(buffers_in_tabpage)
   10              0.000009   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
   20              0.000043   for mode in reverse(mapped)
   10              0.000058     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   10              0.000040       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  149              0.000232       for kvp in items(dict)
  139              0.000333         let mode_colors = kvp[1]
  139              0.000269         let name = kvp[0]
  139              0.000382         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
    1              0.000002           let name = 'airline_c'.bufnr
  139              0.000095         endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
  139              0.000823         if name =~# 'airline_c\d\+'
   15              0.000139           let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
   15              0.000058           if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
   15              0.000012           endif
  124              0.000637         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
   35              0.000036           continue
  104              0.000069         endif
  104   0.001621   0.000834         if s:group_not_done(airline_grouplist, name.suffix)
  104   0.027089   0.000834           call airline#highlighter#exec(name.suffix, mode_colors)
  104              0.000075         endif
                            
  312              0.000557         for accent in keys(s:accents)
  208              0.000521           if !has_key(p.accents, accent)
                                        continue
  208              0.000135           endif
  208              0.000620           let colors = copy(mode_colors)
  208              0.000591           if p.accents[accent][0] != ''
  104              0.000323             let colors[0] = p.accents[accent][0]
  208              0.000140           endif
  208              0.000475           if p.accents[accent][2] != ''
  104              0.000294             let colors[2] = p.accents[accent][2]
  208              0.000137           endif
  208              0.000385           if len(colors) >= 5
  208              0.000770             let colors[4] = get(p.accents[accent], 4, '')
                                      else
                                        call add(colors, get(p.accents[accent], 4, ''))
  208              0.000115           endif
  208   0.003462   0.001922           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  208   0.055249   0.001823             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  208              0.000145           endif
  312              0.000239         endfor
  114              0.000077       endfor
                            
   10              0.000019       if empty(s:separators)
                                    " nothing to be done
                                    continue
   10              0.000006       endif
                                  " TODO: optimize this
   80              0.000132       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
   70   0.036118   0.000833         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   80              0.000058       endfor
   10              0.000007     endif
   20              0.000019   endfor

FUNCTION  yarp#pyx#init()
    Defined: ~/.vim/plugged/nvim-yarp/autoload/yarp/pyx.vim:2
Called 1 time
Total time:   0.001229
 Self time:   0.000290

count  total (s)   self (s)
    1              0.000004     if self.type == 'py'
                                    let l:Detect = function('s:pyexe')
    1              0.000001     else
    1              0.000007         let l:Detect = function('s:py3exe')
    1              0.000001     endif
                            
    1   0.000077   0.000010     let exe = call(l:Detect, [], self)
                            
    1              0.000003     if get(s:, 'script', '') == ''
    1              0.000235         let s:script = globpath(&rtp,'pythonx/yarp.py',1,1)[0]
    1              0.000001     endif
                            
    1   0.000025   0.000010     let self.cmd = [exe, '-u', s:script, yarp#core#serveraddr(), self.id, self.module]
                            
    1   0.000867   0.000010      call self.jobstart()

FUNCTION  airline#parts#ffenc()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:108
Called 102 times
Total time:   0.004215
 Self time:   0.004215

count  total (s)   self (s)
  102              0.000535   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
  102              0.000302   let bomb     = &l:bomb ? '[BOM]' : ''
  102              0.001531   let ff       = strlen(&ff) ? '['.&ff.']' : ''
  102              0.000791   if expected is# &fenc.bomb.ff
                                return ''
  102              0.000102   else
  102              0.000676     return &fenc.bomb.ff
                              endif

FUNCTION  ale#Var()
    Defined: ~/.vim/plugged/ale/autoload/ale.vim:186
Called 69 times
Total time:   0.001702
 Self time:   0.001702

count  total (s)   self (s)
   69              0.000346     let l:full_name = 'ale_' . a:variable_name
   69              0.000735     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
   69              0.000526     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  yarp#core#notify()
    Defined: ~/.vim/plugged/nvim-yarp/autoload/yarp/core.vim:96
Called 1 time
Total time:   0.043985
 Self time:   0.000014

count  total (s)   self (s)
                                call self.wait_channel()
                                call call(s:rpcnotify, [self.channel, a:method] + a:000)

FUNCTION  deoplete#util#convert2list()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/util.vim:20
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000006   return type(a:expr) ==# v:t_list ? a:expr : [a:expr]

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:124
Called 231 times
Total time:   0.006528
 Self time:   0.006528

count  total (s)   self (s)
  231              0.002132   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
  231              0.004228   return match(a:name, pat) > -1

FUNCTION  neovim_rpc#_on_close()
    Defined: ~/.vim/plugged/vim-hug-neovim-rpc/autoload/neovim_rpc.vim:162
Called 1 time
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    1              0.000014     let l:jobid = ch_info(a:job)['id']
    1              0.000008     let l:opts = g:_neovim_rpc_jobs[l:jobid]['opts']
    1              0.000005     let l:opts['_close'] = 1
                                " cleanup when both close_cb and exit_cb is called
    1              0.000006     if l:opts['_close'] && l:opts['_exit']
                                    unlet g:_neovim_rpc_jobs[l:jobid]
    1              0.000001     endif

FUNCTION  <SNR>100_record()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/mrufiles.vim:59
Called 2 times
Total time:   0.000390
 Self time:   0.000069

count  total (s)   self (s)
    2              0.000009 	if s:locked | retu | en
    2              0.000006 	let bufnr = a:bufnr + 0
    2              0.000010 	let bufname = bufname(bufnr)
    2              0.000005 	if bufnr > 0 && !empty(bufname)
    2              0.000011 		cal filter(s:mrbs, 'v:val != bufnr')
    2              0.000006 		cal insert(s:mrbs, bufnr)
    2   0.000337   0.000016 		cal s:addtomrufs(bufname)
    2              0.000001 	en

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:37
Called 48 times
Total time:   0.000529
 Self time:   0.000529

count  total (s)   self (s)
   48              0.000087   let x = a:i - 1
   56              0.000059   while x >= 0
   48              0.000138     let group = a:sections[x][0]
   48              0.000081     if group != '' && group != '|'
   40              0.000045       return group
    8              0.000003     endif
    8              0.000014     let x = x - 1
   16              0.000011   endwhile
    8              0.000007   return ''

FUNCTION  xolox#misc#os#is_win()
    Defined: ~/.vim/plugged/vim-misc/autoload/xolox/misc/os.vim:30
Called 1 time
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
                              " Returns 1 (true) when on Microsoft Windows, 0 (false) otherwise.
    1              0.000018   return has('win16') || has('win32') || has('win64')

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:63
Called 128 times
Total time:   0.000496
 Self time:   0.000496

count  total (s)   self (s)
  128              0.000432   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  airline#update_statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:127
Called 4 times
Total time:   0.035441
 Self time:   0.000216

count  total (s)   self (s)
    4   0.000037   0.000025   if airline#util#getwinvar(winnr(), 'airline_disabled', 0)
                                return
    4              0.000002   endif
    4              0.000027   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    4   0.013988   0.000026   call airline#update_statusline_inactive(range)
                            
    4              0.000008   unlet! w:airline_render_left w:airline_render_right
    4              0.000041   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    4              0.000007   let w:airline_active = 1
    4              0.000019   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    4   0.021296   0.000045   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  <SNR>165_set_custom()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/custom.vim:161
Called 2 times
Total time:   0.000043
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000007   if type(a:name_or_dict) == v:t_dict
    1              0.000003     call extend(a:dest, a:name_or_dict)
    1              0.000001   else
    1   0.000024   0.000008     call s:set_value(a:dest, a:name_or_dict, a:value)
    2              0.000001   endif

FUNCTION  deoplete#initialize()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete.vim:7
Called 1 time
Total time:   0.141447
 Self time:   0.000013

count  total (s)   self (s)
    1   0.141445   0.000011   return deoplete#init#_initialize()

FUNCTION  gutentags#on_vim_leave_pre()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim:353
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005     let g:__gutentags_vim_is_leaving = 1

FUNCTION  <SNR>47_IndentGuidesEnable()
    Defined: ~/.vim/plugged/vim-indent-guides/plugin/indent_guides.vim:19
Called 1 time
Total time:   0.000054
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000052   0.000005   call indent_guides#enable()

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:89
Called 231 times
Total time:   0.012160
 Self time:   0.005632

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
  231   0.009458   0.002930   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
  231              0.000204   endif
  231              0.000654   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
  231              0.000187   else
  231              0.000559     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  <SNR>149_get_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:20
Called 56 times
Total time:   0.001671
 Self time:   0.001270

count  total (s)   self (s)
   56              0.000135   if has_key(s:section_truncate_width, a:key)
   36   0.000529   0.000229     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
   24              0.000022       return ''
   12              0.000006     endif
   32              0.000014   endif
   32              0.000061   let spc = g:airline_symbols.space
   32              0.000109   if !exists('g:airline_section_{a:key}')
                                return ''
   32              0.000019   endif
   32   0.000355   0.000254   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   32              0.000175   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   32              0.000098   return empty(text) ? '' : prefix.text.suffix

FUNCTION  <SNR>155_ApplyPartialTimer()
    Defined: ~/.vim/plugged/ale/autoload/ale/util.vim:432
Called 1 time
Total time:   0.000425
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000007     if has_key(s:partial_timers, a:timer_id)
    1              0.000012         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
    1   0.000405   0.000024         call call(l:Callback, [a:timer_id] + l:args)
    1              0.000001     endif

FUNCTION  deoplete#send_event()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete.vim:43
Called 1 time
Total time:   0.000077
 Self time:   0.000035

count  total (s)   self (s)
    1   0.000022   0.000015   let sources = deoplete#util#convert2list(get(a:000, 0, []))
    1   0.000053   0.000018   call deoplete#util#rpcnotify('deoplete_on_event', {'event': a:event, 'sources': sources})

FUNCTION  <SNR>131_hl_group_exists()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:95
Called 300 times
Total time:   0.003286
 Self time:   0.003286

count  total (s)   self (s)
  300              0.000774   if !hlexists(a:group)
                                return 0
  300              0.001286   elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
  300              0.000191   endif
  300              0.000246   return 1

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:130
Called 24 times
Total time:   0.005602
 Self time:   0.000634

count  total (s)   self (s)
   24              0.000044   if a:group1 == a:group2
                                return 0
   24              0.000014   endif
   24   0.002708   0.000182   let color1 = airline#highlighter#get_highlight(a:group1)
   24   0.002619   0.000177   let color2 = airline#highlighter#get_highlight(a:group2)
   24              0.000036   if g:airline_gui_mode ==# 'gui'
                                return color1[1] != color2[1] || color1[0] != color2[0]
   24              0.000007   else
   24              0.000082     return color1[3] != color2[3] || color1[2] != color2[2]
                              endif

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:104
Called 440 times
Total time:   0.107314
 Self time:   0.028812

count  total (s)   self (s)
  440              0.000776   if pumvisible()
                                return
  440              0.000281   endif
  440              0.000758   let colors = a:colors
  440              0.000562   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  440              0.000284   endif
  440   0.057157   0.003755   let old_hi = airline#highlighter#get_highlight(a:group)
  440              0.000878   if len(colors) == 4
  105              0.000223     call add(colors, '')
  440              0.000271   endif
  440              0.000662   if g:airline_gui_mode ==# 'gui'
                                let new_hi = [colors[0], colors[1], '', '', colors[4]]
  440              0.000277   else
  440              0.003157     let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
  440              0.000303   endif
  440   0.009018   0.003021   let colors = s:CheckDefined(colors)
  440   0.005960   0.002674   if old_hi != new_hi || !s:hl_group_exists(a:group)
  140   0.016950   0.001133     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
  140              0.001030     exe cmd
  140              0.000387     if has_key(s:hl_groups, a:group)
  140              0.000354       let s:hl_groups[a:group] = colors
  140              0.000094     endif
  440              0.000245   endif

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/themes.vim:31
Called 204 times
Total time:   0.024135
 Self time:   0.001790

count  total (s)   self (s)
  204   0.024086   0.001741   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  <SNR>163_SetListsImpl()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:78
Called 1 time
Total time:   0.000381
 Self time:   0.000176

count  total (s)   self (s)
    1              0.000016     let l:title = expand('#' . a:buffer . ':p')
                            
    1              0.000002     if g:ale_set_quickfix
    1   0.000050   0.000013         let l:quickfix_list = ale#list#GetCombinedList()
                            
    1              0.000004         if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
    1              0.000001         else
    1   0.000090   0.000017             call setqflist(s:FixList(a:buffer, l:quickfix_list))
    1              0.000006             call setqflist([], 'r', {'title': l:title})
    1              0.000001         endif
                                elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
                                    let l:ids = s:WinFindBuf(a:buffer)
                            
                                    for l:id in l:ids
                                        if has('nvim')
                                            call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
                                        else
                                            call setloclist(l:id, s:FixList(a:buffer, a:loclist))
                                            call setloclist(l:id, [], 'r', {'title': l:title})
                                        endif
                                    endfor
    1              0.000001     endif
                            
                                " Save the current view before opening/closing any window
    1              0.000018     call setbufvar(a:buffer, 'ale_winview', winsaveview())
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
    1   0.000037   0.000009     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    " Return to original mode when applicable
                                    if mode() != l:mode
                                        if l:mode is? 'v' || l:mode is# "\<c-v>"
                                            " Reset our last visual selection
                                            normal! gv
                                        elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                            " Reset our last character selection
                                            normal! "\<c-g>"
                                        endif
                                    endif
                            
                                    call s:RestoreViewIfNeeded(a:buffer)
    1              0.000001     endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
    1   0.000021   0.000009     if !ale#engine#IsCheckingBuffer(a:buffer)
    1   0.000065   0.000010         call s:CloseWindowIfNeeded(a:buffer)
    1              0.000001     endif

FUNCTION  <SNR>100_addtomrufs()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/mrufiles.vim:70
Called 2 times
Total time:   0.000321
 Self time:   0.000321

count  total (s)   self (s)
    2              0.000031 	let fn = fnamemodify(a:fname, get(g:, 'ctrlp_tilde_homedir', 0) ? ':p:~' : ':p')
    2              0.000019 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    2              0.000014 	let abs_fn = fnamemodify(fn,':p')
    2              0.000184 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^' . abs_fn . '$', '&bt')) || !filereadable(abs_fn)
                            		retu
    2              0.000002 	en
    2              0.000013 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    2              0.000002 	if idx
    2              0.000019 		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
    2              0.000006 		cal insert(s:mrufs, fn)
    2              0.000007 		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
    2              0.000001 		en
    2              0.000002 	en

FUNCTION  deoplete#custom#_get_option()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/custom.vim:84
Called 3 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    3              0.000016   return s:cached.option[a:name]

FUNCTION  <SNR>91_on_cursor_moved()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim:74
Called 67 times
Total time:   0.002443
 Self time:   0.001777

count  total (s)   self (s)
   67              0.000573   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
   67              0.000086   endif
   67   0.001413   0.000747   call airline#update_tabline()

FUNCTION  airline#extensions#append_to_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:53
Called 4 times
Total time:   0.000076
 Self time:   0.000042

count  total (s)   self (s)
    4   0.000062   0.000028   call <sid>check_defined_section(a:name)
    4              0.000012   let w:airline_section_{a:name} .= a:value

FUNCTION  yarp#core#new()
    Defined: ~/.vim/plugged/nvim-yarp/autoload/yarp/core.vim:31
Called 1 time
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    1              0.000003     let s:id = s:id + 1
                            
    1              0.000002     let rp = a:rp
    1              0.000004     let rp.jobstart = function('yarp#core#jobstart')
    1              0.000002     func rp.error(msg) dict
                                    call yarp#core#error(self.module, a:msg)
                                endfunc
    1              0.000001     func rp.warn(msg) dict
                                    call yarp#core#warn(self.module, a:msg)
                                endfunc
    1              0.000003     let rp.call = function('yarp#core#request')
    1              0.000003     let rp.request = function('yarp#core#request')
    1              0.000003     let rp.notify = function('yarp#core#notify')
    1              0.000003     let rp.try_notify = function('yarp#core#try_notify')
    1              0.000003     let rp.wait_channel = function('yarp#core#wait_channel')
    1              0.000002     let rp.id = s:id
    1              0.000002     let rp.job_is_dead = 0
    1              0.000003     let s:reg[rp.id] = rp
                            
                                " options
    1              0.000005     let rp.on_load = get(rp, 'on_load', function('yarp#core#_nop'))
    1              0.000003     let rp.job_detach = get(rp, 'job_detach', 0)
                            
                                " reserved for user
    1              0.000004     let rp.user_data = get(rp, 'user_data', {})
    1              0.000001     return rp

FUNCTION  <SNR>163_CloseWindowIfNeeded()
    Defined: ~/.vim/plugged/ale/autoload/ale/list.vim:201
Called 1 time
Total time:   0.000055
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000053   0.000011     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
    1              0.000001         return
                                endif
                            
                                let l:did_close_any_list = 0
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                            let l:did_close_any_list = 1
                                        endif
                                    else
                                        let l:win_ids = s:WinFindBuf(a:buffer)
                            
                                        for l:win_id in l:win_ids
                                            if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                lclose
                                                let l:did_close_any_list = 1
                                            endif
                                        endfor
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry
                            
                                if l:did_close_any_list
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif

FUNCTION  <SNR>100_savetofile()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/mrufiles.vim:88
Called 1 time
Total time:   0.001672
 Self time:   0.000019

count  total (s)   self (s)
    1   0.001672   0.000019 	cal ctrlp#utils#writecache(a:mrufs, s:cadir, s:cafile)

FUNCTION  anzu#update()
    Defined: ~/.vim/plugged/vim-anzu/autoload/anzu.vim:93
Called 65 times
Total time:   0.007588
 Self time:   0.003406

count  total (s)   self (s)
   65              0.000283 	let pattern = a:pattern
   65              0.000189 	let cursor = a:cursor_pos
   65              0.000153 	if pattern == ""
                            		return
   65              0.000075 	endif
                            
   65   0.005058   0.000876 	let pos_all = s:searchpos(pattern)
                            	
   65              0.000216 	if empty(pos_all)
                            		let s:status_cache = s:print_status(g:anzu_no_match_word, pattern, "", "", "")
                            		return -1
   65              0.000072 	endif
                            
   65              0.000531 	let index = index(pos_all, [cursor[1], cursor[2]])
   65              0.000141 	if index == -1
   65              0.000104 		return -1
                            	endif
                            
                            	let wrap_mes = get(a:, 1, "")
                            
                            	let pattern = substitute(pattern, '\\', '\\\\', 'g')
                            	let s:status_cache = s:print_status(g:anzu_status_format, pattern, index+1, len(pos_all), wrap_mes)

FUNCTION  <SNR>97_wrapscan_mes()
    Defined: ~/.vim/plugged/vim-anzu/plugin/anzu.vim:45
Called 65 times
Total time:   0.000559
 Self time:   0.000559

count  total (s)   self (s)
   65              0.000384 	if !exists("s:start_pos") || !exists("s:is_back")
   65              0.000108 		return ""
                            	endif
                            	let prev_pos = s:start_pos
                            	let pos = getpos(".")
                            	let result = ""
                            	if !empty(prev_pos) && s:pos_less(pos, prev_pos) && !s:is_back
                            		let result = g:anzu_bottomtop_word
                            	elseif !empty(prev_pos) && s:pos_less(prev_pos, pos) && s:is_back
                            		let result = g:anzu_topbottom_word
                            	endif
                            	unlet s:start_pos
                            	unlet s:is_back
                            
                            	return result

FUNCTION  yarp#core#on_exit()
    Defined: ~/.vim/plugged/nvim-yarp/autoload/yarp/core.vim:68
Called 1 time
Total time:   0.000165
 Self time:   0.000071

count  total (s)   self (s)
    1              0.000004     let mod = self.self
    1              0.000004     let mod.job_is_dead = 1
    1              0.000005     if has_key(mod, 'channel')
                                    unlet mod.channel
    1              0.000001     endif
                            
    1              0.000011     if has("nvim")
                                    if v:exiting is 0
                                        return
                                    endif
    1              0.000005     elseif v:dying || s:leaving
                                    return
    1              0.000001     endif
    1   0.000119   0.000025     call mod.error("Job is dead. cmd=" . string(mod.cmd))

FUNCTION  deoplete#init#_enable_handler()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/init.vim:100
Called 1 time
Total time:   0.002433
 Self time:   0.000397

count  total (s)   self (s)
    1   0.002425   0.000389   call deoplete#handler#_init()
    1              0.000006   let s:is_handler_enabled = 1

FUNCTION  <SNR>175_define_completion_via_timer()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/handler.vim:301
Called 3 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
    3              0.000021   if !exists('##' . a:event)
                                return
    3              0.000004   endif
                            
    3              0.000058   execute 'autocmd deoplete' a:event '* call s:completion_timer_start('.string(a:event).')'

FUNCTION  indent_guides#init_matches()
    Defined: ~/.vim/plugged/vim-indent-guides/autoload/indent_guides.vim:176
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006   let w:indent_guides_matches = exists('w:indent_guides_matches') ? w:indent_guides_matches : []

FUNCTION  deoplete#custom#_get_buffer()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/custom.vim:67
Called 1 time
Total time:   0.000017
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000002   if !exists('b:custom')
    1   0.000013   0.000006     call deoplete#custom#_init_buffer()
    1              0.000001   endif
                            
    1              0.000001   return b:custom

FUNCTION  ctrlp#mrufiles#cachefile()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/mrufiles.vim:137
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000008 	if !exists('s:cadir') || !exists('s:cafile')
                            		let s:cadir = ctrlp#utils#cachedir().ctrlp#utils#lash().'mru'
                            		let s:cafile = s:cadir.ctrlp#utils#lash().'cache.txt'
    1              0.000002 	en
    1              0.000003 	retu s:cafile

FUNCTION  <SNR>176_searchpos_all()
    Defined: ~/.vim/plugged/vim-anzu/autoload/anzu.vim:188
Called 1 time
Total time:   0.000912
 Self time:   0.000912

count  total (s)   self (s)
                            	" winsave view correctly restores curswant
    1              0.000009 	let old_pos = winsaveview()
    1              0.000003 	let result = []
    1              0.000001 	try
    1              0.000016 		call setpos(".", [0, line("$"), strlen(getline("$")), 0])
    3              0.000006 		while 1
    3              0.000763 			silent! let pos = searchpos(a:pattern, "w")
    3              0.000025 			if pos == [0, 0] || index(result, pos) != -1
    1              0.000002 				break
    2              0.000002 			endif
    2              0.000011 			call add(result, pos)
    2              0.000011 			if len(result) >= g:anzu_search_limit
                            				break
    2              0.000004 			endif
    3              0.000005 		endwhile
    1              0.000003 	finally
    1              0.000021 		call winrestview(old_pos)
    1              0.000002 	endtry
    1              0.000002 	return result

FUNCTION  <SNR>168_flush_session()
    Defined: ~/.vim/plugged/vim-session/autoload/xolox/session.vim:518
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000006   let s:session_last_flushed = localtime()

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:67
Called 128 times
Total time:   0.003909
 Self time:   0.003909

count  total (s)   self (s)
  128              0.001534   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  128              0.000320   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
  128              0.000104   endif
  128              0.000143   return ''

FUNCTION  deoplete#init#_prev_completion()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/init.vim:268
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005   let g:deoplete#_prev_completion = { 'event': '', 'input': '', 'linenr': -1, 'candidates': [], 'complete_position': -1, }

FUNCTION  deoplete#init#_is_handler_enabled()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/init.vim:11
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004   return s:is_handler_enabled

FUNCTION  neovim_rpc#_on_stderr()
    Defined: ~/.vim/plugged/vim-hug-neovim-rpc/autoload/neovim_rpc.vim:141
Called 1 time
Total time:   0.000348
 Self time:   0.000091

count  total (s)   self (s)
    1              0.000028     let l:jobid = ch_info(a:job)['id']
    1              0.000010     let l:opts = g:_neovim_rpc_jobs[l:jobid]['opts']
                                " convert to neovim style function call
    1   0.000307   0.000050     call call(l:opts['on_stderr'],[l:jobid,split(a:data,"\n",1),'stderr'],l:opts)

FUNCTION  <SNR>125_check_defined_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:47
Called 4 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    4              0.000016   if !exists('w:airline_section_{a:name}')
    4              0.000016     let w:airline_section_{a:name} = g:airline_section_{a:name}
    4              0.000002   endif

FUNCTION  <SNR>139_ale_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ale.vim:125
Called 3 times
Total time:   0.000028
 Self time:   0.000028

count  total (s)   self (s)
    3              0.000017   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
    3              0.000004   endif

FUNCTION  airline#extensions#tagbar#currenttag()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/tagbar.vim:31
Called 102 times
Total time:   0.003247
 Self time:   0.003247

count  total (s)   self (s)
  102              0.000388   if get(w:, 'airline_active', 0)
                                if !s:init
                                  try
                                    " try to load the plugin, if filetypes are disabled,
                                    " this will cause an error, so try only once
                                    let a=tagbar#currenttag('%', '', '')
                                  catch
                                  endtry
                                  unlet! a
                                  let s:init=1
                                endif
                                " function tagbar#currenttag does not exist, if filetype is not enabled
                                if s:airline_tagbar_last_lookup_time != localtime() && exists("*tagbar#currenttag")
                                  let s:airline_tagbar_last_lookup_val = tagbar#currenttag('%s', '', s:flags)
                                  let s:airline_tagbar_last_lookup_time = localtime()
                                endif
                                return s:airline_tagbar_last_lookup_val
  102              0.000093   endif
  102              0.000122   return ''

FUNCTION  deoplete#init#_initialize()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/init.vim:15
Called 1 time
Total time:   0.141434
 Self time:   0.000521

count  total (s)   self (s)
    1              0.000002   if exists('g:deoplete#_initialized')
                                return 1
    1              0.000001   endif
                            
    1              0.000002   let g:deoplete#_initialized = v:false
                            
    1   0.000199   0.000006   call deoplete#init#_custom_variables()
    1   0.000088   0.000009   call deoplete#custom#_update_cache()
                            
    1   0.094356   0.000009   call s:init_internal_variables()
                            
                              " For context_filetype check
    1              0.000456   silent! call context_filetype#get()
                            
    1   0.046321   0.000027   if deoplete#init#_channel()
    1              0.000003     return 1
                              endif
                            
                              call deoplete#mapping#_init()

FUNCTION  <SNR>131_group_not_done()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:25
Called 312 times
Total time:   0.002327
 Self time:   0.002327

count  total (s)   self (s)
  312              0.000975   if index(a:list, a:name) == -1
  312              0.000842     call add(a:list, a:name)
  312              0.000311     return 1
                              else
                                if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
                                endif
                                return 0
                              endif

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:59
Called 128 times
Total time:   0.000861
 Self time:   0.000861

count  total (s)   self (s)
  128              0.000792   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/keymap.vim:10
Called 128 times
Total time:   0.001799
 Self time:   0.001799

count  total (s)   self (s)
  128              0.000893   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  128              0.000830     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  <SNR>127_invoke_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim:177
Called 8 times
Total time:   0.034966
 Self time:   0.000319

count  total (s)   self (s)
    8   0.000187   0.000042   let builder = airline#builder#new(a:context)
    8   0.006248   0.000078   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    8              0.000007   if err == 1
    8   0.028386   0.000054     let a:context.line = builder.build()
    8              0.000035     let s:contexts[a:context.winnr] = a:context
    8              0.000026     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
    8              0.000062     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
    8              0.000005   endif

FUNCTION  airline#extensions#load_theme()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim:131
Called 2 times
Total time:   0.004220
 Self time:   0.000021

count  total (s)   self (s)
    2   0.004219   0.000020   call airline#util#exec_funcrefs(s:ext._theme_funcrefs, g:airline#themes#{g:airline_theme}#palette)

FUNCTION  226()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:146
Called 3 times
Total time:   0.000293
 Self time:   0.000274

count  total (s)   self (s)
    3              0.000019     if exists("t:NERDTreeBufName")
                                    return bufwinnr(t:NERDTreeBufName)
    3              0.000003     endif
                            
                                " If WindowTree, there is no t:NERDTreeBufName variable. Search all windows.
    9              0.000033     for w in range(1,winnr('$'))
    6   0.000155   0.000136         if bufname(winbufnr(w)) =~# '^' . g:NERDTreeCreator.BufNamePrefix() . '\d\+$'
                                        return w
    6              0.000008         endif
    9              0.000012     endfor
                            
    3              0.000006     return -1

FUNCTION  227()
    Defined: ~/.vim/plugged/nerdtree/lib/nerdtree/nerdtree.vim:162
Called 3 times
Total time:   0.000321
 Self time:   0.000028

count  total (s)   self (s)
    3   0.000318   0.000025     return s:NERDTree.GetWinNum() != -1

FUNCTION  <SNR>149_add_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim:47
Called 44 times
Total time:   0.002386
 Self time:   0.001028

count  total (s)   self (s)
   44              0.000159     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   44   0.000342   0.000196     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
    8              0.000006       return
   36              0.000017     endif
   36              0.000030     if condition
                                  call a:builder.add_raw('%(')
   36              0.000017     endif
   36   0.001552   0.000340     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   36              0.000035     if condition
                                  call a:builder.add_raw('%)')
   36              0.000024     endif

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:55
Called 128 times
Total time:   0.006661
 Self time:   0.001507

count  total (s)   self (s)
  128   0.006576   0.001422   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  airline#extensions#gutentags#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/gutentags.vim:10
Called 102 times
Total time:   0.010405
 Self time:   0.001280

count  total (s)   self (s)
  102   0.009986   0.000861   let msg = gutentags#statusline()
  102              0.000339   return empty(msg) ? '' :  'Gen. ' . msg

FUNCTION  <SNR>176_pos_less_equal()
    Defined: ~/.vim/plugged/vim-anzu/autoload/anzu.vim:41
Called 195 times
Total time:   0.001831
 Self time:   0.001831

count  total (s)   self (s)
  195              0.001710 	return a:a[0] == a:b[0] ? a:a[1] <= a:b[1] : a:a[0] <= a:b[0]

FUNCTION  <SNR>177_add_methods()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:686
Called 5 times
Total time:   0.000497
 Self time:   0.000198

count  total (s)   self (s)
   21              0.000025   for name in a:method_names
   16   0.000436   0.000137     let s:{a:namespace}_prototype[name] = s:function('s:'.a:namespace.'_'.name)
   21              0.000013   endfor

FUNCTION  <SNR>138_ModifierFlags()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim:10
Called 231 times
Total time:   0.001207
 Self time:   0.001207

count  total (s)   self (s)
  231              0.001091   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  <SNR>177_can_diffoff()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim:4768
Called 2 times
Total time:   0.000026
 Self time:   0.000026

count  total (s)   self (s)
    2              0.000023   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim:88
Called 4 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
    4              0.000019   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'org', 'rst', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    4              0.000008   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    4              0.000007   if did_filetype()
                            
                                " Select test based on type of "filetypes": new=list, old=string
                                if type(filetypes) == get(v:, 't_list', type([])) ? index(filetypes, &filetype) > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
    4              0.000001   endif
                            
    4              0.000009   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
    4              0.000003   endif

FUNCTION  <SNR>131_CheckDefined()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:132
Called 440 times
Total time:   0.005997
 Self time:   0.005997

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  440              0.001358   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  440              0.000274   endif
  440              0.001298   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
  440              0.000583     return a:colors
                              endif
                            
                              for val in a:colors
                                if !empty(val) && val !=# 'NONE'
                                  return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  xolox#session#auto_load()
    Defined: ~/.vim/plugged/vim-session/autoload/xolox/session.vim:382
Called 1 time
Total time:   0.000643
 Self time:   0.000051

count  total (s)   self (s)
                              " Automatically load the default or last used session when Vim starts.
                              " Normally called by the [VimEnter] [] automatic command event.
                              "
                              " [VimEnter]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimEnter
    1              0.000002   if g:session_autoload == 'no'
                                return
    1              0.000000   endif
                              " Check that the user has started Vim without editing any files.
    1   0.000599   0.000007   if xolox#session#is_empty()
                                " Check whether a session matching the user-specified server name exists.
                                if v:servername !~ '^\cgvim\d*$'
                                  for session in xolox#session#get_names(0)
                                    if v:servername ==? session
                                      call xolox#session#open_cmd(session, '', 'OpenSession')
                                      return
                                    endif
                                  endfor
                                endif
                                " Default to the last used session or the default session?
                                let [has_last_session, session] = s:get_last_or_default_session()
                                let path = xolox#session#name_to_path(session)
                                if (g:session_default_to_last == 0 || has_last_session) && filereadable(path) && !s:session_is_locked(session, 'OpenSession')
                                  " Compose the message for the prompt.
                                  let is_default_session = (session == g:session_default_name)
                                  let msg = printf("Do you want to restore your %s editing session%s?", is_default_session ? 'default' : 'last used', is_default_session ? '' : printf(' (%s)', session))
                                  " Prepare the list of choices.
                                  let choices = ["&Restore", "&Don't Restore"]
                                  if g:session_default_to_last && has_last_session
                                    call add(choices, "&Forget")
                                  endif
                                  " Prompt the user (if not configured otherwise).
                                  let choice = s:prompt(msg, choices, 'g:session_autoload')
                                  if choice == 1
                                    call xolox#session#open_cmd(session, '', 'OpenSession')
                                  elseif choice == 3
                                    call s:last_session_forget()
                                  endif
                                endif
    1              0.000000   endif

FUNCTION  <SNR>148_section_is_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:185
Called 48 times
Total time:   0.000428
 Self time:   0.000428

count  total (s)   self (s)
   48              0.000065   let start=1
                            
                              " do not check for inactive windows or the tabline
   48              0.000073   if a:self._context.active == 0
   20              0.000016     return 0
   28              0.000062   elseif get(a:self._context, 'tabline', 0)
                                return 0
   28              0.000014   endif
                            
                              " only check, if airline#skip_empty_sections == 1
   28              0.000059   if get(g:, 'airline_skip_empty_sections', 0) == 0
   28              0.000024     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  ale#cursor#EchoCursorWarning()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim:62
Called 65 times
Total time:   0.004796
 Self time:   0.002212

count  total (s)   self (s)
   65              0.000531     let l:buffer = bufnr('')
                            
   65              0.000203     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
   65              0.000079     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
   65              0.000223     if mode(1) isnot# 'n'
                                    return
   65              0.000057     endif
                            
   65   0.003203   0.000619     if ale#ShouldDoNothing(l:buffer)
   65              0.000076         return
                                endif
                            
                                let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
                                if g:ale_echo_cursor
                                    if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
                                    elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        execute 'echo'
                                        let l:info.echoed = 0
                                    endif
                                endif
                            
                                if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
                                endif

FUNCTION  indent_guides#clear_matches()
    Defined: ~/.vim/plugged/vim-indent-guides/autoload/indent_guides.vim:75
Called 1 time
Total time:   0.000032
 Self time:   0.000026

count  total (s)   self (s)
    1   0.000013   0.000007   call indent_guides#init_matches()
    1              0.000002   if !empty(w:indent_guides_matches)
                                let l:index = 0
                                for l:match_id in w:indent_guides_matches
                                  try
                                    call matchdelete(l:match_id)
                                  catch /E803:/
                                    " Do nothing
                                  endtry
                                  call remove(w:indent_guides_matches, l:index)
                                  let l:index += l:index
                                endfor
    1              0.000001   endif

FUNCTION  gutentags#trace()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim:33
Called 8 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
    8              0.000040     if g:gutentags_trace || (a:0 && a:1)
                                    let l:message = "gutentags: " . a:message
                                    echom l:message
    8              0.000012     endif

FUNCTION  gutentags#remove_job_by_data()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim:436
Called 1 time
Total time:   0.000257
 Self time:   0.000055

count  total (s)   self (s)
    1   0.000078   0.000038     let l:idx = gutentags#find_job_index_by_data(a:module, a:data)
    1   0.000178   0.000016     call gutentags#remove_job(a:module, l:idx)

FUNCTION  xolox#session#auto_unlock()
    Defined: ~/.vim/plugged/vim-session/autoload/xolox/session.vim:526
Called 1 time
Total time:   0.000123
 Self time:   0.000061

count  total (s)   self (s)
                              " Automatically unlock all sessions when Vim quits. Normally called by the
                              " [VimLeavePre] [] automatic command event.
                              "
                              " [VimLeavePre]: http://vimdoc.sourceforge.net/htmldoc/autocmd.html#VimLeavePre
    1   0.000092   0.000030   if xolox#session#locking_enabled()
    1              0.000003     let i = 0
    1              0.000006     while i < len(s:lock_files)
                                  let lock_file = s:lock_files[i]
                                  if delete(lock_file) == 0
                                    call remove(s:lock_files, i)
                                  else
                                    let i += 1
                                  endif
    1              0.000002     endwhile
    1              0.000001   endif

FUNCTION  <SNR>100_chop()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/mrufiles.vim:38
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000013 	if len(a:mrufs) > {s:max} | cal remove(a:mrufs, {s:max}, -1) | en
    1              0.000002 	retu a:mrufs

FUNCTION  gutentags#inprogress()
    Defined: ~/.vim/plugged/vim-gutentags/autoload/gutentags.vim:644
Called 102 times
Total time:   0.007524
 Self time:   0.005702

count  total (s)   self (s)
                                " Does this buffer have gutentags enabled?
  102              0.000436     if !exists('b:gutentags_files')
                                    return []
  102              0.000097     endif
                            
                                " Find any module that has a job in progress for any of this buffer's
                                " tags files.
  102              0.000303     let l:modules_in_progress = []
  204              0.000907     for [module, tags_file] in items(b:gutentags_files)
  102   0.003295   0.001473         let l:jobidx = gutentags#find_job_index_by_tags_file(module, tags_file)
  102              0.000211         if l:jobidx >= 0
                                        call add(l:modules_in_progress, module)
  102              0.000085         endif
  204              0.000222     endfor
  102              0.000224     return l:modules_in_progress

FUNCTION  <SNR>176_searchpos()
    Defined: ~/.vim/plugged/vim-anzu/autoload/anzu.vim:165
Called 65 times
Total time:   0.004182
 Self time:   0.003270

count  total (s)   self (s)
   65              0.000533 	let bufnr = get(a:, 1, bufnr("%"))
   65              0.000307 	let uncache = get(a:, 2, 0)
   65              0.000113 	if uncache
                            		return s:searchpos_all(a:pattern)
   65              0.000069 	endif
   65              0.000373 	let cache = getbufvar(bufnr, "anzu_searchpos_cache")
   65              0.000299 	if type(cache) == type("")
    1              0.000003 		unlet cache
    1              0.000004 		let cache = {}
   65              0.000069 	endif
                            
   65              0.000288 	if has_key(cache, a:pattern)
   64              0.000457 		return deepcopy(cache[a:pattern])
    1              0.000001 	endif
    1   0.000930   0.000018 	let searchpos = s:searchpos_all(a:pattern)
    1              0.000006 	let cache[a:pattern] = searchpos
    1              0.000010 	call setbufvar(bufnr, "anzu_searchpos_cache", cache)
    1              0.000003 	return searchpos

FUNCTION  deoplete#init#_python_version_check()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/init.vim:278
Called 1 time
Total time:   0.000298
 Self time:   0.000298

count  total (s)   self (s)
    1              0.000002   python3 << EOF
                            import vim
                            import sys
                            vim.vars['deoplete#_python_version_check'] = (
                                sys.version_info.major,
                                sys.version_info.minor,
                                sys.version_info.micro) < (3, 6, 1)
                            EOF
    1              0.000011   return get(g:, 'deoplete#_python_version_check', 0)

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:67
Called 692 times
Total time:   0.080715
 Self time:   0.038166

count  total (s)   self (s)
  692              0.008491   let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  692              0.002359   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
  692              0.000471   else
  692   0.023284   0.004456     let fg = s:get_syn(a:group, 'fg')
  692   0.022742   0.004302     let bg = s:get_syn(a:group, 'bg')
  692              0.003036     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  692              0.000714     if reverse
                                  let res = s:get_array(bg, fg, bold ? ['bold'] : a:000)
  692              0.000464     else
  692   0.010227   0.004946       let res = s:get_array(fg, bg, bold ? ['bold'] : a:000)
  692              0.000447     endif
  692              0.000383   endif
  692              0.001877   let s:hl_groups[a:group] = res
  692              0.000725   return res

FUNCTION  deoplete#util#has_yarp()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/util.vim:134
Called 4 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    4              0.000032   return !has('nvim') || deoplete#custom#_get_option('yarp')

FUNCTION  neovim_rpc#_on_exit()
    Defined: ~/.vim/plugged/vim-hug-neovim-rpc/autoload/neovim_rpc.vim:148
Called 1 time
Total time:   0.000238
 Self time:   0.000073

count  total (s)   self (s)
    1              0.000013     let l:jobid = ch_info(a:job)['id']
    1              0.000008     let l:opts = g:_neovim_rpc_jobs[l:jobid]['opts']
    1              0.000004     let l:opts['_exit'] = 1
                                " cleanup when both close_cb and exit_cb is called
    1              0.000005     if l:opts['_close'] && l:opts['_exit']
    1              0.000006         unlet g:_neovim_rpc_jobs[l:jobid]
    1              0.000001     endif
    1              0.000006     if has_key(l:opts, 'on_exit')
                                    " convert to neovim style function call
    1   0.000189   0.000024         call call(l:opts['on_exit'],[l:jobid,a:status,'exit'],l:opts)
    1              0.000002     endif

FUNCTION  airline#extensions#ctrlp#load_theme()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ctrlp.vim:23
Called 2 times
Total time:   0.004144
 Self time:   0.000221

count  total (s)   self (s)
    2              0.000005   if exists('a:palette.ctrlp')
    2              0.000003     let theme = a:palette.ctrlp
                              else
                                let s:color_template = has_key(a:palette, s:color_template) ? s:color_template : 'insert'
                                let theme = airline#extensions#ctrlp#generate_color_map( a:palette[s:color_template]['airline_c'], a:palette[s:color_template]['airline_b'], a:palette[s:color_template]['airline_a'])
    2              0.000001   endif
   20              0.000026   for key in keys(theme)
   18   0.004073   0.000150     call airline#highlighter#exec(key, theme[key])
   20              0.000012   endfor

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:27
Called 128 times
Total time:   0.005154
 Self time:   0.003515

count  total (s)   self (s)
  128   0.003278   0.001639   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
   25              0.000048     if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
   25              0.000014     else
                                  " shorten from beginning of string
   25              0.000178       return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
  103              0.000084   else
  103              0.000172     return a:text
                              endif

FUNCTION  274()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:8
Called 8 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    8              0.000026   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  <SNR>164_StopCursorTimer()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim:55
Called 68 times
Total time:   0.001049
 Self time:   0.001049

count  total (s)   self (s)
   68              0.000218     if s:cursor_timer != -1
   65              0.000392         call timer_stop(s:cursor_timer)
   65              0.000221         let s:cursor_timer = -1
   68              0.000090     endif

FUNCTION  xolox#session#locking_enabled()
    Defined: ~/.vim/plugged/vim-session/autoload/xolox/session.vim:1049
Called 1 time
Total time:   0.000062
 Self time:   0.000024

count  total (s)   self (s)
                              " Check whether session locking is enabled. Returns true (1) when locking is
                              " enabled, false (0) otherwise.
                              "
                              " By default session locking is enabled but users can opt-out by setting
                              " `g:session_lock_enabled` to false (0).
    1   0.000059   0.000021   return xolox#misc#option#get('session_lock_enabled', 1)

FUNCTION  xolox#misc#option#get()
    Defined: ~/.vim/plugged/vim-misc/autoload/xolox/misc/option.vim:7
Called 2 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
                              " Expects one or two arguments: 1. The name of a variable and 2. the default
                              " value if the variable does not exist.
                              "
                              " Returns the value of the variable from a buffer local variable, global
                              " variable or the default value, depending on which is defined.
                              "
                              " This is used by some of my Vim plug-ins for option handling, so that users
                              " can customize options for specific buffers.
    2              0.000013   if exists('b:' . a:name)
                                " Buffer local variable.
                                return eval('b:' . a:name)
    2              0.000012   elseif exists('g:' . a:name)
                                " Global variable.
                                return eval('g:' . a:name)
    2              0.000006   elseif exists('a:1')
                                " Default value.
    1              0.000002     return a:1
    1              0.000001   endif

FUNCTION  <SNR>154_skip()
    Defined: ~/.vim/plugged/vim-signify/autoload/sy.vim:148
Called 3 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    3              0.000022   if getbufvar(a:bufnr, '&diff') || !filereadable(a:path)
    3              0.000006     return 1
                              endif
                            
                              if exists('g:signify_skip_filetype')
                                if has_key(g:signify_skip_filetype, getbufvar(a:bufnr, '&filetype'))
                                  return 1
                                elseif has_key(g:signify_skip_filetype, 'help') && getbufvar(a:bufnr, '&buftype') == 'help'
                                  return 1
                                endif
                              endif
                            
                              if exists('g:signify_skip_filename') && has_key(g:signify_skip_filename, a:path)
                                return 1
                              endif
                            
                              " DEPRECATED: Use g:signify_skip.pattern instead.
                              if exists('g:signify_skip_filename_pattern')
                                for pattern in g:signify_skip_filename_pattern
                                  if a:path =~ pattern
                                    return 1
                                  endif
                                endfor
                              endif
                            
                              if exists('g:signify_skip')
                                if has_key(g:signify_skip, 'pattern')
                                  for pattern in g:signify_skip.pattern
                                    if a:path =~ pattern
                                      return 1
                                    endif
                                  endfor
                                endif
                              endif
                            
                              return 0

FUNCTION  indent_guides#enable()
    Defined: ~/.vim/plugged/vim-indent-guides/autoload/indent_guides.vim:33
Called 1 time
Total time:   0.000047
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000003   let g:indent_guides_autocmds_enabled = 1
                            
    1              0.000002   if &diff || indent_guides#exclude_filetype()
    1   0.000038   0.000006     call indent_guides#clear_matches()
    1              0.000001     return
                              end
                            
                              call indent_guides#init_script_vars()
                              call indent_guides#highlight_colors()
                              call indent_guides#clear_matches()
                            
                              " loop through each indent level and define a highlight pattern
                              " will automagically figure out whether to use tabs or spaces
                              for l:level in range(s:start_level, s:indent_levels)
                                let l:group = 'IndentGuides' . ((l:level % 2 == 0) ? 'Even' : 'Odd')
                                let l:column_start = (l:level - 1) * s:indent_size + 1
                            
                                " define the higlight patterns and add to matches list
                                if g:indent_guides_space_guides
                                  let l:soft_pattern = indent_guides#indent_highlight_pattern(g:indent_guides_soft_pattern, l:column_start, s:guide_size)
                                  call add(w:indent_guides_matches, matchadd(l:group, l:soft_pattern))
                                end
                                if g:indent_guides_tab_guides
                                  let l:hard_pattern = indent_guides#indent_highlight_pattern('\t', l:column_start, s:indent_size)
                                  call add(w:indent_guides_matches, matchadd(l:group, l:hard_pattern))
                                end
                              endfor

FUNCTION  <SNR>131_get_syn()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:37
Called 1384 times
Total time:   0.037268
 Self time:   0.037268

count  total (s)   self (s)
 1384              0.003599   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
 1384              0.000903   endif
 1384              0.001737   let color = ''
 1384              0.003448   if hlexists(a:group)
 1308              0.006646     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
 1384              0.000951   endif
 1384              0.003004   if empty(color) || color == -1
                                " should always exists
  260              0.002095     let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
  260              0.000498     if empty(color) || color == -1
  260              0.000319       let color = 'NONE'
  260              0.000156     endif
 1384              0.000767   endif
 1384              0.001513   return color

FUNCTION  airline#highlighter#reset_hlcache()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim:63
Called 2 times
Total time:   0.000148
 Self time:   0.000148

count  total (s)   self (s)
    2              0.000145   let s:hl_groups = {}

FUNCTION  281()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:62
Called 8 times
Total time:   0.028332
 Self time:   0.004354

count  total (s)   self (s)
    8              0.000009   let side = 1
    8              0.000009   let line = ''
    8              0.000010   let i = 0
    8              0.000018   let length = len(self._sections)
    8              0.000008   let split = 0
    8              0.000010   let is_empty = 0
    8              0.000011   let prev_group = ''
                            
   56              0.000069   while i < length
   48              0.000107     let section = self._sections[i]
   48              0.000086     let group = section[0]
   48              0.000088     let contents = section[1]
   48              0.000069     let pgroup = prev_group
   48   0.000865   0.000336     let prev_group = airline#builder#get_prev_group(self._sections, i)
   48              0.000103     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
   48              0.000127     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
   48              0.000131     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
   48              0.000028     endif
   48              0.000046     if is_empty
                                  let prev_group = pgroup
   48              0.000026     endif
   48   0.000755   0.000327     let is_empty = s:section_is_empty(self, contents)
                            
   48              0.000046     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
   48              0.000032     endif
                            
   48              0.000050     if group == ''
                                  let line .= contents
   48              0.000051     elseif group == '|'
    8              0.000008       let side = 0
    8              0.000013       let line .= contents
    8              0.000009       let split = 1
   40              0.000024     else
   40              0.000045       if prev_group == ''
    8              0.000019         let line .= '%#'.group.'#'
   32              0.000031       elseif split
    8              0.000008         if !is_empty
    8   0.004187   0.000070           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    8              0.000004         endif
    8              0.000008         let split = 0
   24              0.000011       else
   24              0.000023         if !is_empty
   24   0.017747   0.000182           let line .= s:get_seperator(self, prev_group, group, side)
   24              0.000018         endif
   40              0.000019       endif
   40   0.001724   0.000385       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   48              0.000028     endif
                            
   48              0.000086     let i = i + 1
   56              0.000047   endwhile
                            
    8              0.000011   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
    4              0.000131     let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    8              0.000003   endif
    8              0.000009   return line

FUNCTION  282()
    Defined: ~/.vim/plugged/nvim-yarp/autoload/yarp/core.vim:36
Called 2 times
Total time:   0.000294
 Self time:   0.000038

count  total (s)   self (s)
    2   0.000292   0.000036         call yarp#core#error(self.module, a:msg)

FUNCTION  ctrlp#utils#mkdir()
    Defined: ~/.vim/plugged/ctrlp.vim/autoload/ctrlp/utils.vim:56
Called 1 time
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    1              0.000011 	if exists('*mkdir') && !isdirectory(a:dir)
                            		sil! cal mkdir(a:dir, 'p')
    1              0.000001 	en
    1              0.000002 	retu a:dir

FUNCTION  airline#extensions#ctrlp#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ctrlp.vim:69
Called 4 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
    4              0.000021   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  <SNR>166_init_internal_variables()
    Defined: ~/.vim/plugged/deoplete.nvim/autoload/deoplete/init.vim:111
Called 1 time
Total time:   0.094347
 Self time:   0.000404

count  total (s)   self (s)
    1   0.000011   0.000006   call deoplete#init#_prev_completion()
                            
    1              0.000002   let g:deoplete#_context = {}
                            
    1              0.000002   if !exists('g:deoplete#_logging')
    1              0.000022     let g:deoplete#_logging = {}
    1              0.000000   endif
    1              0.000029   unlet! g:deoplete#_initialized
    1              0.000001   try
    1   0.094251   0.000313     let g:deoplete#_serveraddr = deoplete#util#has_yarp() ? neovim_rpc#serveraddr() : v:servername
    1              0.000003     if g:deoplete#_serveraddr ==# ''
                                  " Use NVIM_LISTEN_ADDRESS
                                  let g:deoplete#_serveraddr = $NVIM_LISTEN_ADDRESS
    1              0.000001     endif
                              catch
                                call deoplete#util#print_error(v:exception)
                                call deoplete#util#print_error(v:throwpoint)
                            
                                if !has('python3')
                                  call deoplete#util#print_error( 'deoplete requires Python3 support("+python3").')
                                endif
                            
                                if deoplete#util#has_yarp()
                                  " Dummy call is needed to check exists()
                                  call neovim_rpc#serveraddr()
                                  if !exists('*neovim_rpc#serveraddr')
                                    call deoplete#util#print_error( 'deoplete requires vim-hug-neovim-rpc plugin in Vim.')
                                  endif
                                endif
    1              0.000002   endtry

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim:82
Called 128 times
Total time:   0.000982
 Self time:   0.000982

count  total (s)   self (s)
  128              0.000375   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
  128              0.000114   endif
  128              0.000137   return ''

FUNCTION  neovim_rpc#serveraddr()
    Defined: ~/.vim/plugged/vim-hug-neovim-rpc/autoload/neovim_rpc.vim:17
Called 2 times
Total time:   0.093248
 Self time:   0.001146

count  total (s)   self (s)
    2              0.000007     if exists('g:_neovim_rpc_nvim_server')
    1              0.000002         return g:_neovim_rpc_nvim_server
    1              0.000000     endif
                            
    1              0.000002     if &encoding !=? "utf-8"
                                    throw '[vim-hug-neovim-rpc] requires `:set encoding=utf-8`'
    1              0.000001     endif
                            
    1              0.000001     try
    1   0.085149   0.000010         call s:py('import pynvim')
                                catch
                                    try
                                        call s:py('import neovim')
                                    catch
                                        call neovim_rpc#_error("failed executing: " . g:neovim_rpc#py . " import [pynvim|neovim]")
                                        call neovim_rpc#_error(v:exception)
                                        throw '[vim-hug-neovim-rpc] requires one of `:' . g:neovim_rpc#py . ' import [pynvim|neovim]` command to work'
                                    endtry
    1              0.000001     endtry
                            
    1   0.006984   0.000021     call s:py('import neovim_rpc_server')
    1              0.000863     let l:servers = s:pyeval('neovim_rpc_server.start()')
                            
    1              0.000045     let g:_neovim_rpc_nvim_server     = l:servers[0]
    1              0.000018     let g:_neovim_rpc_vim_server = l:servers[1]
                            
    1              0.000107     let g:_neovim_rpc_main_channel = ch_open(g:_neovim_rpc_vim_server)
                            
                                " identify myself
    1              0.000028     call ch_sendexpr(g:_neovim_rpc_main_channel,'neovim_rpc_setup')
                            
    1              0.000003     return g:_neovim_rpc_nvim_server

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim:62
Called 510 times
Total time:   0.005605
 Self time:   0.005605

count  total (s)   self (s)
  510              0.001803   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  510              0.000467   endif
  510              0.002314   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
    Defined: ~/.vim/plugged/ale/autoload/ale/cursor.vim:103
Called 70 times
Total time:   0.008693
 Self time:   0.006002

count  total (s)   self (s)
   70              0.000581     let l:buffer = bufnr('')
                            
   70              0.000285     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
   70              0.000121     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
   70              0.000319     if mode(1) isnot# 'n'
    2              0.000005         return
   68              0.000074     endif
                            
   68   0.002042   0.000993     call s:StopCursorTimer()
                            
   68              0.000766     let l:pos = getpos('.')[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
   68              0.000232     if l:pos != s:last_pos
   65   0.002439   0.000797         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
   65              0.000232         let s:last_pos = l:pos
   65              0.000583         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
   68              0.000091     endif

FUNCTION  neovim_rpc#_callback()
    Defined: ~/.vim/plugged/vim-hug-neovim-rpc/autoload/neovim_rpc.vim:172
Called 1 time
Total time:   0.000267
 Self time:   0.000267

count  total (s)   self (s)
    1              0.000265     execute g:neovim_rpc#py . ' neovim_rpc_server.process_pending_requests()'

FUNCTION  airline#builder#new()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim:232
Called 8 times
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
    8              0.000035   let builder = copy(s:prototype)
    8              0.000018   let builder._context = a:context
    8              0.000012   let builder._sections = []
                            
    8              0.000062   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    8              0.000009   return builder

FUNCTION  xolox#misc#option#split()
    Defined: ~/.vim/plugged/vim-misc/autoload/xolox/misc/option.vim:28
Called 1 time
Total time:   0.000054
 Self time:   0.000038

count  total (s)   self (s)
                              " Given a multi-value Vim option like ['runtimepath'] [rtp] this returns a
                              " list of strings. For example:
                              "
                              "     :echo xolox#misc#option#split(&runtimepath)
                              "     ['/home/peter/Projects/Vim/misc',
                              "      '/home/peter/Projects/Vim/colorscheme-switcher',
                              "      '/home/peter/Projects/Vim/easytags',
                              "      ...]
                              "
                              " [rtp]: http://vimdoc.sourceforge.net/htmldoc/options.html#'runtimepath'
    1              0.000011   let values = split(a:value, '[^\\]\zs,')
    1   0.000040   0.000024   return map(values, 's:unescape(v:val)')

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    1   0.143979   0.000061  deoplete#enable()
    1   0.141447   0.000013  deoplete#initialize()
    1   0.141434   0.000521  deoplete#init#_initialize()
   10   0.139519   0.022226  airline#highlighter#highlight()
  231   0.115040   0.033970  airline#check_mode()
  440   0.107314   0.028812  airline#highlighter#exec()
    2   0.103412   0.000269  <SNR>91_airline_refresh()
    1   0.094347   0.000404  <SNR>166_init_internal_variables()
    2   0.093248   0.001146  neovim_rpc#serveraddr()
    2   0.092102             <SNR>171_py()
    2   0.085253   0.000200  airline#load_theme()
  692   0.080715   0.038166  airline#highlighter#get_highlight()
    2   0.061728   0.000230  airline#highlighter#load_theme()
  102   0.049626   0.004212  <SNR>131_exec_separator()
    1   0.046294   0.000517  deoplete#init#_channel()
    1   0.043985   0.000014  yarp#core#notify()
    1   0.043971   0.040841  yarp#core#wait_channel()
 1384   0.037268             <SNR>131_get_syn()
    4   0.035441   0.000216  airline#update_statusline()
    8   0.034966   0.000319  <SNR>127_invoke_funcrefs()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
    2              0.092102  <SNR>171_py()
    1   0.043971   0.040841  yarp#core#wait_channel()
  692   0.080715   0.038166  airline#highlighter#get_highlight()
 1384              0.037268  <SNR>131_get_syn()
  231   0.115040   0.033970  airline#check_mode()
  440   0.107314   0.028812  airline#highlighter#exec()
   10   0.139519   0.022226  airline#highlighter#highlight()
  140              0.015817  <SNR>131_GetHiCmd()
  231   0.020403   0.014287  airline#extensions#fugitiveline#bufname()
  896              0.011919  airline#util#append()
   67              0.011581  <SNR>108_Highlight_Matching_Pair()
   65   0.014524   0.011197  anzu#get_on_pattern_pos()
  231              0.006528  airline#util#ignore_buf()
   70   0.008693   0.006002  ale#cursor#EchoCursorWarningWithDelay()
  440              0.005997  <SNR>131_CheckDefined()
   67   0.029237   0.005753  <SNR>97_update_search_status()
  102   0.007524   0.005702  gutentags#inprogress()
  231   0.012160   0.005632  airline#parts#readonly()
  510              0.005605  airline#util#prepend()
  692              0.005281  <SNR>131_get_array()

